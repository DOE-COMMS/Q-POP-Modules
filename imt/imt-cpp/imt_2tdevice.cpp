// This code conforms with the UFC specification version 2018.1.0
// and was automatically generated by FFC version 2019.1.0.post0.
//
// This code was generated with the option '-l dolfin' and
// contains DOLFIN-specific wrappers that depend on DOLFIN.
//
// This code was generated with the following parameters:
//

//  add_tabulate_tensor_timing:     False
//  convert_exceptions_to_warnings: False
//  cpp_optimize:                   True
//  cpp_optimize_flags:             '-O2'
//  epsilon:                        1e-14
//  error_control:                  False
//  external_include_dirs:          ''
//  external_includes:              ''
//  external_libraries:             ''
//  external_library_dirs:          ''
//  form_postfix:                   True
//  format:                         'dolfin'
//  generate_dummy_tabulate_tensor: False
//  max_signature_length:           0
//  optimize:                       True
//  precision:                      None
//  quadrature_degree:              None
//  quadrature_rule:                None
//  representation:                 'auto'
//  split:                          True

#include "VO2_2tdevice.h"

vo2_2tdevice_finite_element_0::vo2_2tdevice_finite_element_0() : ufc::finite_element()
{
    // Do nothing
}

vo2_2tdevice_finite_element_0::~vo2_2tdevice_finite_element_0()
{
    // Do nothing
}

const char * vo2_2tdevice_finite_element_0::signature() const
{
    return "FiniteElement('Lagrange', triangle, 1)";
}

ufc::shape vo2_2tdevice_finite_element_0::cell_shape() const
{
    return ufc::shape::triangle;
}

std::size_t vo2_2tdevice_finite_element_0::topological_dimension() const
{
    return 2;
}

std::size_t vo2_2tdevice_finite_element_0::geometric_dimension() const
{
    return 2;
}

std::size_t vo2_2tdevice_finite_element_0::space_dimension() const
{
    return 3;
}

std::size_t vo2_2tdevice_finite_element_0::value_rank() const
{
    return 0;
}

std::size_t vo2_2tdevice_finite_element_0::value_dimension(std::size_t i) const
{
    return 1;
}

std::size_t vo2_2tdevice_finite_element_0::value_size() const
{
    return 1;
}

std::size_t vo2_2tdevice_finite_element_0::reference_value_rank() const
{
    return 0;
}

std::size_t vo2_2tdevice_finite_element_0::reference_value_dimension(std::size_t i) const
{
    return 1;
}

std::size_t vo2_2tdevice_finite_element_0::reference_value_size() const
{
    return 1;
}

std::size_t vo2_2tdevice_finite_element_0::degree() const
{
    return 1;
}

const char * vo2_2tdevice_finite_element_0::family() const
{
    return "Lagrange";
}

void vo2_2tdevice_finite_element_0::evaluate_reference_basis(double * reference_values,
                                             std::size_t num_points,
                                             const double * X) const
{
    static const double coefficients0[1][3] = { { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients1[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients2[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
    for (std::size_t k = 0; k < num_points * 3; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[3] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
        basisvalues1[0] *= std::sqrt(0.5);
        basisvalues1[2] *= std::sqrt(1.0);
        basisvalues1[1] *= std::sqrt(3.0);
        // Accumulate products of coefficients and basisvalues
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[3 * ip] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[3 * ip + 1] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[3 * ip + 2] += coefficients2[0][r] * basisvalues1[r];
    }
}

void vo2_2tdevice_finite_element_0::evaluate_reference_basis_derivatives(double * reference_values,
                                                         std::size_t order,
                                                         std::size_t num_points,
                                                         const double * X) const
{
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(2, order);
    std::fill_n(reference_values, num_points * 3 * num_derivatives, 0.0);
    if (order > 1)
        return;
    // Tables of derivatives of the polynomial base (transpose).
    alignas(32) static const double dmats0[2][3][3] =
        { { { 0.0, 0.0, 0.0 },
            { 4.8989794855663495, 0.0, 0.0 },
            { 0.0, 0.0, 0.0 } },
          { { 0.0, 0.0, 0.0 },
            { 2.449489742783182, 0.0, 0.0 },
            { 4.242640687119285, 0.0, 0.0 } } };
    static const double coefficients0[1][3] = { { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients1[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients2[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
    const std::size_t reference_offset[3] = {};
    const std::size_t num_components[3] = { 1, 1, 1 };
    // Precomputed combinations
    const std::size_t combinations[1][2][1] =
        { { { 0 },
            { 1 } } };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[3] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
        basisvalues1[0] *= std::sqrt(0.5);
        basisvalues1[2] *= std::sqrt(1.0);
        basisvalues1[1] *= std::sqrt(3.0);
        // Loop over all dofs
        for (std::size_t i = 0; i < 3; ++i)
        {
            double derivatives[2] = {};
            switch (i)
            {
            case 0:
                // Compute reference derivatives for dof 0.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 1:
                // Compute reference derivatives for dof 1.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 2:
                // Compute reference derivatives for dof 2.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            }
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t c = 0; c < num_components[i]; ++c)
                    reference_values[3 * num_derivatives * ip + num_derivatives * i + r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
        }
    }
}

void vo2_2tdevice_finite_element_0::transform_reference_basis_derivatives(double * values,
                                                          std::size_t order,
                                                          std::size_t num_points,
                                                          const double * reference_values,
                                                          const double * X,
                                                          const double * J,
                                                          const double * detJ,
                                                          const double * K,
                                                          int cell_orientation) const
{
    const std::size_t num_derivatives = std::pow(2, order);
    // Precomputed combinations
    const std::size_t combinations[1][2][1] =
        { { { 0 },
            { 1 } } };
    std::fill_n(values, num_points * 3 * num_derivatives, 0.0);
    const std::size_t reference_offsets[3] = {};
    const std::size_t physical_offsets[3] = {};
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[2][2];
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                transform[r][s] = 1.0;
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                for (std::size_t k = 0; k < order; ++k)
                    transform[r][s] *= K[2 * 2 * ip + 2 * combinations[order - 1][s][k] + combinations[order - 1][r][k]];
        for (std::size_t d = 0; d < 3; ++d)
        {
            for (std::size_t s = 0; s < num_derivatives; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[3 * num_derivatives * ip + num_derivatives * d + s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < num_derivatives; ++r)
                        values[3 * num_derivatives * ip + num_derivatives * d + r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
}

void vo2_2tdevice_finite_element_0::evaluate_basis(std::size_t i,
                                   double * values,
                                   const double * x,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    double X[2] = {};
    double J[4];
    double detJ;
    double K[4];
    if (cm)
    {
        cm->compute_reference_geometry(X, J, &detJ, K, 1, x, coordinate_dofs, cell_orientation);
    }
    else
    {
        compute_jacobian_triangle_2d(J, coordinate_dofs);
        compute_jacobian_inverse_triangle_2d(K, detJ, J);
        // Compute constants
        const double C0 = coordinate_dofs[2] + coordinate_dofs[4];
        const double C1 = coordinate_dofs[3] + coordinate_dofs[5];
        // Get coordinates and map to the reference (FIAT) element
        double Y[2] = { (J[1] * (C1 - 2.0 * x[1]) + J[3] * (2.0 * x[0] - C0)) / detJ, (J[0] * (2.0 * x[1] - C1) + J[2] * (C0 - 2.0 * x[0])) / detJ };
        // Map to FFC reference coordinate
        for (std::size_t k = 0; k < 2; ++k)
            X[k] = (Y[k] + 1.0) / 2.0;
    }
    // Evaluate basis on reference element
    double ref_values[3];
    evaluate_reference_basis(ref_values, 1, X);
    // Push forward
    double physical_values[3];
    transform_reference_basis_derivatives(physical_values, 0, 1, ref_values, X, J, &detJ, K, cell_orientation);
    for (std::size_t k = 0; k < 1; ++k)
        values[k] = physical_values[i + k];
}

void vo2_2tdevice_finite_element_0::evaluate_basis_all(double * values,
                                       const double * x,
                                       const double * coordinate_dofs,
                                       int cell_orientation,
                                       const ufc::coordinate_mapping * cm
                                       ) const
{
    // Helper variable to hold value of a single dof.
    double dof_values = 0.0;
    // Loop dofs and call evaluate_basis
    for (std::size_t r = 0; r < 3; ++r)
    {
        evaluate_basis(r, &dof_values, x, coordinate_dofs, cell_orientation);
        values[r] = dof_values;
    }
}

void vo2_2tdevice_finite_element_0::evaluate_basis_derivatives(std::size_t i,
                                               std::size_t n,
                                               double * values,
                                               const double * x,
                                               const double * coordinate_dofs,
                                               int cell_orientation,
                                               const ufc::coordinate_mapping * cm
                                               ) const
{
    std::size_t num_derivatives = std::pow(2, n);
    std::fill_n(values, num_derivatives, 0.0);
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
        return;
    }
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
        return;
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, coordinate_dofs);
    // Compute Inverse Jacobian and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    // Compute constants
    const double C0 = coordinate_dofs[2] + coordinate_dofs[4];
    const double C1 = coordinate_dofs[3] + coordinate_dofs[5];
    // Get coordinates and map to the reference (FIAT) element
    double Y[2] = { (J[1] * (C1 - 2.0 * x[1]) + J[3] * (2.0 * x[0] - C0)) / detJ, (J[0] * (2.0 * x[1] - C1) + J[2] * (C0 - 2.0 * x[0])) / detJ };
    // Precomputed combinations
    const std::size_t combinations[1][2][1] =
        { { { 0 },
            { 1 } } };
    // Declare transformation matrix
    double transform[2][2] =
        { { 1.0, 1.0 },
          { 1.0, 1.0 } };
    // Construct transformation matrix
    for (std::size_t row = 0; row < num_derivatives; ++row)
        for (std::size_t col = 0; col < num_derivatives; ++col)
            for (std::size_t k = 0; k < n; ++k)
                transform[row][col] *= K[2 * combinations[n - 1][col][k] + combinations[n - 1][row][k]];
    switch (i)
    {
    case 0:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 1:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 2:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, 0.0, 0.3333333333333333 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    }
}

void vo2_2tdevice_finite_element_0::evaluate_basis_derivatives_all(std::size_t n,
                                                   double * values,
                                                   const double * x,
                                                   const double * coordinate_dofs,
                                                   int cell_orientation,
                                                   const ufc::coordinate_mapping * cm
                                                   ) const
{
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
        return;
    }
    unsigned int num_derivatives = std::pow(2, n);
    // Set values equal to zero.
    std::fill_n(values, num_derivatives * 3, 0.0);
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
        return;
    // Helper variable to hold values of a single dof.
    double dof_values[2] = {};
    // Loop dofs and call evaluate_basis_derivatives.
    for (std::size_t r = 0; r < 3; ++r)
    {
        evaluate_basis_derivatives(r, n, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < num_derivatives; ++s)
            values[num_derivatives * r + s] = dof_values[s];
    }
}

double vo2_2tdevice_finite_element_0::evaluate_dof(std::size_t i,
                                   const ufc::function& f,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::cell& c,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 1:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 2:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    }
    return 0.0;
}

void vo2_2tdevice_finite_element_0::evaluate_dofs(double * values,
                                  const ufc::function& f,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::cell& c,
                                  const ufc::coordinate_mapping * cm
                                  ) const
{
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[2];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
}

void vo2_2tdevice_finite_element_0::interpolate_vertex_values(double * vertex_values,
                                              const double * dof_values,
                                              const double * coordinate_dofs,
                                              int cell_orientation,
                                              const ufc::coordinate_mapping * cm
                                              ) const
{
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
}

void vo2_2tdevice_finite_element_0::tabulate_dof_coordinates(double * dof_coordinates,
                                             const double * coordinate_dofs,
                                             const ufc::coordinate_mapping * cm
                                             ) const
{
    dof_coordinates[0] = coordinate_dofs[0];
    dof_coordinates[1] = coordinate_dofs[1];
    dof_coordinates[2] = coordinate_dofs[2];
    dof_coordinates[2 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 2] = coordinate_dofs[4];
    dof_coordinates[2 * 2 + 1] = coordinate_dofs[5];
}

void vo2_2tdevice_finite_element_0::tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const
{
    static const double dof_X[6] = { 0.0, 0.0, 1.0, 0.0, 0.0, 1.0 };
    std::copy_n(dof_X, 6, reference_dof_coordinates);
}

std::size_t vo2_2tdevice_finite_element_0::num_sub_elements() const
{
    return 0;
}

ufc::finite_element * vo2_2tdevice_finite_element_0::create_sub_element(std::size_t i) const
{
    return nullptr;
}

ufc::finite_element * vo2_2tdevice_finite_element_0::create() const
{
    return new vo2_2tdevice_finite_element_0();
}


vo2_2tdevice_finite_element_1::vo2_2tdevice_finite_element_1() : ufc::finite_element()
{
    // Do nothing
}

vo2_2tdevice_finite_element_1::~vo2_2tdevice_finite_element_1()
{
    // Do nothing
}

const char * vo2_2tdevice_finite_element_1::signature() const
{
    return "VectorElement(FiniteElement('Lagrange', triangle, 1), dim=2)";
}

ufc::shape vo2_2tdevice_finite_element_1::cell_shape() const
{
    return ufc::shape::triangle;
}

std::size_t vo2_2tdevice_finite_element_1::topological_dimension() const
{
    return 2;
}

std::size_t vo2_2tdevice_finite_element_1::geometric_dimension() const
{
    return 2;
}

std::size_t vo2_2tdevice_finite_element_1::space_dimension() const
{
    return 6;
}

std::size_t vo2_2tdevice_finite_element_1::value_rank() const
{
    return 1;
}

std::size_t vo2_2tdevice_finite_element_1::value_dimension(std::size_t i) const
{
    static const int return_values[1] = { 2 };
    if (i >= 1)
        return 1;
    return return_values[i];
}

std::size_t vo2_2tdevice_finite_element_1::value_size() const
{
    return 2;
}

std::size_t vo2_2tdevice_finite_element_1::reference_value_rank() const
{
    return 1;
}

std::size_t vo2_2tdevice_finite_element_1::reference_value_dimension(std::size_t i) const
{
    static const int return_values[1] = { 2 };
    if (i >= 1)
        return 1;
    return return_values[i];
}

std::size_t vo2_2tdevice_finite_element_1::reference_value_size() const
{
    return 2;
}

std::size_t vo2_2tdevice_finite_element_1::degree() const
{
    return 1;
}

const char * vo2_2tdevice_finite_element_1::family() const
{
    return "Lagrange";
}

void vo2_2tdevice_finite_element_1::evaluate_reference_basis(double * reference_values,
                                             std::size_t num_points,
                                             const double * X) const
{
    static const double coefficients0[1][3] = { { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients1[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients2[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
    for (std::size_t k = 0; k < num_points * 6 * 2; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[3] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
        basisvalues1[0] *= std::sqrt(0.5);
        basisvalues1[2] *= std::sqrt(1.0);
        basisvalues1[1] *= std::sqrt(3.0);
        // Accumulate products of coefficients and basisvalues
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[6 * 2 * ip] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[6 * 2 * ip + 2] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[6 * 2 * ip + 2 * 2] += coefficients2[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[6 * 2 * ip + 2 * 3 + 1] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[6 * 2 * ip + 2 * 4 + 1] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[6 * 2 * ip + 2 * 5 + 1] += coefficients2[0][r] * basisvalues1[r];
    }
}

void vo2_2tdevice_finite_element_1::evaluate_reference_basis_derivatives(double * reference_values,
                                                         std::size_t order,
                                                         std::size_t num_points,
                                                         const double * X) const
{
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(2, order);
    std::fill_n(reference_values, num_points * 6 * num_derivatives * 2, 0.0);
    if (order > 1)
        return;
    // Tables of derivatives of the polynomial base (transpose).
    alignas(32) static const double dmats0[2][3][3] =
        { { { 0.0, 0.0, 0.0 },
            { 4.8989794855663495, 0.0, 0.0 },
            { 0.0, 0.0, 0.0 } },
          { { 0.0, 0.0, 0.0 },
            { 2.449489742783182, 0.0, 0.0 },
            { 4.242640687119285, 0.0, 0.0 } } };
    static const double coefficients0[1][3] = { { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients1[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients2[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
    const std::size_t reference_offset[6] = { 0, 0, 0, 1, 1, 1 };
    const std::size_t num_components[6] = { 1, 1, 1, 1, 1, 1 };
    // Precomputed combinations
    const std::size_t combinations[1][2][1] =
        { { { 0 },
            { 1 } } };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[3] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
        basisvalues1[0] *= std::sqrt(0.5);
        basisvalues1[2] *= std::sqrt(1.0);
        basisvalues1[1] *= std::sqrt(3.0);
        // Loop over all dofs
        for (std::size_t i = 0; i < 6; ++i)
        {
            double derivatives[2] = {};
            switch (i)
            {
            case 0:
                // Compute reference derivatives for dof 0.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 1:
                // Compute reference derivatives for dof 1.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 2:
                // Compute reference derivatives for dof 2.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 3:
                // Compute reference derivatives for dof 3.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 4:
                // Compute reference derivatives for dof 4.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 5:
                // Compute reference derivatives for dof 5.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            }
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t c = 0; c < num_components[i]; ++c)
                    reference_values[6 * (num_derivatives * 2) * ip + num_derivatives * 2 * i + 2 * r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
        }
    }
}

void vo2_2tdevice_finite_element_1::transform_reference_basis_derivatives(double * values,
                                                          std::size_t order,
                                                          std::size_t num_points,
                                                          const double * reference_values,
                                                          const double * X,
                                                          const double * J,
                                                          const double * detJ,
                                                          const double * K,
                                                          int cell_orientation) const
{
    const std::size_t num_derivatives = std::pow(2, order);
    // Precomputed combinations
    const std::size_t combinations[1][2][1] =
        { { { 0 },
            { 1 } } };
    std::fill_n(values, num_points * 6 * num_derivatives * 2, 0.0);
    const std::size_t reference_offsets[6] = { 0, 0, 0, 1, 1, 1 };
    const std::size_t physical_offsets[6] = { 0, 0, 0, 1, 1, 1 };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[2][2];
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                transform[r][s] = 1.0;
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                for (std::size_t k = 0; k < order; ++k)
                    transform[r][s] *= K[2 * 2 * ip + 2 * combinations[order - 1][s][k] + combinations[order - 1][r][k]];
        for (std::size_t d = 0; d < 6; ++d)
        {
            for (std::size_t s = 0; s < num_derivatives; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[6 * (num_derivatives * 2) * ip + num_derivatives * 2 * d + 2 * s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < num_derivatives; ++r)
                        values[6 * (num_derivatives * 2) * ip + num_derivatives * 2 * d + 2 * r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
}

void vo2_2tdevice_finite_element_1::evaluate_basis(std::size_t i,
                                   double * values,
                                   const double * x,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    double X[2] = {};
    double J[4];
    double detJ;
    double K[4];
    if (cm)
    {
        cm->compute_reference_geometry(X, J, &detJ, K, 1, x, coordinate_dofs, cell_orientation);
    }
    else
    {
        compute_jacobian_triangle_2d(J, coordinate_dofs);
        compute_jacobian_inverse_triangle_2d(K, detJ, J);
        // Compute constants
        const double C0 = coordinate_dofs[2] + coordinate_dofs[4];
        const double C1 = coordinate_dofs[3] + coordinate_dofs[5];
        // Get coordinates and map to the reference (FIAT) element
        double Y[2] = { (J[1] * (C1 - 2.0 * x[1]) + J[3] * (2.0 * x[0] - C0)) / detJ, (J[0] * (2.0 * x[1] - C1) + J[2] * (C0 - 2.0 * x[0])) / detJ };
        // Map to FFC reference coordinate
        for (std::size_t k = 0; k < 2; ++k)
            X[k] = (Y[k] + 1.0) / 2.0;
    }
    // Evaluate basis on reference element
    double ref_values[12];
    evaluate_reference_basis(ref_values, 1, X);
    // Push forward
    double physical_values[12];
    transform_reference_basis_derivatives(physical_values, 0, 1, ref_values, X, J, &detJ, K, cell_orientation);
    for (std::size_t k = 0; k < 2; ++k)
        values[k] = physical_values[2 * i + k];
}

void vo2_2tdevice_finite_element_1::evaluate_basis_all(double * values,
                                       const double * x,
                                       const double * coordinate_dofs,
                                       int cell_orientation,
                                       const ufc::coordinate_mapping * cm
                                       ) const
{
    // Helper variable to hold values of a single dof.
    double dof_values[2] = {};
    // Loop dofs and call evaluate_basis
    for (std::size_t r = 0; r < 6; ++r)
    {
        evaluate_basis(r, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 2; ++s)
            values[r * 2 + s] = dof_values[s];
    }
}

void vo2_2tdevice_finite_element_1::evaluate_basis_derivatives(std::size_t i,
                                               std::size_t n,
                                               double * values,
                                               const double * x,
                                               const double * coordinate_dofs,
                                               int cell_orientation,
                                               const ufc::coordinate_mapping * cm
                                               ) const
{
    std::size_t num_derivatives = std::pow(2, n);
    std::fill_n(values, 2 * num_derivatives, 0.0);
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
        return;
    }
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
        return;
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, coordinate_dofs);
    // Compute Inverse Jacobian and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    // Compute constants
    const double C0 = coordinate_dofs[2] + coordinate_dofs[4];
    const double C1 = coordinate_dofs[3] + coordinate_dofs[5];
    // Get coordinates and map to the reference (FIAT) element
    double Y[2] = { (J[1] * (C1 - 2.0 * x[1]) + J[3] * (2.0 * x[0] - C0)) / detJ, (J[0] * (2.0 * x[1] - C1) + J[2] * (C0 - 2.0 * x[0])) / detJ };
    // Precomputed combinations
    const std::size_t combinations[1][2][1] =
        { { { 0 },
            { 1 } } };
    // Declare transformation matrix
    double transform[2][2] =
        { { 1.0, 1.0 },
          { 1.0, 1.0 } };
    // Construct transformation matrix
    for (std::size_t row = 0; row < num_derivatives; ++row)
        for (std::size_t col = 0; col < num_derivatives; ++col)
            for (std::size_t k = 0; k < n; ++k)
                transform[row][col] *= K[2 * combinations[n - 1][col][k] + combinations[n - 1][row][k]];
    switch (i)
    {
    case 0:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 1:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 2:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, 0.0, 0.3333333333333333 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 3:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 4:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 5:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, 0.0, 0.3333333333333333 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    }
}

void vo2_2tdevice_finite_element_1::evaluate_basis_derivatives_all(std::size_t n,
                                                   double * values,
                                                   const double * x,
                                                   const double * coordinate_dofs,
                                                   int cell_orientation,
                                                   const ufc::coordinate_mapping * cm
                                                   ) const
{
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
        return;
    }
    unsigned int num_derivatives = std::pow(2, n);
    // Set values equal to zero.
    std::fill_n(values, 2 * num_derivatives * 6, 0.0);
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
        return;
    // Helper variable to hold values of a single dof.
    double dof_values[4] = {};
    // Loop dofs and call evaluate_basis_derivatives.
    for (std::size_t r = 0; r < 6; ++r)
    {
        evaluate_basis_derivatives(r, n, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 2 * num_derivatives; ++s)
            values[2 * num_derivatives * r + s] = dof_values[s];
    }
}

double vo2_2tdevice_finite_element_1::evaluate_dof(std::size_t i,
                                   const ufc::function& f,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::cell& c,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    // Declare variables for result of evaluation
    double vals[2];
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 1:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 2:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 3:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 4:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 5:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    }
    return 0.0;
}

void vo2_2tdevice_finite_element_1::evaluate_dofs(double * values,
                                  const ufc::function& f,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::cell& c,
                                  const ufc::coordinate_mapping * cm
                                  ) const
{
    // Declare variables for result of evaluation
    double vals[2];
    // Declare variable for physical coordinates
    double y[2];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[3] = vals[1];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[4] = vals[1];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[5] = vals[1];
}

void vo2_2tdevice_finite_element_1::interpolate_vertex_values(double * vertex_values,
                                              const double * dof_values,
                                              const double * coordinate_dofs,
                                              int cell_orientation,
                                              const ufc::coordinate_mapping * cm
                                              ) const
{
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[2] = dof_values[1];
    vertex_values[4] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[3];
    vertex_values[3] = dof_values[4];
    vertex_values[5] = dof_values[5];
}

void vo2_2tdevice_finite_element_1::tabulate_dof_coordinates(double * dof_coordinates,
                                             const double * coordinate_dofs,
                                             const ufc::coordinate_mapping * cm
                                             ) const
{
    dof_coordinates[0] = coordinate_dofs[0];
    dof_coordinates[1] = coordinate_dofs[1];
    dof_coordinates[2] = coordinate_dofs[2];
    dof_coordinates[2 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 2] = coordinate_dofs[4];
    dof_coordinates[2 * 2 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 3] = coordinate_dofs[0];
    dof_coordinates[2 * 3 + 1] = coordinate_dofs[1];
    dof_coordinates[2 * 4] = coordinate_dofs[2];
    dof_coordinates[2 * 4 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 5] = coordinate_dofs[4];
    dof_coordinates[2 * 5 + 1] = coordinate_dofs[5];
}

void vo2_2tdevice_finite_element_1::tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const
{
    static const double dof_X[12] = { 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0 };
    std::copy_n(dof_X, 12, reference_dof_coordinates);
}

std::size_t vo2_2tdevice_finite_element_1::num_sub_elements() const
{
    return 2;
}

ufc::finite_element * vo2_2tdevice_finite_element_1::create_sub_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new vo2_2tdevice_finite_element_0();
    case 1:
        return new vo2_2tdevice_finite_element_0();
    default:
        return nullptr;
    }
}

ufc::finite_element * vo2_2tdevice_finite_element_1::create() const
{
    return new vo2_2tdevice_finite_element_1();
}


vo2_2tdevice_finite_element_2::vo2_2tdevice_finite_element_2() : ufc::finite_element()
{
    // Do nothing
}

vo2_2tdevice_finite_element_2::~vo2_2tdevice_finite_element_2()
{
    // Do nothing
}

const char * vo2_2tdevice_finite_element_2::signature() const
{
    return "FiniteElement('Real', triangle, 0)";
}

ufc::shape vo2_2tdevice_finite_element_2::cell_shape() const
{
    return ufc::shape::triangle;
}

std::size_t vo2_2tdevice_finite_element_2::topological_dimension() const
{
    return 2;
}

std::size_t vo2_2tdevice_finite_element_2::geometric_dimension() const
{
    return 2;
}

std::size_t vo2_2tdevice_finite_element_2::space_dimension() const
{
    return 1;
}

std::size_t vo2_2tdevice_finite_element_2::value_rank() const
{
    return 0;
}

std::size_t vo2_2tdevice_finite_element_2::value_dimension(std::size_t i) const
{
    return 1;
}

std::size_t vo2_2tdevice_finite_element_2::value_size() const
{
    return 1;
}

std::size_t vo2_2tdevice_finite_element_2::reference_value_rank() const
{
    return 0;
}

std::size_t vo2_2tdevice_finite_element_2::reference_value_dimension(std::size_t i) const
{
    return 1;
}

std::size_t vo2_2tdevice_finite_element_2::reference_value_size() const
{
    return 1;
}

std::size_t vo2_2tdevice_finite_element_2::degree() const
{
    return 0;
}

const char * vo2_2tdevice_finite_element_2::family() const
{
    return "Real";
}

void vo2_2tdevice_finite_element_2::evaluate_reference_basis(double * reference_values,
                                             std::size_t num_points,
                                             const double * X) const
{
    static const double coefficients0[1][1] = { { 1.0 } };
    for (std::size_t k = 0; k < num_points; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Compute basisvalues for each relevant embedded degree
        double basisvalues0[1] = {};
        basisvalues0[0] = 1.0;
        // Accumulate products of coefficients and basisvalues
        reference_values[ip] += coefficients0[0][0] * basisvalues0[0];
    }
}

void vo2_2tdevice_finite_element_2::evaluate_reference_basis_derivatives(double * reference_values,
                                                         std::size_t order,
                                                         std::size_t num_points,
                                                         const double * X) const
{
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(2, order);
    std::fill_n(reference_values, num_points * num_derivatives, 0.0);
    if (order > 0)
        return;
}

void vo2_2tdevice_finite_element_2::transform_reference_basis_derivatives(double * values,
                                                          std::size_t order,
                                                          std::size_t num_points,
                                                          const double * reference_values,
                                                          const double * X,
                                                          const double * J,
                                                          const double * detJ,
                                                          const double * K,
                                                          int cell_orientation) const
{
    std::fill_n(values, num_points, 0.0);
    const std::size_t reference_offsets[1] = {};
    const std::size_t physical_offsets[1] = {};
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[1][1];
        for (std::size_t r = 0; r < 1; ++r)
            for (std::size_t s = 0; s < 1; ++s)
                transform[r][s] = 1.0;
        for (std::size_t d = 0; d < 1; ++d)
        {
            for (std::size_t s = 0; s < 1; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[ip + d + s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < 1; ++r)
                        values[ip + d + r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
}

void vo2_2tdevice_finite_element_2::evaluate_basis(std::size_t i,
                                   double * values,
                                   const double * x,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    double X[2] = {};
    double J[4];
    double detJ;
    double K[4];
    if (cm)
    {
        cm->compute_reference_geometry(X, J, &detJ, K, 1, x, coordinate_dofs, cell_orientation);
    }
    else
    {
        compute_jacobian_triangle_2d(J, coordinate_dofs);
        compute_jacobian_inverse_triangle_2d(K, detJ, J);
    }
    // Evaluate basis on reference element
    double ref_values[1];
    evaluate_reference_basis(ref_values, 1, X);
    // Push forward
    double physical_values[1];
    transform_reference_basis_derivatives(physical_values, 0, 1, ref_values, X, J, &detJ, K, cell_orientation);
    for (std::size_t k = 0; k < 1; ++k)
        values[k] = physical_values[i + k];
}

void vo2_2tdevice_finite_element_2::evaluate_basis_all(double * values,
                                       const double * x,
                                       const double * coordinate_dofs,
                                       int cell_orientation,
                                       const ufc::coordinate_mapping * cm
                                       ) const
{
    // Element is constant, calling evaluate_basis.
    evaluate_basis(0, values, x, coordinate_dofs, cell_orientation);
}

void vo2_2tdevice_finite_element_2::evaluate_basis_derivatives(std::size_t i,
                                               std::size_t n,
                                               double * values,
                                               const double * x,
                                               const double * coordinate_dofs,
                                               int cell_orientation,
                                               const ufc::coordinate_mapping * cm
                                               ) const
{
    std::size_t num_derivatives = std::pow(2, n);
    std::fill_n(values, num_derivatives, 0.0);
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
        return;
    }
}

void vo2_2tdevice_finite_element_2::evaluate_basis_derivatives_all(std::size_t n,
                                                   double * values,
                                                   const double * x,
                                                   const double * coordinate_dofs,
                                                   int cell_orientation,
                                                   const ufc::coordinate_mapping * cm
                                                   ) const
{
    // Element is constant, calling evaluate_basis_derivatives.
    evaluate_basis_derivatives(0, n, values, x, coordinate_dofs, cell_orientation);
}

double vo2_2tdevice_finite_element_2::evaluate_dof(std::size_t i,
                                   const ufc::function& f,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::cell& c,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
        {
            y[0] = 0.3333333333333334 * coordinate_dofs[0] + 0.3333333333333333 * coordinate_dofs[2] + 0.3333333333333333 * coordinate_dofs[4];
            y[1] = 0.3333333333333334 * coordinate_dofs[1] + 0.3333333333333333 * coordinate_dofs[3] + 0.3333333333333333 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    }
    return 0.0;
}

void vo2_2tdevice_finite_element_2::evaluate_dofs(double * values,
                                  const ufc::function& f,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::cell& c,
                                  const ufc::coordinate_mapping * cm
                                  ) const
{
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[2];
    y[0] = 0.3333333333333334 * coordinate_dofs[0] + 0.3333333333333333 * coordinate_dofs[2] + 0.3333333333333333 * coordinate_dofs[4];
    y[1] = 0.3333333333333334 * coordinate_dofs[1] + 0.3333333333333333 * coordinate_dofs[3] + 0.3333333333333333 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
}

void vo2_2tdevice_finite_element_2::interpolate_vertex_values(double * vertex_values,
                                              const double * dof_values,
                                              const double * coordinate_dofs,
                                              int cell_orientation,
                                              const ufc::coordinate_mapping * cm
                                              ) const
{
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[0];
    vertex_values[2] = dof_values[0];
}

void vo2_2tdevice_finite_element_2::tabulate_dof_coordinates(double * dof_coordinates,
                                             const double * coordinate_dofs,
                                             const ufc::coordinate_mapping * cm
                                             ) const
{
    dof_coordinates[0] = 0.3333333333333334 * coordinate_dofs[0] + 0.3333333333333333 * coordinate_dofs[2] + 0.3333333333333333 * coordinate_dofs[4];
    dof_coordinates[1] = 0.3333333333333334 * coordinate_dofs[1] + 0.3333333333333333 * coordinate_dofs[3] + 0.3333333333333333 * coordinate_dofs[5];
}

void vo2_2tdevice_finite_element_2::tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const
{
    static const double dof_X[2] = { 0.3333333333333333, 0.3333333333333333 };
    std::copy_n(dof_X, 2, reference_dof_coordinates);
}

std::size_t vo2_2tdevice_finite_element_2::num_sub_elements() const
{
    return 0;
}

ufc::finite_element * vo2_2tdevice_finite_element_2::create_sub_element(std::size_t i) const
{
    return nullptr;
}

ufc::finite_element * vo2_2tdevice_finite_element_2::create() const
{
    return new vo2_2tdevice_finite_element_2();
}


vo2_2tdevice_finite_element_3::vo2_2tdevice_finite_element_3() : ufc::finite_element()
{
    // Do nothing
}

vo2_2tdevice_finite_element_3::~vo2_2tdevice_finite_element_3()
{
    // Do nothing
}

const char * vo2_2tdevice_finite_element_3::signature() const
{
    return "MixedElement(FiniteElement('Lagrange', triangle, 1), FiniteElement('Lagrange', triangle, 1), FiniteElement('Lagrange', triangle, 1), FiniteElement('Lagrange', triangle, 1), FiniteElement('Lagrange', triangle, 1), FiniteElement('Lagrange', triangle, 1), FiniteElement('Real', triangle, 0))";
}

ufc::shape vo2_2tdevice_finite_element_3::cell_shape() const
{
    return ufc::shape::triangle;
}

std::size_t vo2_2tdevice_finite_element_3::topological_dimension() const
{
    return 2;
}

std::size_t vo2_2tdevice_finite_element_3::geometric_dimension() const
{
    return 2;
}

std::size_t vo2_2tdevice_finite_element_3::space_dimension() const
{
    return 19;
}

std::size_t vo2_2tdevice_finite_element_3::value_rank() const
{
    return 1;
}

std::size_t vo2_2tdevice_finite_element_3::value_dimension(std::size_t i) const
{
    static const int return_values[1] = { 7 };
    if (i >= 1)
        return 1;
    return return_values[i];
}

std::size_t vo2_2tdevice_finite_element_3::value_size() const
{
    return 7;
}

std::size_t vo2_2tdevice_finite_element_3::reference_value_rank() const
{
    return 1;
}

std::size_t vo2_2tdevice_finite_element_3::reference_value_dimension(std::size_t i) const
{
    static const int return_values[1] = { 7 };
    if (i >= 1)
        return 1;
    return return_values[i];
}

std::size_t vo2_2tdevice_finite_element_3::reference_value_size() const
{
    return 7;
}

std::size_t vo2_2tdevice_finite_element_3::degree() const
{
    return 1;
}

const char * vo2_2tdevice_finite_element_3::family() const
{
    return "Mixed";
}

void vo2_2tdevice_finite_element_3::evaluate_reference_basis(double * reference_values,
                                             std::size_t num_points,
                                             const double * X) const
{
    static const double coefficients0[1][3] = { { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients1[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients2[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
    static const double coefficients18[1][1] = { { 1.0 } };
    for (std::size_t k = 0; k < num_points * 19 * 7; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[3] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
        basisvalues1[0] *= std::sqrt(0.5);
        basisvalues1[2] *= std::sqrt(1.0);
        basisvalues1[1] *= std::sqrt(3.0);
        double basisvalues0[1] = {};
        basisvalues0[0] = 1.0;
        // Accumulate products of coefficients and basisvalues
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[19 * 7 * ip] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[19 * 7 * ip + 7] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[19 * 7 * ip + 7 * 2] += coefficients2[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[19 * 7 * ip + 7 * 3 + 1] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[19 * 7 * ip + 7 * 4 + 1] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[19 * 7 * ip + 7 * 5 + 1] += coefficients2[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[19 * 7 * ip + 7 * 6 + 2] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[19 * 7 * ip + 7 * 7 + 2] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[19 * 7 * ip + 7 * 8 + 2] += coefficients2[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[19 * 7 * ip + 7 * 9 + 3] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[19 * 7 * ip + 7 * 10 + 3] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[19 * 7 * ip + 7 * 11 + 3] += coefficients2[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[19 * 7 * ip + 7 * 12 + 4] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[19 * 7 * ip + 7 * 13 + 4] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[19 * 7 * ip + 7 * 14 + 4] += coefficients2[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[19 * 7 * ip + 7 * 15 + 5] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[19 * 7 * ip + 7 * 16 + 5] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[19 * 7 * ip + 7 * 17 + 5] += coefficients2[0][r] * basisvalues1[r];
        reference_values[19 * 7 * ip + 7 * 18 + 6] += coefficients18[0][0] * basisvalues0[0];
    }
}

void vo2_2tdevice_finite_element_3::evaluate_reference_basis_derivatives(double * reference_values,
                                                         std::size_t order,
                                                         std::size_t num_points,
                                                         const double * X) const
{
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(2, order);
    std::fill_n(reference_values, num_points * 19 * num_derivatives * 7, 0.0);
    if (order > 1)
        return;
    // Tables of derivatives of the polynomial base (transpose).
    alignas(32) static const double dmats0[2][3][3] =
        { { { 0.0, 0.0, 0.0 },
            { 4.8989794855663495, 0.0, 0.0 },
            { 0.0, 0.0, 0.0 } },
          { { 0.0, 0.0, 0.0 },
            { 2.449489742783182, 0.0, 0.0 },
            { 4.242640687119285, 0.0, 0.0 } } };
    alignas(32) static const double dmats18[2][1][1] = {};
    static const double coefficients0[1][3] = { { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients1[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients2[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
    static const double coefficients18[1][1] = { { 1.0 } };
    const std::size_t reference_offset[19] = { 0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6 };
    const std::size_t num_components[19] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
    // Precomputed combinations
    const std::size_t combinations[1][2][1] =
        { { { 0 },
            { 1 } } };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[3] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
        basisvalues1[0] *= std::sqrt(0.5);
        basisvalues1[2] *= std::sqrt(1.0);
        basisvalues1[1] *= std::sqrt(3.0);
        double basisvalues0[1] = {};
        basisvalues0[0] = 1.0;
        // Loop over all dofs
        for (std::size_t i = 0; i < 19; ++i)
        {
            double derivatives[2] = {};
            switch (i)
            {
            case 0:
                // Compute reference derivatives for dof 0.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 1:
                // Compute reference derivatives for dof 1.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 2:
                // Compute reference derivatives for dof 2.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 3:
                // Compute reference derivatives for dof 3.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 4:
                // Compute reference derivatives for dof 4.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 5:
                // Compute reference derivatives for dof 5.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 6:
                // Compute reference derivatives for dof 6.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 7:
                // Compute reference derivatives for dof 7.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 8:
                // Compute reference derivatives for dof 8.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 9:
                // Compute reference derivatives for dof 9.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 10:
                // Compute reference derivatives for dof 10.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 11:
                // Compute reference derivatives for dof 11.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 12:
                // Compute reference derivatives for dof 12.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 13:
                // Compute reference derivatives for dof 13.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 14:
                // Compute reference derivatives for dof 14.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 15:
                // Compute reference derivatives for dof 15.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 16:
                // Compute reference derivatives for dof 16.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 17:
                // Compute reference derivatives for dof 17.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 18:
                // Compute reference derivatives for dof 18.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[1] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[1][1] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats18[comb][0][0], 1, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[1][1];
                        std::copy_n(&dmats[0][0], 1, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 1, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 1; ++t)
                            for (std::size_t u = 0; u < 1; ++u)
                                for (std::size_t tu = 0; tu < 1; ++tu)
                                    dmats[t][u] += dmats18[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 1; ++s)
                        for (std::size_t t = 0; t < 1; ++t)
                            aux[s] += dmats[s][t] * basisvalues0[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 1; ++s)
                        derivatives[r] += coefficients18[0][s] * aux[s];
                }
                break;
            }
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t c = 0; c < num_components[i]; ++c)
                    reference_values[19 * (num_derivatives * 7) * ip + num_derivatives * 7 * i + 7 * r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
        }
    }
}

void vo2_2tdevice_finite_element_3::transform_reference_basis_derivatives(double * values,
                                                          std::size_t order,
                                                          std::size_t num_points,
                                                          const double * reference_values,
                                                          const double * X,
                                                          const double * J,
                                                          const double * detJ,
                                                          const double * K,
                                                          int cell_orientation) const
{
    const std::size_t num_derivatives = std::pow(2, order);
    // Precomputed combinations
    const std::size_t combinations[1][2][1] =
        { { { 0 },
            { 1 } } };
    std::fill_n(values, num_points * 19 * num_derivatives * 7, 0.0);
    const std::size_t reference_offsets[19] = { 0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6 };
    const std::size_t physical_offsets[19] = { 0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6 };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[2][2];
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                transform[r][s] = 1.0;
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                for (std::size_t k = 0; k < order; ++k)
                    transform[r][s] *= K[2 * 2 * ip + 2 * combinations[order - 1][s][k] + combinations[order - 1][r][k]];
        for (std::size_t d = 0; d < 19; ++d)
        {
            for (std::size_t s = 0; s < num_derivatives; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[19 * (num_derivatives * 7) * ip + num_derivatives * 7 * d + 7 * s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < num_derivatives; ++r)
                        values[19 * (num_derivatives * 7) * ip + num_derivatives * 7 * d + 7 * r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
}

void vo2_2tdevice_finite_element_3::evaluate_basis(std::size_t i,
                                   double * values,
                                   const double * x,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    double X[2] = {};
    double J[4];
    double detJ;
    double K[4];
    if (cm)
    {
        cm->compute_reference_geometry(X, J, &detJ, K, 1, x, coordinate_dofs, cell_orientation);
    }
    else
    {
        compute_jacobian_triangle_2d(J, coordinate_dofs);
        compute_jacobian_inverse_triangle_2d(K, detJ, J);
        // Compute constants
        const double C0 = coordinate_dofs[2] + coordinate_dofs[4];
        const double C1 = coordinate_dofs[3] + coordinate_dofs[5];
        // Get coordinates and map to the reference (FIAT) element
        double Y[2] = { (J[1] * (C1 - 2.0 * x[1]) + J[3] * (2.0 * x[0] - C0)) / detJ, (J[0] * (2.0 * x[1] - C1) + J[2] * (C0 - 2.0 * x[0])) / detJ };
        // Map to FFC reference coordinate
        for (std::size_t k = 0; k < 2; ++k)
            X[k] = (Y[k] + 1.0) / 2.0;
    }
    // Evaluate basis on reference element
    double ref_values[133];
    evaluate_reference_basis(ref_values, 1, X);
    // Push forward
    double physical_values[133];
    transform_reference_basis_derivatives(physical_values, 0, 1, ref_values, X, J, &detJ, K, cell_orientation);
    for (std::size_t k = 0; k < 7; ++k)
        values[k] = physical_values[7 * i + k];
}

void vo2_2tdevice_finite_element_3::evaluate_basis_all(double * values,
                                       const double * x,
                                       const double * coordinate_dofs,
                                       int cell_orientation,
                                       const ufc::coordinate_mapping * cm
                                       ) const
{
    // Helper variable to hold values of a single dof.
    double dof_values[7] = {};
    // Loop dofs and call evaluate_basis
    for (std::size_t r = 0; r < 19; ++r)
    {
        evaluate_basis(r, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 7; ++s)
            values[r * 7 + s] = dof_values[s];
    }
}

void vo2_2tdevice_finite_element_3::evaluate_basis_derivatives(std::size_t i,
                                               std::size_t n,
                                               double * values,
                                               const double * x,
                                               const double * coordinate_dofs,
                                               int cell_orientation,
                                               const ufc::coordinate_mapping * cm
                                               ) const
{
    std::size_t num_derivatives = std::pow(2, n);
    std::fill_n(values, 7 * num_derivatives, 0.0);
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
        return;
    }
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
        return;
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, coordinate_dofs);
    // Compute Inverse Jacobian and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    // Compute constants
    const double C0 = coordinate_dofs[2] + coordinate_dofs[4];
    const double C1 = coordinate_dofs[3] + coordinate_dofs[5];
    // Get coordinates and map to the reference (FIAT) element
    double Y[2] = { (J[1] * (C1 - 2.0 * x[1]) + J[3] * (2.0 * x[0] - C0)) / detJ, (J[0] * (2.0 * x[1] - C1) + J[2] * (C0 - 2.0 * x[0])) / detJ };
    // Precomputed combinations
    const std::size_t combinations[1][2][1] =
        { { { 0 },
            { 1 } } };
    // Declare transformation matrix
    double transform[2][2] =
        { { 1.0, 1.0 },
          { 1.0, 1.0 } };
    // Construct transformation matrix
    for (std::size_t row = 0; row < num_derivatives; ++row)
        for (std::size_t col = 0; col < num_derivatives; ++col)
            for (std::size_t k = 0; k < n; ++k)
                transform[row][col] *= K[2 * combinations[n - 1][col][k] + combinations[n - 1][row][k]];
    switch (i)
    {
    case 0:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 1:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 2:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, 0.0, 0.3333333333333333 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 3:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 4:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 5:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, 0.0, 0.3333333333333333 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 6:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[2 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 7:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[2 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 8:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, 0.0, 0.3333333333333333 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[2 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 9:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[3 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 10:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[3 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 11:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, 0.0, 0.3333333333333333 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[3 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 12:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[4 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 13:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[4 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 14:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, 0.0, 0.3333333333333333 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[4 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 15:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[5 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 16:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[5 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 17:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, 0.0, 0.3333333333333333 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[5 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 18:
        {
            double basisvalues[1] = {};
            basisvalues[0] = 1.0;
            // Table(s) of coefficients
            static const double coefficients0[1] = { 1.0 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[1][1] = {};
            static const double dmats1[1][1] = {};
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[1][1] = { { 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[1][1] = { { 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 1, 0.0);
                for (std::size_t t = 0; t < 1; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 1, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 1, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 1; ++t)
                            for (std::size_t u = 0; u < 1; ++u)
                                for (std::size_t tu = 0; tu < 1; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 1; ++t)
                            for (std::size_t u = 0; u < 1; ++u)
                                for (std::size_t tu = 0; tu < 1; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 1; ++s)
                    for (std::size_t t = 0; t < 1; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[6 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    }
}

void vo2_2tdevice_finite_element_3::evaluate_basis_derivatives_all(std::size_t n,
                                                   double * values,
                                                   const double * x,
                                                   const double * coordinate_dofs,
                                                   int cell_orientation,
                                                   const ufc::coordinate_mapping * cm
                                                   ) const
{
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
        return;
    }
    unsigned int num_derivatives = std::pow(2, n);
    // Set values equal to zero.
    std::fill_n(values, 7 * num_derivatives * 19, 0.0);
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
        return;
    // Helper variable to hold values of a single dof.
    double dof_values[14] = {};
    // Loop dofs and call evaluate_basis_derivatives.
    for (std::size_t r = 0; r < 19; ++r)
    {
        evaluate_basis_derivatives(r, n, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 7 * num_derivatives; ++s)
            values[7 * num_derivatives * r + s] = dof_values[s];
    }
}

double vo2_2tdevice_finite_element_3::evaluate_dof(std::size_t i,
                                   const ufc::function& f,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::cell& c,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    // Declare variables for result of evaluation
    double vals[7];
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 1:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 2:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 3:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 4:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 5:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 6:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 7:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 8:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 9:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[3];
        }
        break;
    case 10:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[3];
        }
        break;
    case 11:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[3];
        }
        break;
    case 12:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[4];
        }
        break;
    case 13:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[4];
        }
        break;
    case 14:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[4];
        }
        break;
    case 15:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[5];
        }
        break;
    case 16:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[5];
        }
        break;
    case 17:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[5];
        }
        break;
    case 18:
        {
            y[0] = 0.3333333333333334 * coordinate_dofs[0] + 0.3333333333333333 * coordinate_dofs[2] + 0.3333333333333333 * coordinate_dofs[4];
            y[1] = 0.3333333333333334 * coordinate_dofs[1] + 0.3333333333333333 * coordinate_dofs[3] + 0.3333333333333333 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[6];
        }
        break;
    }
    return 0.0;
}

void vo2_2tdevice_finite_element_3::evaluate_dofs(double * values,
                                  const ufc::function& f,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::cell& c,
                                  const ufc::coordinate_mapping * cm
                                  ) const
{
    // Declare variables for result of evaluation
    double vals[7];
    // Declare variable for physical coordinates
    double y[2];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[3] = vals[1];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[4] = vals[1];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[5] = vals[1];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[6] = vals[2];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[7] = vals[2];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[8] = vals[2];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[9] = vals[3];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[10] = vals[3];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[11] = vals[3];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[12] = vals[4];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[13] = vals[4];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[14] = vals[4];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[15] = vals[5];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[16] = vals[5];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[17] = vals[5];
    y[0] = 0.3333333333333334 * coordinate_dofs[0] + 0.3333333333333333 * coordinate_dofs[2] + 0.3333333333333333 * coordinate_dofs[4];
    y[1] = 0.3333333333333334 * coordinate_dofs[1] + 0.3333333333333333 * coordinate_dofs[3] + 0.3333333333333333 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[18] = vals[6];
}

void vo2_2tdevice_finite_element_3::interpolate_vertex_values(double * vertex_values,
                                              const double * dof_values,
                                              const double * coordinate_dofs,
                                              int cell_orientation,
                                              const ufc::coordinate_mapping * cm
                                              ) const
{
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[7] = dof_values[1];
    vertex_values[14] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[3];
    vertex_values[8] = dof_values[4];
    vertex_values[15] = dof_values[5];
    // Evaluate function and change variables
    vertex_values[2] = dof_values[6];
    vertex_values[9] = dof_values[7];
    vertex_values[16] = dof_values[8];
    // Evaluate function and change variables
    vertex_values[3] = dof_values[9];
    vertex_values[10] = dof_values[10];
    vertex_values[17] = dof_values[11];
    // Evaluate function and change variables
    vertex_values[4] = dof_values[12];
    vertex_values[11] = dof_values[13];
    vertex_values[18] = dof_values[14];
    // Evaluate function and change variables
    vertex_values[5] = dof_values[15];
    vertex_values[12] = dof_values[16];
    vertex_values[19] = dof_values[17];
    // Evaluate function and change variables
    vertex_values[6] = dof_values[18];
    vertex_values[13] = dof_values[18];
    vertex_values[20] = dof_values[18];
}

void vo2_2tdevice_finite_element_3::tabulate_dof_coordinates(double * dof_coordinates,
                                             const double * coordinate_dofs,
                                             const ufc::coordinate_mapping * cm
                                             ) const
{
    dof_coordinates[0] = coordinate_dofs[0];
    dof_coordinates[1] = coordinate_dofs[1];
    dof_coordinates[2] = coordinate_dofs[2];
    dof_coordinates[2 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 2] = coordinate_dofs[4];
    dof_coordinates[2 * 2 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 3] = coordinate_dofs[0];
    dof_coordinates[2 * 3 + 1] = coordinate_dofs[1];
    dof_coordinates[2 * 4] = coordinate_dofs[2];
    dof_coordinates[2 * 4 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 5] = coordinate_dofs[4];
    dof_coordinates[2 * 5 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 6] = coordinate_dofs[0];
    dof_coordinates[2 * 6 + 1] = coordinate_dofs[1];
    dof_coordinates[2 * 7] = coordinate_dofs[2];
    dof_coordinates[2 * 7 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 8] = coordinate_dofs[4];
    dof_coordinates[2 * 8 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 9] = coordinate_dofs[0];
    dof_coordinates[2 * 9 + 1] = coordinate_dofs[1];
    dof_coordinates[2 * 10] = coordinate_dofs[2];
    dof_coordinates[2 * 10 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 11] = coordinate_dofs[4];
    dof_coordinates[2 * 11 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 12] = coordinate_dofs[0];
    dof_coordinates[2 * 12 + 1] = coordinate_dofs[1];
    dof_coordinates[2 * 13] = coordinate_dofs[2];
    dof_coordinates[2 * 13 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 14] = coordinate_dofs[4];
    dof_coordinates[2 * 14 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 15] = coordinate_dofs[0];
    dof_coordinates[2 * 15 + 1] = coordinate_dofs[1];
    dof_coordinates[2 * 16] = coordinate_dofs[2];
    dof_coordinates[2 * 16 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 17] = coordinate_dofs[4];
    dof_coordinates[2 * 17 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 18] = 0.3333333333333334 * coordinate_dofs[0] + 0.3333333333333333 * coordinate_dofs[2] + 0.3333333333333333 * coordinate_dofs[4];
    dof_coordinates[2 * 18 + 1] = 0.3333333333333334 * coordinate_dofs[1] + 0.3333333333333333 * coordinate_dofs[3] + 0.3333333333333333 * coordinate_dofs[5];
}

void vo2_2tdevice_finite_element_3::tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const
{
    static const double dof_X[38] = { 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.3333333333333333, 0.3333333333333333 };
    std::copy_n(dof_X, 38, reference_dof_coordinates);
}

std::size_t vo2_2tdevice_finite_element_3::num_sub_elements() const
{
    return 7;
}

ufc::finite_element * vo2_2tdevice_finite_element_3::create_sub_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new vo2_2tdevice_finite_element_0();
    case 1:
        return new vo2_2tdevice_finite_element_0();
    case 2:
        return new vo2_2tdevice_finite_element_0();
    case 3:
        return new vo2_2tdevice_finite_element_0();
    case 4:
        return new vo2_2tdevice_finite_element_0();
    case 5:
        return new vo2_2tdevice_finite_element_0();
    case 6:
        return new vo2_2tdevice_finite_element_2();
    default:
        return nullptr;
    }
}

ufc::finite_element * vo2_2tdevice_finite_element_3::create() const
{
    return new vo2_2tdevice_finite_element_3();
}


vo2_2tdevice_dofmap_0::vo2_2tdevice_dofmap_0() : ufc::dofmap()
{
    // Do nothing
}

vo2_2tdevice_dofmap_0::~vo2_2tdevice_dofmap_0()
{
    // Do nothing
}

const char * vo2_2tdevice_dofmap_0::signature() const
{
    return "FFC dofmap for FiniteElement('Lagrange', triangle, 1)";
}

bool vo2_2tdevice_dofmap_0::needs_mesh_entities(std::size_t d) const
{
    static const bool return_values[3] = { true, false, false };
    if (d >= 3)
        return false;
    return return_values[d];
}

std::size_t vo2_2tdevice_dofmap_0::topological_dimension() const
{
    return 2;
}

std::size_t vo2_2tdevice_dofmap_0::global_dimension(const std::vector<std::size_t>&
                                            num_global_entities) const
{
    return num_global_entities[0];
}

std::size_t vo2_2tdevice_dofmap_0::num_global_support_dofs() const
{
    return 0;
}

std::size_t vo2_2tdevice_dofmap_0::num_element_support_dofs() const
{
    return 3;
}

std::size_t vo2_2tdevice_dofmap_0::num_element_dofs() const
{
    return 3;
}

std::size_t vo2_2tdevice_dofmap_0::num_facet_dofs() const
{
    return 2;
}

std::size_t vo2_2tdevice_dofmap_0::num_entity_dofs(std::size_t d) const
{
    static const std::size_t return_values[3] = { 1, 0, 0 };
    if (d >= 3)
        return 0;
    return return_values[d];
}

std::size_t vo2_2tdevice_dofmap_0::num_entity_closure_dofs(std::size_t d) const
{
    static const std::size_t return_values[3] = { 1, 2, 3 };
    if (d >= 3)
        return 0;
    return return_values[d];
}

void vo2_2tdevice_dofmap_0::tabulate_dofs(std::size_t * dofs,
                                  const std::vector<std::size_t>& num_global_entities,
                                  const std::vector<std::vector<std::size_t>>& entity_indices) const
{
    dofs[0] = entity_indices[0][0];
    dofs[1] = entity_indices[0][1];
    dofs[2] = entity_indices[0][2];
}

void vo2_2tdevice_dofmap_0::tabulate_facet_dofs(std::size_t * dofs,
                                        std::size_t facet) const
{
    switch (facet)
    {
    case 0:
        dofs[0] = 1;
        dofs[1] = 2;
        break;
    case 1:
        dofs[0] = 0;
        dofs[1] = 2;
        break;
    case 2:
        dofs[0] = 0;
        dofs[1] = 1;
        break;
    }
}

void vo2_2tdevice_dofmap_0::tabulate_entity_dofs(std::size_t * dofs,
                                         std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        case 1:
            dofs[0] = 1;
            break;
        case 2:
            dofs[0] = 2;
            break;
        }
        break;
    }
}

void vo2_2tdevice_dofmap_0::tabulate_entity_closure_dofs(std::size_t * dofs,
                                             std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        case 1:
            dofs[0] = 1;
            break;
        case 2:
            dofs[0] = 2;
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 1;
            dofs[1] = 2;
            break;
        case 1:
            dofs[0] = 0;
            dofs[1] = 2;
            break;
        case 2:
            dofs[0] = 0;
            dofs[1] = 1;
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            break;
        }
        break;
    }
}

std::size_t vo2_2tdevice_dofmap_0::num_sub_dofmaps() const
{
    return 0;
}

ufc::dofmap * vo2_2tdevice_dofmap_0::create_sub_dofmap(std::size_t i) const
{
    return nullptr;
}

ufc::dofmap * vo2_2tdevice_dofmap_0::create() const
{
    return new vo2_2tdevice_dofmap_0();
}


vo2_2tdevice_dofmap_1::vo2_2tdevice_dofmap_1() : ufc::dofmap()
{
    // Do nothing
}

vo2_2tdevice_dofmap_1::~vo2_2tdevice_dofmap_1()
{
    // Do nothing
}

const char * vo2_2tdevice_dofmap_1::signature() const
{
    return "FFC dofmap for VectorElement(FiniteElement('Lagrange', triangle, 1), dim=2)";
}

bool vo2_2tdevice_dofmap_1::needs_mesh_entities(std::size_t d) const
{
    static const bool return_values[3] = { true, false, false };
    if (d >= 3)
        return false;
    return return_values[d];
}

std::size_t vo2_2tdevice_dofmap_1::topological_dimension() const
{
    return 2;
}

std::size_t vo2_2tdevice_dofmap_1::global_dimension(const std::vector<std::size_t>&
                                            num_global_entities) const
{
    return 2 * num_global_entities[0];
}

std::size_t vo2_2tdevice_dofmap_1::num_global_support_dofs() const
{
    return 0;
}

std::size_t vo2_2tdevice_dofmap_1::num_element_support_dofs() const
{
    return 6;
}

std::size_t vo2_2tdevice_dofmap_1::num_element_dofs() const
{
    return 6;
}

std::size_t vo2_2tdevice_dofmap_1::num_facet_dofs() const
{
    return 4;
}

std::size_t vo2_2tdevice_dofmap_1::num_entity_dofs(std::size_t d) const
{
    static const std::size_t return_values[3] = { 2, 0, 0 };
    if (d >= 3)
        return 0;
    return return_values[d];
}

std::size_t vo2_2tdevice_dofmap_1::num_entity_closure_dofs(std::size_t d) const
{
    static const std::size_t return_values[3] = { 2, 4, 6 };
    if (d >= 3)
        return 0;
    return return_values[d];
}

void vo2_2tdevice_dofmap_1::tabulate_dofs(std::size_t * dofs,
                                  const std::vector<std::size_t>& num_global_entities,
                                  const std::vector<std::vector<std::size_t>>& entity_indices) const
{
    std::size_t offset = 0;
    dofs[0] = offset + entity_indices[0][0];
    dofs[1] = offset + entity_indices[0][1];
    dofs[2] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[3] = offset + entity_indices[0][0];
    dofs[4] = offset + entity_indices[0][1];
    dofs[5] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
}

void vo2_2tdevice_dofmap_1::tabulate_facet_dofs(std::size_t * dofs,
                                        std::size_t facet) const
{
    switch (facet)
    {
    case 0:
        dofs[0] = 1;
        dofs[1] = 2;
        dofs[2] = 4;
        dofs[3] = 5;
        break;
    case 1:
        dofs[0] = 0;
        dofs[1] = 2;
        dofs[2] = 3;
        dofs[3] = 5;
        break;
    case 2:
        dofs[0] = 0;
        dofs[1] = 1;
        dofs[2] = 3;
        dofs[3] = 4;
        break;
    }
}

void vo2_2tdevice_dofmap_1::tabulate_entity_dofs(std::size_t * dofs,
                                         std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 3;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 4;
            break;
        case 2:
            dofs[0] = 2;
            dofs[1] = 5;
            break;
        }
        break;
    }
}

void vo2_2tdevice_dofmap_1::tabulate_entity_closure_dofs(std::size_t * dofs,
                                             std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 3;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 4;
            break;
        case 2:
            dofs[0] = 2;
            dofs[1] = 5;
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 1;
            dofs[1] = 2;
            dofs[2] = 4;
            dofs[3] = 5;
            break;
        case 1:
            dofs[0] = 0;
            dofs[1] = 2;
            dofs[2] = 3;
            dofs[3] = 5;
            break;
        case 2:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 3;
            dofs[3] = 4;
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            dofs[4] = 4;
            dofs[5] = 5;
            break;
        }
        break;
    }
}

std::size_t vo2_2tdevice_dofmap_1::num_sub_dofmaps() const
{
    return 2;
}

ufc::dofmap * vo2_2tdevice_dofmap_1::create_sub_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new vo2_2tdevice_dofmap_0();
    case 1:
        return new vo2_2tdevice_dofmap_0();
    default:
        return nullptr;
    }
}

ufc::dofmap * vo2_2tdevice_dofmap_1::create() const
{
    return new vo2_2tdevice_dofmap_1();
}


vo2_2tdevice_dofmap_2::vo2_2tdevice_dofmap_2() : ufc::dofmap()
{
    // Do nothing
}

vo2_2tdevice_dofmap_2::~vo2_2tdevice_dofmap_2()
{
    // Do nothing
}

const char * vo2_2tdevice_dofmap_2::signature() const
{
    return "FFC dofmap for FiniteElement('Real', triangle, 0)";
}

bool vo2_2tdevice_dofmap_2::needs_mesh_entities(std::size_t d) const
{
    static const bool return_values[3] = {};
    if (d >= 3)
        return false;
    return return_values[d];
}

std::size_t vo2_2tdevice_dofmap_2::topological_dimension() const
{
    return 2;
}

std::size_t vo2_2tdevice_dofmap_2::global_dimension(const std::vector<std::size_t>&
                                            num_global_entities) const
{
    return 1;
}

std::size_t vo2_2tdevice_dofmap_2::num_global_support_dofs() const
{
    return 1;
}

std::size_t vo2_2tdevice_dofmap_2::num_element_support_dofs() const
{
    return 0;
}

std::size_t vo2_2tdevice_dofmap_2::num_element_dofs() const
{
    return 1;
}

std::size_t vo2_2tdevice_dofmap_2::num_facet_dofs() const
{
    return 0;
}

std::size_t vo2_2tdevice_dofmap_2::num_entity_dofs(std::size_t d) const
{
    static const std::size_t return_values[3] = { 0, 0, 1 };
    if (d >= 3)
        return 0;
    return return_values[d];
}

std::size_t vo2_2tdevice_dofmap_2::num_entity_closure_dofs(std::size_t d) const
{
    static const std::size_t return_values[3] = { 0, 0, 1 };
    if (d >= 3)
        return 0;
    return return_values[d];
}

void vo2_2tdevice_dofmap_2::tabulate_dofs(std::size_t * dofs,
                                  const std::vector<std::size_t>& num_global_entities,
                                  const std::vector<std::vector<std::size_t>>& entity_indices) const
{
    dofs[0] = 0;
}

void vo2_2tdevice_dofmap_2::tabulate_facet_dofs(std::size_t * dofs,
                                        std::size_t facet) const
{
    // Do nothing
}

void vo2_2tdevice_dofmap_2::tabulate_entity_dofs(std::size_t * dofs,
                                         std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        }
        break;
    }
}

void vo2_2tdevice_dofmap_2::tabulate_entity_closure_dofs(std::size_t * dofs,
                                             std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            break;
        case 1:
            break;
        case 2:
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            break;
        case 1:
            break;
        case 2:
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        }
        break;
    }
}

std::size_t vo2_2tdevice_dofmap_2::num_sub_dofmaps() const
{
    return 0;
}

ufc::dofmap * vo2_2tdevice_dofmap_2::create_sub_dofmap(std::size_t i) const
{
    return nullptr;
}

ufc::dofmap * vo2_2tdevice_dofmap_2::create() const
{
    return new vo2_2tdevice_dofmap_2();
}


vo2_2tdevice_dofmap_3::vo2_2tdevice_dofmap_3() : ufc::dofmap()
{
    // Do nothing
}

vo2_2tdevice_dofmap_3::~vo2_2tdevice_dofmap_3()
{
    // Do nothing
}

const char * vo2_2tdevice_dofmap_3::signature() const
{
    return "FFC dofmap for MixedElement(FiniteElement('Lagrange', triangle, 1), FiniteElement('Lagrange', triangle, 1), FiniteElement('Lagrange', triangle, 1), FiniteElement('Lagrange', triangle, 1), FiniteElement('Lagrange', triangle, 1), FiniteElement('Lagrange', triangle, 1), FiniteElement('Real', triangle, 0))";
}

bool vo2_2tdevice_dofmap_3::needs_mesh_entities(std::size_t d) const
{
    static const bool return_values[3] = { true, false, true };
    if (d >= 3)
        return false;
    return return_values[d];
}

std::size_t vo2_2tdevice_dofmap_3::topological_dimension() const
{
    return 2;
}

std::size_t vo2_2tdevice_dofmap_3::global_dimension(const std::vector<std::size_t>&
                                            num_global_entities) const
{
    return 6 * num_global_entities[0] + 1;
}

std::size_t vo2_2tdevice_dofmap_3::num_global_support_dofs() const
{
    return 1;
}

std::size_t vo2_2tdevice_dofmap_3::num_element_support_dofs() const
{
    return 18;
}

std::size_t vo2_2tdevice_dofmap_3::num_element_dofs() const
{
    return 19;
}

std::size_t vo2_2tdevice_dofmap_3::num_facet_dofs() const
{
    return 12;
}

std::size_t vo2_2tdevice_dofmap_3::num_entity_dofs(std::size_t d) const
{
    static const std::size_t return_values[3] = { 6, 0, 1 };
    if (d >= 3)
        return 0;
    return return_values[d];
}

std::size_t vo2_2tdevice_dofmap_3::num_entity_closure_dofs(std::size_t d) const
{
    static const std::size_t return_values[3] = { 6, 12, 19 };
    if (d >= 3)
        return 0;
    return return_values[d];
}

void vo2_2tdevice_dofmap_3::tabulate_dofs(std::size_t * dofs,
                                  const std::vector<std::size_t>& num_global_entities,
                                  const std::vector<std::vector<std::size_t>>& entity_indices) const
{
    std::size_t offset = 0;
    dofs[0] = offset + entity_indices[0][0];
    dofs[1] = offset + entity_indices[0][1];
    dofs[2] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[3] = offset + entity_indices[0][0];
    dofs[4] = offset + entity_indices[0][1];
    dofs[5] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[6] = offset + entity_indices[0][0];
    dofs[7] = offset + entity_indices[0][1];
    dofs[8] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[9] = offset + entity_indices[0][0];
    dofs[10] = offset + entity_indices[0][1];
    dofs[11] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[12] = offset + entity_indices[0][0];
    dofs[13] = offset + entity_indices[0][1];
    dofs[14] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[15] = offset + entity_indices[0][0];
    dofs[16] = offset + entity_indices[0][1];
    dofs[17] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[18] = offset;
    offset += 1;
}

void vo2_2tdevice_dofmap_3::tabulate_facet_dofs(std::size_t * dofs,
                                        std::size_t facet) const
{
    switch (facet)
    {
    case 0:
        dofs[0] = 1;
        dofs[1] = 2;
        dofs[2] = 4;
        dofs[3] = 5;
        dofs[4] = 7;
        dofs[5] = 8;
        dofs[6] = 10;
        dofs[7] = 11;
        dofs[8] = 13;
        dofs[9] = 14;
        dofs[10] = 16;
        dofs[11] = 17;
        break;
    case 1:
        dofs[0] = 0;
        dofs[1] = 2;
        dofs[2] = 3;
        dofs[3] = 5;
        dofs[4] = 6;
        dofs[5] = 8;
        dofs[6] = 9;
        dofs[7] = 11;
        dofs[8] = 12;
        dofs[9] = 14;
        dofs[10] = 15;
        dofs[11] = 17;
        break;
    case 2:
        dofs[0] = 0;
        dofs[1] = 1;
        dofs[2] = 3;
        dofs[3] = 4;
        dofs[4] = 6;
        dofs[5] = 7;
        dofs[6] = 9;
        dofs[7] = 10;
        dofs[8] = 12;
        dofs[9] = 13;
        dofs[10] = 15;
        dofs[11] = 16;
        break;
    }
}

void vo2_2tdevice_dofmap_3::tabulate_entity_dofs(std::size_t * dofs,
                                         std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 3;
            dofs[2] = 6;
            dofs[3] = 9;
            dofs[4] = 12;
            dofs[5] = 15;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 4;
            dofs[2] = 7;
            dofs[3] = 10;
            dofs[4] = 13;
            dofs[5] = 16;
            break;
        case 2:
            dofs[0] = 2;
            dofs[1] = 5;
            dofs[2] = 8;
            dofs[3] = 11;
            dofs[4] = 14;
            dofs[5] = 17;
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 18;
            break;
        }
        break;
    }
}

void vo2_2tdevice_dofmap_3::tabulate_entity_closure_dofs(std::size_t * dofs,
                                             std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 3;
            dofs[2] = 6;
            dofs[3] = 9;
            dofs[4] = 12;
            dofs[5] = 15;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 4;
            dofs[2] = 7;
            dofs[3] = 10;
            dofs[4] = 13;
            dofs[5] = 16;
            break;
        case 2:
            dofs[0] = 2;
            dofs[1] = 5;
            dofs[2] = 8;
            dofs[3] = 11;
            dofs[4] = 14;
            dofs[5] = 17;
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 1;
            dofs[1] = 2;
            dofs[2] = 4;
            dofs[3] = 5;
            dofs[4] = 7;
            dofs[5] = 8;
            dofs[6] = 10;
            dofs[7] = 11;
            dofs[8] = 13;
            dofs[9] = 14;
            dofs[10] = 16;
            dofs[11] = 17;
            break;
        case 1:
            dofs[0] = 0;
            dofs[1] = 2;
            dofs[2] = 3;
            dofs[3] = 5;
            dofs[4] = 6;
            dofs[5] = 8;
            dofs[6] = 9;
            dofs[7] = 11;
            dofs[8] = 12;
            dofs[9] = 14;
            dofs[10] = 15;
            dofs[11] = 17;
            break;
        case 2:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 3;
            dofs[3] = 4;
            dofs[4] = 6;
            dofs[5] = 7;
            dofs[6] = 9;
            dofs[7] = 10;
            dofs[8] = 12;
            dofs[9] = 13;
            dofs[10] = 15;
            dofs[11] = 16;
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            dofs[4] = 4;
            dofs[5] = 5;
            dofs[6] = 6;
            dofs[7] = 7;
            dofs[8] = 8;
            dofs[9] = 9;
            dofs[10] = 10;
            dofs[11] = 11;
            dofs[12] = 12;
            dofs[13] = 13;
            dofs[14] = 14;
            dofs[15] = 15;
            dofs[16] = 16;
            dofs[17] = 17;
            dofs[18] = 18;
            break;
        }
        break;
    }
}

std::size_t vo2_2tdevice_dofmap_3::num_sub_dofmaps() const
{
    return 7;
}

ufc::dofmap * vo2_2tdevice_dofmap_3::create_sub_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new vo2_2tdevice_dofmap_0();
    case 1:
        return new vo2_2tdevice_dofmap_0();
    case 2:
        return new vo2_2tdevice_dofmap_0();
    case 3:
        return new vo2_2tdevice_dofmap_0();
    case 4:
        return new vo2_2tdevice_dofmap_0();
    case 5:
        return new vo2_2tdevice_dofmap_0();
    case 6:
        return new vo2_2tdevice_dofmap_2();
    default:
        return nullptr;
    }
}

ufc::dofmap * vo2_2tdevice_dofmap_3::create() const
{
    return new vo2_2tdevice_dofmap_3();
}


vo2_2tdevice_coordinate_mapping_1::vo2_2tdevice_coordinate_mapping_1() : ufc::coordinate_mapping()
{
    // Do nothing
}

vo2_2tdevice_coordinate_mapping_1::~vo2_2tdevice_coordinate_mapping_1()
{
    // Do nothing
}

const char * vo2_2tdevice_coordinate_mapping_1::signature() const
{
    return "FFC coordinate_mapping from VectorElement(FiniteElement('Lagrange', triangle, 1), dim=2)";
}

ufc::coordinate_mapping * vo2_2tdevice_coordinate_mapping_1::create() const
{
    return new vo2_2tdevice_coordinate_mapping_1();
}

std::size_t vo2_2tdevice_coordinate_mapping_1::geometric_dimension() const
{
    return 2;
}

std::size_t vo2_2tdevice_coordinate_mapping_1::topological_dimension() const
{
    return 2;
}

ufc::shape vo2_2tdevice_coordinate_mapping_1::cell_shape() const
{
    return ufc::shape::triangle;
}

ufc::finite_element * vo2_2tdevice_coordinate_mapping_1::create_coordinate_finite_element() const
{
    return new vo2_2tdevice_finite_element_1();
}

ufc::dofmap * vo2_2tdevice_coordinate_mapping_1::create_coordinate_dofmap() const
{
    return new vo2_2tdevice_dofmap_1();
}

void vo2_2tdevice_coordinate_mapping_1::compute_physical_coordinates(
    double * x, std::size_t num_points,
    const double * X,
    const double * coordinate_dofs) const
{
    vo2_2tdevice_finite_element_0 xelement;
    double phi[3];
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Compute basis values of coordinate element
        xelement.evaluate_reference_basis(phi, 1, &X[2 * ip]);
        // Compute x
        for (std::size_t i = 0; i < 2; ++i)
            for (std::size_t d = 0; d < 3; ++d)
                x[2 * ip + i] += coordinate_dofs[2 * d + i] * phi[d];
    }
}

void vo2_2tdevice_coordinate_mapping_1::compute_reference_coordinates(
    double * X, std::size_t num_points,
    const double * x,
    const double * coordinate_dofs, int cell_orientation) const
{
    const double phi_X0[3] = { 1.0, 0.0, 0.0 };
    const double dphi_X0[2][3] =
        { { -1.0, 1.0, 0.0 },
          { -1.0, 0.0, 1.0 } };
    double J[4];
    double detJ[1];
    double K[4];
    double x0[2] = {};
    for (std::size_t i = 0; i < 2; ++i)
        for (std::size_t k = 0; k < 3; ++k)
            x0[i] += coordinate_dofs[2 * k + i] * phi_X0[k];
    for (std::size_t i = 0; i < 2; ++i)
    {
        for (std::size_t j = 0; j < 2; ++j)
        {
            J[2 * i + j] = 0.0;
            for (std::size_t k = 0; k < 3; ++k)
                J[2 * i + j] += coordinate_dofs[2 * k + i] * dphi_X0[j][k];
        }
    }
    compute_jacobian_determinants(detJ, 1, J, cell_orientation);
    compute_jacobian_inverses(K, 1, J, detJ);
    for (std::size_t ip = 0; ip < num_points; ++ip)
        for (std::size_t j = 0; j < 2; ++j)
            for (std::size_t i = 0; i < 2; ++i)
                X[2 * ip + j] += K[2 * j + i] * (x[2 * ip + i] - x0[i]);
}

void vo2_2tdevice_coordinate_mapping_1::compute_reference_geometry(
    double * X, double * J, double * detJ, double * K, std::size_t num_points,
    const double * x,
    const double * coordinate_dofs, int cell_orientation) const
{
    const double phi_X0[3] = { 1.0, 0.0, 0.0 };
    const double dphi_X0[2][3] =
        { { -1.0, 1.0, 0.0 },
          { -1.0, 0.0, 1.0 } };
    double x0[2] = {};
    for (std::size_t i = 0; i < 2; ++i)
        for (std::size_t k = 0; k < 3; ++k)
            x0[i] += coordinate_dofs[2 * k + i] * phi_X0[k];
    for (std::size_t i = 0; i < 2; ++i)
    {
        for (std::size_t j = 0; j < 2; ++j)
        {
            J[2 * i + j] = 0.0;
            for (std::size_t k = 0; k < 3; ++k)
                J[2 * i + j] += coordinate_dofs[2 * k + i] * dphi_X0[j][k];
        }
    }
    compute_jacobian_determinants(detJ, 1, J, cell_orientation);
    compute_jacobian_inverses(K, 1, J, detJ);
    for (std::size_t ip = 0; ip < num_points; ++ip)
        for (std::size_t j = 0; j < 2; ++j)
            for (std::size_t i = 0; i < 2; ++i)
                X[2 * ip + j] += K[2 * j + i] * (x[2 * ip + i] - x0[i]);
}

void vo2_2tdevice_coordinate_mapping_1::compute_jacobians(
    double * J, std::size_t num_points,
    const double * X,
    const double * coordinate_dofs) const
{
    vo2_2tdevice_finite_element_0 xelement;
    double dphi[6];
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Compute basis derivatives of coordinate element
        xelement.evaluate_reference_basis_derivatives(dphi, 1, 1, &X[2 * ip]);
        // Compute J
        for (std::size_t i = 0; i < 2; ++i)
            for (std::size_t j = 0; j < 2; ++j)
                for (std::size_t d = 0; d < 3; ++d)
                    J[2 * 2 * ip + 2 * i + j] += coordinate_dofs[2 * d + i] * dphi[2 * d + j];
    }
}

void vo2_2tdevice_coordinate_mapping_1::compute_jacobian_determinants(
    double * detJ, std::size_t num_points,
    const double * J,
    int cell_orientation) const
{
    for (std::size_t ip = 0; ip < num_points; ++ip)
        detJ[ip] = J[2 * 2 * ip] * J[2 * 2 * ip + 2 + 1] - J[2 * 2 * ip + 1] * J[2 * 2 * ip + 2];
}

void vo2_2tdevice_coordinate_mapping_1::compute_jacobian_inverses(
    double * K, std::size_t num_points,
    const double * J, const double * detJ) const
{
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        K[2 * 2 * ip] = J[2 * 2 * ip + 2 + 1] / detJ[ip];
        K[2 * 2 * ip + 1] = -J[2 * 2 * ip + 1] / detJ[ip];
        K[2 * 2 * ip + 2] = -J[2 * 2 * ip + 2] / detJ[ip];
        K[2 * 2 * ip + 2 + 1] = J[2 * 2 * ip] / detJ[ip];
    }
}

void vo2_2tdevice_coordinate_mapping_1::compute_geometry(
    double * x, double * J, double * detJ, double * K, std::size_t num_points,
    const double * X,
    const double * coordinate_dofs, int cell_orientation) const
{
    compute_physical_coordinates(x, num_points, X, coordinate_dofs);
    compute_jacobians(J, num_points, X, coordinate_dofs);
    compute_jacobian_determinants(detJ, num_points, J, cell_orientation);
    compute_jacobian_inverses(K, num_points, J, detJ);
}

void vo2_2tdevice_coordinate_mapping_1::compute_midpoint_geometry(
    double * x, double * J,
    const double * coordinate_dofs) const
{
    const double phi_Xm[3] = { 0.33333333333333337, 0.33333333333333337, 0.3333333333333333 };
    const double dphi_Xm[2][3] =
        { { -1.0, 1.0, 0.0 },
          { -1.0, 0.0, 1.0 } };
    // Compute x
    for (std::size_t i = 0; i < 2; ++i)
        for (std::size_t d = 0; d < 3; ++d)
            x[i] += coordinate_dofs[2 * d + i] * phi_Xm[d];
    // Compute J
    for (std::size_t i = 0; i < 2; ++i)
        for (std::size_t j = 0; j < 2; ++j)
            for (std::size_t d = 0; d < 3; ++d)
                J[2 * i + j] += coordinate_dofs[2 * d + i] * dphi_Xm[j][d];
}


vo2_2tdevice_cell_integral_0_otherwise::vo2_2tdevice_cell_integral_0_otherwise() : ufc::cell_integral()
{

}

vo2_2tdevice_cell_integral_0_otherwise::~vo2_2tdevice_cell_integral_0_otherwise()
{

}

const std::vector<bool> & vo2_2tdevice_cell_integral_0_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, true, true, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false, false, false, true});
return enabled;
}

void vo2_2tdevice_cell_integral_0_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 19
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 19
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           19
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Quadrature rules
    alignas(32) static const double weights100[100] = { 0.001003387331496351, 0.002143055506450444, 0.002873911642439686, 0.003090113257366684, 0.002818768086972337, 0.002201923671765969, 0.001446831722862302, 0.0007592063141351052, 0.0002806636840481119, 4.99748596350856e-5, 0.002249206041480534, 0.004803900987217113, 0.006442197570121599, 0.006926837911101845, 0.006318587061783892, 0.004935860629243982, 0.003243236734127946, 0.001701846709521723, 0.0006291393502485065, 0.000112024292798025, 0.003297195863253446, 0.007042219418948902, 0.009443860094064295, 0.01015431262619157, 0.009262654793514121, 0.007235664029083863, 0.004754382900500859, 0.002494801199641485, 0.0009222790730563176, 0.0001642206307406176, 0.004052397889238688, 0.008655195594217754, 0.01160691699815769, 0.01248009422541406, 0.01138420776039229, 0.008892947478639324, 0.005843344475026482, 0.003066219762122812, 0.001133521308392819, 0.000201834335897191, 0.00444756688654952, 0.00949920574770708, 0.01273876383980475, 0.01369708881878754, 0.01249433714275104, 0.009760141972942057, 0.006413157371057729, 0.0033652217412104, 0.001244056475745846, 0.0002215161821322789, 0.00444756688654952, 0.00949920574770708, 0.01273876383980475, 0.01369708881878754, 0.01249433714275104, 0.009760141972942057, 0.006413157371057729, 0.0033652217412104, 0.001244056475745846, 0.0002215161821322789, 0.004052397889238688, 0.008655195594217754, 0.01160691699815769, 0.01248009422541406, 0.01138420776039229, 0.008892947478639324, 0.005843344475026482, 0.003066219762122812, 0.001133521308392819, 0.000201834335897191, 0.003297195863253446, 0.007042219418948902, 0.009443860094064295, 0.01015431262619157, 0.009262654793514121, 0.007235664029083863, 0.004754382900500859, 0.002494801199641485, 0.0009222790730563176, 0.0001642206307406176, 0.002249206041480531, 0.004803900987217105, 0.006442197570121589, 0.006926837911101834, 0.006318587061783881, 0.004935860629243974, 0.00324323673412794, 0.00170184670952172, 0.0006291393502485056, 0.0001120242927980248, 0.001003387331496351, 0.002143055506450444, 0.002873911642439686, 0.003090113257366684, 0.002818768086972337, 0.002201923671765969, 0.001446831722862302, 0.0007592063141351052, 0.0002806636840481119, 4.99748596350856e-5 };
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE3_C0_D01_Q100[1][1][2] = { { { -1.0, 1.0 } } };
    alignas(32) static const double FE3_C0_Q100[1][100][3] =
        { { { 0.9751911367792913, 0.01289124978829297, 0.01191761343241561 },
            { 0.9260265944099889, 0.01224133371286303, 0.06173207187714813 },
            { 0.8417611388235453, 0.0111274115333846, 0.1471114496430702 },
            { 0.7292008695293253, 0.009639454462218471, 0.2611596760084562 },
            { 0.59746217916815, 0.007897973946063137, 0.3946398468857868 },
            { 0.4572171873813903, 0.006044046902949144, 0.5367387657156606 },
            { 0.3198276713492887, 0.004227866974046322, 0.675944461676665 },
            { 0.1964245035388985, 0.002596575424202787, 0.8009789210368987 },
            { 0.09700666144126668, 0.001282350768586624, 0.9017109877901468 },
            { 0.02963725131430517, 0.000391780847181388, 0.9699709678385136 },
            { 0.9214181312289127, 0.06666425533867154, 0.01191761343241561 },
            { 0.8749645704405521, 0.06330335768229965, 0.06173207187714815 },
            { 0.7953455955695915, 0.05754295478733831, 0.1471114496430702 },
            { 0.6889920110546244, 0.04984831293691944, 0.2611596760084562 },
            { 0.5645175226132768, 0.04084263050093641, 0.3946398468857868 },
            { 0.4320057786354223, 0.03125545564891716, 0.5367387657156605 },
            { 0.3021920566497652, 0.02186348167356982, 0.6759444616766649 },
            { 0.1855934617864979, 0.0134276171766034, 0.8009789210368986 },
            { 0.0916576180103218, 0.006631394199531512, 0.9017109877901468 },
            { 0.02800302391075693, 0.002026008250729626, 0.9699709678385136 },
            { 0.8296975071346683, 0.1583848794329159, 0.01191761343241561 },
            { 0.7878680680588094, 0.1503998600640424, 0.06173207187714815 },
            { 0.7161745960810562, 0.1367139542758737, 0.1471114496430702 },
            { 0.6204077547782749, 0.1184325692132689, 0.2611596760084562 },
            { 0.508323816703486, 0.09703633641072713, 0.3946398468857868 },
            { 0.3890026747395679, 0.0742585595447716, 0.5367387657156606 },
            { 0.27211098586025, 0.05194455246308505, 0.675944461676665 },
            { 0.167118952151914, 0.03190212681118733, 0.8009789210368987 },
            { 0.08253375378194361, 0.0157552584279097, 0.9017109877901468 },
            { 0.02521552196937976, 0.004813510192106795, 0.9699709678385136 },
            { 0.7081563709631048, 0.2799260156044794, 0.01191761343241561 },
            { 0.6724544633152437, 0.2658134648076081, 0.06173207187714815 },
            { 0.6112632598935969, 0.2416252904633329, 0.1471114496430702 },
            { 0.5295251587032198, 0.209315165288324, 0.2611596760084562 },
            { 0.4338602276316446, 0.1714999254825686, 0.3946398468857868 },
            { 0.3320182597509012, 0.1312429745334383, 0.5367387657156606 },
            { 0.232249858037371, 0.09180568028596399, 0.675944461676665 },
            { 0.1426379489601713, 0.05638313000293001, 0.8009789210368987 },
            { 0.07044350869755851, 0.02784550351229483, 0.9017109877901466 },
            { 0.02152173819521691, 0.008507293966269647, 0.9699709678385136 },
            { 0.5675912493636129, 0.4204911372039713, 0.01191761343241561 },
            { 0.5389759728549031, 0.3992919552679489, 0.06173207187714813 },
            { 0.4899308847581597, 0.3629576655987701, 0.1471114496430702 },
            { 0.4244173444193796, 0.3144229795721643, 0.2611596760084562 },
            { 0.3477413728774554, 0.2576187802367578, 0.3946398468857868 },
            { 0.2661144721571176, 0.1971467621272219, 0.5367387657156606 },
            { 0.186149546192279, 0.137905992131056, 0.675944461676665 },
            { 0.114325105268572, 0.08469597369452932, 0.8009789210368987 },
            { 0.0564608619658763, 0.04182815024397701, 0.9017109877901468 },
            { 0.01724979223739298, 0.01277923992409358, 0.9699709678385136 },
            { 0.4204911372039713, 0.5675912493636129, 0.01191761343241561 },
            { 0.3992919552679489, 0.5389759728549031, 0.06173207187714813 },
            { 0.3629576655987701, 0.4899308847581597, 0.1471114496430702 },
            { 0.3144229795721643, 0.4244173444193796, 0.2611596760084562 },
            { 0.2576187802367578, 0.3477413728774554, 0.3946398468857868 },
            { 0.1971467621272219, 0.2661144721571175, 0.5367387657156605 },
            { 0.137905992131056, 0.186149546192279, 0.6759444616766649 },
            { 0.08469597369452932, 0.114325105268572, 0.8009789210368987 },
            { 0.04182815024397696, 0.05646086196587635, 0.9017109877901468 },
            { 0.01277923992409352, 0.01724979223739304, 0.9699709678385136 },
            { 0.2799260156044797, 0.7081563709631046, 0.01191761343241561 },
            { 0.2658134648076084, 0.6724544633152435, 0.06173207187714813 },
            { 0.2416252904633332, 0.6112632598935966, 0.1471114496430702 },
            { 0.2093151652883241, 0.5295251587032196, 0.2611596760084562 },
            { 0.1714999254825688, 0.4338602276316444, 0.3946398468857868 },
            { 0.1312429745334385, 0.332018259750901, 0.5367387657156606 },
            { 0.09180568028596404, 0.232249858037371, 0.675944461676665 },
            { 0.05638313000293006, 0.1426379489601712, 0.8009789210368987 },
            { 0.02784550351229483, 0.07044350869755851, 0.9017109877901466 },
            { 0.008507293966269591, 0.02152173819521697, 0.9699709678385136 },
            { 0.1583848794329159, 0.8296975071346683, 0.01191761343241561 },
            { 0.1503998600640424, 0.7878680680588094, 0.06173207187714815 },
            { 0.1367139542758737, 0.7161745960810562, 0.1471114496430702 },
            { 0.1184325692132689, 0.6204077547782749, 0.2611596760084562 },
            { 0.09703633641072713, 0.508323816703486, 0.3946398468857868 },
            { 0.07425855954477163, 0.3890026747395678, 0.5367387657156606 },
            { 0.05194455246308505, 0.27211098586025, 0.675944461676665 },
            { 0.03190212681118738, 0.1671189521519139, 0.8009789210368987 },
            { 0.01575525842790964, 0.08253375378194366, 0.9017109877901468 },
            { 0.004813510192106739, 0.02521552196937982, 0.9699709678385136 },
            { 0.06666425533867142, 0.9214181312289128, 0.01191761343241561 },
            { 0.06330335768229968, 0.8749645704405522, 0.06173207187714813 },
            { 0.05754295478733831, 0.7953455955695915, 0.1471114496430702 },
            { 0.04984831293691938, 0.6889920110546244, 0.2611596760084562 },
            { 0.04084263050093641, 0.5645175226132768, 0.3946398468857868 },
            { 0.03125545564891716, 0.4320057786354223, 0.5367387657156605 },
            { 0.02186348167356984, 0.3021920566497652, 0.675944461676665 },
            { 0.01342761717660341, 0.1855934617864979, 0.8009789210368987 },
            { 0.006631394199531475, 0.09165761801032186, 0.9017109877901466 },
            { 0.002026008250729571, 0.02800302391075699, 0.9699709678385136 },
            { 0.01289124978829297, 0.9751911367792913, 0.01191761343241561 },
            { 0.01224133371286297, 0.9260265944099889, 0.06173207187714813 },
            { 0.0111274115333846, 0.8417611388235453, 0.1471114496430702 },
            { 0.009639454462218471, 0.7292008695293253, 0.2611596760084562 },
            { 0.007897973946063137, 0.59746217916815, 0.3946398468857868 },
            { 0.006044046902949214, 0.4572171873813903, 0.5367387657156606 },
            { 0.004227866974046322, 0.3198276713492887, 0.675944461676665 },
            { 0.002596575424202731, 0.1964245035388986, 0.8009789210368987 },
            { 0.001282350768586587, 0.09700666144126675, 0.9017109877901466 },
            { 0.000391780847181351, 0.02963725131430524, 0.9699709678385133 } } };
    // Unstructured piecewise computations
    const double w0_d1_c5 = w[0][15] * FE3_C0_D01_Q100[0][0][0] + w[0][17] * FE3_C0_D01_Q100[0][0][1];
    const double J_c0 = coordinate_dofs[0] * FE3_C0_D01_Q100[0][0][0] + coordinate_dofs[2] * FE3_C0_D01_Q100[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE3_C0_D01_Q100[0][0][0] + coordinate_dofs[5] * FE3_C0_D01_Q100[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE3_C0_D01_Q100[0][0][0] + coordinate_dofs[4] * FE3_C0_D01_Q100[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE3_C0_D01_Q100[0][0][0] + coordinate_dofs[3] * FE3_C0_D01_Q100[0][0][1];
    double w0_d0_c5 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c5 += w[0][ic + 15] * FE3_C0_D01_Q100[0][0][ic];
    const double w0_d1_c2 = w[0][6] * FE3_C0_D01_Q100[0][0][0] + w[0][8] * FE3_C0_D01_Q100[0][0][1];
    double w0_d0_c2 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c2 += w[0][ic + 6] * FE3_C0_D01_Q100[0][0][ic];
    const double w0_d1_c1 = w[0][3] * FE3_C0_D01_Q100[0][0][0] + w[0][5] * FE3_C0_D01_Q100[0][0][1];
    double w0_d0_c1 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c1 += w[0][ic + 3] * FE3_C0_D01_Q100[0][0][ic];
    const double w0_d1_c4 = w[0][12] * FE3_C0_D01_Q100[0][0][0] + w[0][14] * FE3_C0_D01_Q100[0][0][1];
    double w0_d0_c4 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c4 += w[0][ic + 12] * FE3_C0_D01_Q100[0][0][ic];
    const double w0_d1_c3 = w[0][9] * FE3_C0_D01_Q100[0][0][0] + w[0][11] * FE3_C0_D01_Q100[0][0][1];
    double w0_d0_c3 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c3 += w[0][ic + 9] * FE3_C0_D01_Q100[0][0][ic];
    const double w0_d1_c0 = w[0][0] * FE3_C0_D01_Q100[0][0][0] + w[0][2] * FE3_C0_D01_Q100[0][0][1];
    double w0_d0_c0 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c0 += w[0][ic] * FE3_C0_D01_Q100[0][0][ic];
    alignas(32) double sp[92];
    sp[0] = J_c0 * J_c3;
    sp[1] = J_c1 * J_c2;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = J_c0 / sp[2];
    sp[4] = w0_d1_c5 * sp[3];
    sp[5] = -1 * J_c1 / sp[2];
    sp[6] = w0_d0_c5 * sp[5];
    sp[7] = sp[4] + sp[6];
    sp[8] = w0_d1_c2 * sp[3];
    sp[9] = w0_d0_c2 * sp[5];
    sp[10] = sp[8] + sp[9];
    sp[11] = w0_d1_c1 * sp[3];
    sp[12] = w0_d0_c1 * sp[5];
    sp[13] = sp[11] + sp[12];
    sp[14] = w0_d1_c4 * sp[3];
    sp[15] = w0_d0_c4 * sp[5];
    sp[16] = sp[14] + sp[15];
    sp[17] = sp[16] * w[6][0];
    sp[18] = w[26][0] / w[6][0];
    sp[19] = w0_d1_c3 * sp[3];
    sp[20] = w0_d0_c3 * sp[5];
    sp[21] = sp[19] + sp[20];
    sp[22] = w[28][0] / w[6][0];
    sp[23] = J_c3 / sp[2];
    sp[24] = w0_d0_c5 * sp[23];
    sp[25] = -1 * J_c2 / sp[2];
    sp[26] = w0_d1_c5 * sp[25];
    sp[27] = sp[24] + sp[26];
    sp[28] = w0_d0_c2 * sp[23];
    sp[29] = w0_d1_c2 * sp[25];
    sp[30] = sp[28] + sp[29];
    sp[31] = w0_d0_c1 * sp[23];
    sp[32] = w0_d1_c1 * sp[25];
    sp[33] = sp[31] + sp[32];
    sp[34] = w0_d0_c4 * sp[23];
    sp[35] = w0_d1_c4 * sp[25];
    sp[36] = sp[34] + sp[35];
    sp[37] = sp[36] * w[6][0];
    sp[38] = w[27][0] / w[6][0];
    sp[39] = w0_d0_c3 * sp[23];
    sp[40] = w0_d1_c3 * sp[25];
    sp[41] = sp[39] + sp[40];
    sp[42] = w[29][0] / w[6][0];
    sp[43] = w[34][0] / w[4][0];
    sp[44] = w[6][0] / w[31][0];
    sp[45] = w0_d1_c0 * sp[3];
    sp[46] = w0_d0_c0 * sp[5];
    sp[47] = sp[45] + sp[46];
    sp[48] = sp[47] * sp[3];
    sp[49] = sp[47] * sp[5];
    sp[50] = w0_d0_c0 * sp[23];
    sp[51] = w0_d1_c0 * sp[25];
    sp[52] = sp[50] + sp[51];
    sp[53] = sp[52] * sp[25];
    sp[54] = sp[52] * sp[23];
    sp[55] = sp[48] + sp[53];
    sp[56] = sp[54] + sp[49];
    sp[57] = w[20][0] * w[21][0];
    sp[58] = sp[55] * sp[57];
    sp[59] = sp[56] * sp[57];
    sp[60] = sp[13] * sp[3];
    sp[61] = sp[13] * sp[5];
    sp[62] = sp[33] * sp[25];
    sp[63] = sp[33] * sp[23];
    sp[64] = sp[60] + sp[62];
    sp[65] = sp[63] + sp[61];
    sp[66] = w[22][0] * w[23][0];
    sp[67] = sp[64] * sp[66];
    sp[68] = sp[65] * sp[66];
    sp[69] = sp[7] * sp[3];
    sp[70] = sp[7] * sp[5];
    sp[71] = sp[27] * sp[25];
    sp[72] = sp[27] * sp[23];
    sp[73] = sp[69] + sp[71];
    sp[74] = sp[72] + sp[70];
    sp[75] = sp[73] * w[33][0];
    sp[76] = sp[74] * w[33][0];
    sp[77] = sp[16] * sp[3];
    sp[78] = sp[16] * sp[5];
    sp[79] = sp[36] * sp[25];
    sp[80] = sp[36] * sp[23];
    sp[81] = sp[77] + sp[79];
    sp[82] = sp[80] + sp[78];
    sp[83] = std::abs(sp[2]);
    sp[84] = sp[58] * sp[83];
    sp[85] = sp[59] * sp[83];
    sp[86] = sp[67] * sp[83];
    sp[87] = sp[68] * sp[83];
    sp[88] = sp[75] * sp[83];
    sp[89] = sp[76] * sp[83];
    sp[90] = sp[81] * sp[83];
    sp[91] = sp[82] * sp[83];
    alignas(32) double BF0[3] = {};
    alignas(32) double BF1[3] = {};
    alignas(32) double BF2[2] = {};
    alignas(32) double BF3[3] = {};
    alignas(32) double BF4[2] = {};
    alignas(32) double BF5[2] = {};
    alignas(32) double BF6[3] = {};
    alignas(32) double BF7[2] = {};
    alignas(32) double BF8[3] = {};
    alignas(32) double BF9[3] = {};
    for (int iq = 0; iq < 100; ++iq)
    {
        // Quadrature loop body setup (num_points=100)
        // Unstructured varying computations for num_points=100
        double w0_c0 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c0 += w[0][ic] * FE3_C0_Q100[0][iq][ic];
        double w1_c0 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w1_c0 += w[1][ic] * FE3_C0_Q100[0][iq][ic];
        double w44 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w44 += w[44][ic] * FE3_C0_Q100[0][iq][ic];
        double w0_c1 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c1 += w[0][ic + 3] * FE3_C0_Q100[0][iq][ic];
        double w1_c1 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w1_c1 += w[1][ic + 3] * FE3_C0_Q100[0][iq][ic];
        double w0_c2 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c2 += w[0][ic + 6] * FE3_C0_Q100[0][iq][ic];
        double w0_c5 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c5 += w[0][ic + 15] * FE3_C0_Q100[0][iq][ic];
        double w0_c3 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c3 += w[0][ic + 9] * FE3_C0_Q100[0][iq][ic];
        double w1_c5 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w1_c5 += w[1][ic + 15] * FE3_C0_Q100[0][iq][ic];
        double w0_c4 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c4 += w[0][ic + 12] * FE3_C0_Q100[0][iq][ic];
        double w1_c2 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w1_c2 += w[1][ic + 6] * FE3_C0_Q100[0][iq][ic];
        double w1_c3 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w1_c3 += w[1][ic + 9] * FE3_C0_Q100[0][iq][ic];
        alignas(32) double sv100[192];
        sv100[0] = w0_c0 + -1 * w1_c0;
        sv100[1] = -1 * w[8][0] + -1 * w44;
        sv100[2] = sv100[1] * w[9][0];
        sv100[3] = sv100[2] / w[7][0];
        sv100[4] = w0_c0 * sv100[3];
        sv100[5] = std::pow(w0_c0, 3) * w[10][0];
        sv100[6] = sv100[4] + sv100[5];
        sv100[7] = std::pow(w0_c0, 5) * w[11][0];
        sv100[8] = sv100[6] + sv100[7];
        sv100[9] = w0_c1 * w[16][0];
        sv100[10] = sv100[8] + sv100[9];
        sv100[11] = w0_c0 * w[17][0];
        sv100[12] = sv100[11] * std::pow(w0_c1, 2);
        sv100[13] = sv100[10] + -1 * sv100[12];
        sv100[14] = 1.5 * w[18][0] * std::pow(w0_c0, 2);
        sv100[15] = w0_c1 * sv100[14];
        sv100[16] = sv100[13] + sv100[15];
        sv100[17] = sv100[0] * sv100[16];
        sv100[18] = sv100[17] / w[2][0];
        sv100[19] = w0_c1 + -1 * w1_c1;
        sv100[20] = -1 * w[12][0] + -1 * w44;
        sv100[21] = sv100[20] * w[13][0];
        sv100[22] = sv100[21] / w[7][0];
        sv100[23] = w0_c1 * sv100[22];
        sv100[24] = std::pow(w0_c1, 3) * w[14][0];
        sv100[25] = sv100[23] + sv100[24];
        sv100[26] = std::pow(w0_c1, 5) * w[15][0];
        sv100[27] = sv100[25] + sv100[26];
        sv100[28] = w0_c0 * w[16][0];
        sv100[29] = sv100[27] + sv100[28];
        sv100[30] = std::pow(w0_c0, 2) * w[17][0];
        sv100[31] = w0_c1 * sv100[30];
        sv100[32] = sv100[29] + -1 * sv100[31];
        sv100[33] = 0.5 * w[18][0] * std::pow(w0_c0, 3);
        sv100[34] = sv100[32] + sv100[33];
        sv100[35] = sv100[19] * sv100[34];
        sv100[36] = sv100[35] / w[2][0];
        sv100[37] = sv100[18] + sv100[36];
        sv100[38] = w0_c2 * w[5][0];
        sv100[39] = sp[7] * sv100[38];
        sv100[40] = w0_c5 * w[5][0];
        sv100[41] = sp[10] * sv100[40];
        sv100[42] = sv100[39] + sv100[41];
        sv100[43] = w0_c1 * w[19][0];
        sv100[44] = sp[13] * sv100[43];
        sv100[45] = sv100[42] + sv100[44];
        sv100[46] = sv100[45] + -1 * sp[17];
        sv100[47] = std::exp(-1 * w0_c2);
        sv100[48] = 1.32934038825 * std::pow(4 + std::pow(w0_c2, 2), -0.75) + sv100[47];
        sv100[49] = 1 / sv100[48] * w[24][0];
        sv100[50] = -1 * sv100[49] * sp[18];
        sv100[51] = sv100[46] * sv100[50];
        sv100[52] = w0_c3 * w[5][0];
        sv100[53] = sp[7] * sv100[52];
        sv100[54] = sp[21] * sv100[40];
        sv100[55] = sv100[53] + sv100[54];
        sv100[56] = sv100[55] + sv100[44];
        sv100[57] = sv100[56] + sp[17];
        sv100[58] = std::exp(-1 * w0_c3);
        sv100[59] = 1.32934038825 * std::pow(4 + std::pow(w0_c3, 2), -0.75) + sv100[58];
        sv100[60] = 1 / sv100[59] * w[25][0];
        sv100[61] = -1 * sv100[60] * sp[22];
        sv100[62] = sv100[57] * sv100[61];
        sv100[63] = -1 * sv100[51] + sv100[62];
        sv100[64] = sv100[49] * w[26][0];
        sv100[65] = sv100[60] * w[28][0];
        sv100[66] = sv100[64] + sv100[65];
        sv100[67] = std::pow(sv100[63], 2) / sv100[66];
        sv100[68] = sp[27] * sv100[38];
        sv100[69] = sp[30] * sv100[40];
        sv100[70] = sv100[68] + sv100[69];
        sv100[71] = sp[33] * sv100[43];
        sv100[72] = sv100[70] + sv100[71];
        sv100[73] = sv100[72] + -1 * sp[37];
        sv100[74] = -1 * sv100[49] * sp[38];
        sv100[75] = sv100[73] * sv100[74];
        sv100[76] = sp[27] * sv100[52];
        sv100[77] = sp[41] * sv100[40];
        sv100[78] = sv100[76] + sv100[77];
        sv100[79] = sv100[78] + sv100[71];
        sv100[80] = sv100[79] + sp[37];
        sv100[81] = -1 * sv100[60] * sp[42];
        sv100[82] = sv100[80] * sv100[81];
        sv100[83] = -1 * sv100[75] + sv100[82];
        sv100[84] = sv100[49] * w[27][0];
        sv100[85] = sv100[60] * w[29][0];
        sv100[86] = sv100[84] + sv100[85];
        sv100[87] = std::pow(sv100[83], 2) / sv100[86];
        sv100[88] = sv100[67] + sv100[87];
        sv100[89] = sv100[88] * w[6][0];
        sv100[90] = w0_c5 + -1 * w1_c5;
        sv100[91] = sv100[90] * w[32][0];
        sv100[92] = sv100[91] / w[2][0];
        sv100[93] = -1 * sv100[89] + sv100[92];
        sv100[94] = sv100[37] + sv100[93];
        sv100[95] = w0_c5 + -1 * w[36][0];
        sv100[96] = sv100[95] * sp[43];
        sv100[97] = sv100[94] + sv100[96];
        sv100[98] = w0_c5 + -1 * w[8][0];
        sv100[99] = sv100[98] + -1 * w44;
        sv100[100] = sv100[99] * w[9][0];
        sv100[101] = sv100[100] / w[7][0];
        sv100[102] = w0_c0 * sv100[101];
        sv100[103] = sv100[102] + sv100[5];
        sv100[104] = sv100[103] + sv100[7];
        sv100[105] = sv100[104] + sv100[9];
        sv100[106] = sv100[105] + -1 * sv100[12];
        sv100[107] = sv100[106] + sv100[15];
        sv100[108] = sv100[107] * (2.0 * w[20][0]);
        sv100[109] = sv100[0] / w[2][0];
        sv100[110] = sv100[108] + sv100[109];
        sv100[111] = w0_c5 + -1 * w[12][0];
        sv100[112] = sv100[111] + -1 * w44;
        sv100[113] = sv100[112] * w[13][0];
        sv100[114] = sv100[113] / w[7][0];
        sv100[115] = w0_c1 * sv100[114];
        sv100[116] = sv100[115] + sv100[24];
        sv100[117] = sv100[116] + sv100[26];
        sv100[118] = sv100[117] + sv100[28];
        sv100[119] = sv100[118] + -1 * sv100[31];
        sv100[120] = sv100[119] + sv100[33];
        sv100[121] = sv100[49] + sv100[60];
        sv100[122] = std::pow(w0_c1, 2) * w[19][0];
        sv100[123] = -1 * w[35][0] + sv100[122] / 2;
        sv100[124] = -1 * sv100[123] / sv100[40];
        sv100[125] = std::exp(-1 * sv100[124]);
        sv100[126] = 1.32934038825 * std::pow(4 + std::pow(sv100[124], 2), -0.75) + sv100[125];
        sv100[127] = 1 / sv100[126] * w[24][0];
        sv100[128] = sv100[121] + -1 * (2 * sv100[127]);
        sv100[129] = sv100[128] * sv100[43];
        sv100[130] = sv100[120] + sv100[129];
        sv100[131] = sv100[130] * (2.0 * w[22][0]);
        sv100[132] = sv100[19] / w[2][0];
        sv100[133] = sv100[131] + sv100[132];
        sv100[134] = sv100[49] * sv100[60];
        sv100[135] = w0_c4 * w[6][0];
        sv100[136] = -1 * sv100[135] + sv100[122] / 2;
        sv100[137] = sv100[136] + -1 * w[35][0];
        sv100[138] = -1 * sv100[137] / sv100[40];
        sv100[139] = std::exp(-1 * sv100[138]);
        sv100[140] = 1.32934038825 * std::pow(4 + std::pow(sv100[138], 2), -0.75) + sv100[139];
        sv100[141] = 1 / sv100[140] * w[24][0];
        sv100[142] = sv100[135] + sv100[122] / 2;
        sv100[143] = sv100[142] + w[35][0];
        sv100[144] = -1 * sv100[143] / sv100[40];
        sv100[145] = std::exp(-1 * sv100[144]);
        sv100[146] = 1.32934038825 * std::pow(4 + std::pow(sv100[144], 2), -0.75) + sv100[145];
        sv100[147] = 1 / sv100[146] * w[25][0];
        sv100[148] = sv100[141] * sv100[147];
        sv100[149] = -1 * sv100[134] + sv100[148];
        sv100[150] = std::pow(w0_c1, 2) * w[30][0];
        sv100[151] = sv100[149] * sv100[150];
        sv100[152] = w0_c2 + -1 * w1_c2;
        sv100[153] = w0_c2 * (1.994010582375 * std::pow(4 + std::pow(w0_c2, 2), -1.75));
        sv100[154] = sv100[153] + sv100[47];
        sv100[155] = sv100[154] * std::pow(1 / sv100[48], 2);
        sv100[156] = sv100[155] * w[24][0];
        sv100[157] = sv100[152] * sv100[156];
        sv100[158] = sv100[157] / w[2][0];
        sv100[159] = -1 * sv100[151] + sv100[158];
        sv100[160] = w0_c3 + -1 * w1_c3;
        sv100[161] = w0_c3 * (1.994010582375 * std::pow(4 + std::pow(w0_c3, 2), -1.75));
        sv100[162] = sv100[161] + sv100[58];
        sv100[163] = sv100[162] * std::pow(1 / sv100[59], 2);
        sv100[164] = sv100[163] * w[25][0];
        sv100[165] = sv100[160] * sv100[164];
        sv100[166] = sv100[165] / w[2][0];
        sv100[167] = -1 * sv100[151] + sv100[166];
        sv100[168] = -1 * sv100[49] + sv100[60];
        sv100[169] = sv100[168] * sp[44];
        sv100[170] = sv100[51] * sp[3];
        sv100[171] = sv100[51] * sp[5];
        sv100[172] = sv100[75] * sp[25];
        sv100[173] = sv100[75] * sp[23];
        sv100[174] = sv100[170] + sv100[172];
        sv100[175] = sv100[173] + sv100[171];
        sv100[176] = sv100[62] * sp[3];
        sv100[177] = sv100[62] * sp[5];
        sv100[178] = sv100[82] * sp[25];
        sv100[179] = sv100[82] * sp[23];
        sv100[180] = sv100[176] + sv100[178];
        sv100[181] = sv100[179] + sv100[177];
        sv100[182] = sv100[97] * sp[83];
        sv100[183] = sv100[110] * sp[83];
        sv100[184] = sv100[133] * sp[83];
        sv100[185] = sv100[159] * sp[83];
        sv100[186] = sv100[167] * sp[83];
        sv100[187] = -1 * sv100[169] * sp[83];
        sv100[188] = -1 * sv100[174] * sp[83];
        sv100[189] = -1 * sv100[175] * sp[83];
        sv100[190] = -1 * sv100[180] * sp[83];
        sv100[191] = -1 * sv100[181] * sp[83];
        const double fw0 = sv100[183] * weights100[iq];
        for (int i = 0; i < 3; ++i)
            BF0[i] += fw0 * FE3_C0_Q100[0][iq][i];
        const double fw1 = sv100[184] * weights100[iq];
        for (int i = 0; i < 3; ++i)
            BF1[i] += fw1 * FE3_C0_Q100[0][iq][i];
        const double fw2 = sv100[189] * weights100[iq];
        for (int i = 0; i < 2; ++i)
            BF2[i] += fw2 * FE3_C0_D01_Q100[0][0][i];
        const double fw3 = sv100[185] * weights100[iq];
        for (int i = 0; i < 3; ++i)
            BF3[i] += fw3 * FE3_C0_Q100[0][iq][i];
        const double fw4 = sv100[188] * weights100[iq];
        for (int i = 0; i < 2; ++i)
            BF4[i] += fw4 * FE3_C0_D01_Q100[0][0][i];
        const double fw5 = sv100[191] * weights100[iq];
        for (int i = 0; i < 2; ++i)
            BF5[i] += fw5 * FE3_C0_D01_Q100[0][0][i];
        const double fw6 = sv100[186] * weights100[iq];
        for (int i = 0; i < 3; ++i)
            BF6[i] += fw6 * FE3_C0_Q100[0][iq][i];
        const double fw7 = sv100[190] * weights100[iq];
        for (int i = 0; i < 2; ++i)
            BF7[i] += fw7 * FE3_C0_D01_Q100[0][0][i];
        const double fw8 = sv100[187] * weights100[iq];
        for (int i = 0; i < 3; ++i)
            BF8[i] += fw8 * FE3_C0_Q100[0][iq][i];
        const double fw9 = sv100[182] * weights100[iq];
        for (int i = 0; i < 3; ++i)
            BF9[i] += fw9 * FE3_C0_Q100[0][iq][i];
    }
    A[0] = -0.5 * sp[85] + -0.5 * sp[84];
    A[1] = 0.5 * sp[85];
    A[2] = 0.5 * sp[84];
    A[3] = -0.5 * sp[87] + -0.5 * sp[86];
    A[4] = 0.5 * sp[87];
    A[5] = 0.5 * sp[86];
    std::fill(A + 6, A + 12, 0.0);
    A[12] = -0.5 * sp[91] + -0.5 * sp[90];
    A[13] = 0.5 * sp[91];
    A[14] = 0.5 * sp[90];
    A[15] = -0.5 * sp[89] + -0.5 * sp[88];
    A[16] = 0.5 * sp[89];
    A[17] = 0.5 * sp[88];
    A[18] = 0.0;
    static const int DM0[2] = { 6, 8 };
    static const int DM1[2] = { 9, 11 };
    for (int i = 0; i < 3; ++i)
        A[i] += BF0[i];
    for (int i = 0; i < 3; ++i)
        A[i + 3] += BF1[i];
    for (int i = 0; i < 2; ++i)
        A[i + 6] += BF2[i];
    for (int i = 0; i < 3; ++i)
        A[i + 6] += BF3[i];
    for (int i = 0; i < 2; ++i)
        A[DM0[i]] += BF4[i];
    for (int i = 0; i < 2; ++i)
        A[i + 9] += BF5[i];
    for (int i = 0; i < 3; ++i)
        A[i + 9] += BF6[i];
    for (int i = 0; i < 2; ++i)
        A[DM1[i]] += BF7[i];
    for (int i = 0; i < 3; ++i)
        A[i + 12] += BF8[i];
    for (int i = 0; i < 3; ++i)
        A[i + 15] += BF9[i];
}


vo2_2tdevice_exterior_facet_integral_0_0::vo2_2tdevice_exterior_facet_integral_0_0() : ufc::exterior_facet_integral()
{

}

vo2_2tdevice_exterior_facet_integral_0_0::~vo2_2tdevice_exterior_facet_integral_0_0()
{

}

const std::vector<bool> & vo2_2tdevice_exterior_facet_integral_0_0::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, true, true, true, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, true, true, true, false, true, false, false, false, false, false, false, true, false, true, true, true, true, true, true, true, false});
return enabled;
}

void vo2_2tdevice_exterior_facet_integral_0_0::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    std::size_t facet,
                                    int cell_orientation) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 6
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 6
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           6
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Quadrature rules
    alignas(32) static const double weights4[4] = { 0.1739274225687268, 0.3260725774312731, 0.3260725774312731, 0.1739274225687268 };
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE29_C0_D01_F_Q4[1][1][2] = { { { -1.0, 1.0 } } };
    alignas(32) static const double FE29_C0_F_Q4[3][4][3] =
        { { { 0.0, 0.9305681557970263, 0.06943184420297369 },
            { 0.0, 0.6699905217924281, 0.3300094782075718 },
            { 0.0, 0.3300094782075719, 0.6699905217924279 },
            { 0.0, 0.06943184420297382, 0.9305681557970262 } },
          { { 0.9305681557970263, 0.0, 0.06943184420297369 },
            { 0.6699905217924281, 0.0, 0.3300094782075718 },
            { 0.3300094782075719, 0.0, 0.669990521792428 },
            { 0.06943184420297382, 0.0, 0.9305681557970262 } },
          { { 0.9305681557970263, 0.06943184420297367, 0.0 },
            { 0.6699905217924281, 0.3300094782075718, 0.0 },
            { 0.3300094782075719, 0.6699905217924281, 0.0 },
            { 0.06943184420297374, 0.9305681557970263, 0.0 } } };
    // Unstructured piecewise computations
    const double w0_d1_c5 = w[0][15] * FE29_C0_D01_F_Q4[0][0][0] + w[0][17] * FE29_C0_D01_F_Q4[0][0][1];
    const double J_c0 = coordinate_dofs[0] * FE29_C0_D01_F_Q4[0][0][0] + coordinate_dofs[2] * FE29_C0_D01_F_Q4[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE29_C0_D01_F_Q4[0][0][0] + coordinate_dofs[5] * FE29_C0_D01_F_Q4[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE29_C0_D01_F_Q4[0][0][0] + coordinate_dofs[4] * FE29_C0_D01_F_Q4[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE29_C0_D01_F_Q4[0][0][0] + coordinate_dofs[3] * FE29_C0_D01_F_Q4[0][0][1];
    double w0_d0_c5 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c5 += w[0][ic + 15] * FE29_C0_D01_F_Q4[0][0][ic];
    const double w0_d1_c2 = w[0][6] * FE29_C0_D01_F_Q4[0][0][0] + w[0][8] * FE29_C0_D01_F_Q4[0][0][1];
    double w0_d0_c2 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c2 += w[0][ic + 6] * FE29_C0_D01_F_Q4[0][0][ic];
    const double w0_d1_c1 = w[0][3] * FE29_C0_D01_F_Q4[0][0][0] + w[0][5] * FE29_C0_D01_F_Q4[0][0][1];
    double w0_d0_c1 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c1 += w[0][ic + 3] * FE29_C0_D01_F_Q4[0][0][ic];
    const double w0_d1_c4 = w[0][12] * FE29_C0_D01_F_Q4[0][0][0] + w[0][14] * FE29_C0_D01_F_Q4[0][0][1];
    double w0_d0_c4 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c4 += w[0][ic + 12] * FE29_C0_D01_F_Q4[0][0][ic];
    const double w0_d1_c3 = w[0][9] * FE29_C0_D01_F_Q4[0][0][0] + w[0][11] * FE29_C0_D01_F_Q4[0][0][1];
    double w0_d0_c3 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c3 += w[0][ic + 9] * FE29_C0_D01_F_Q4[0][0][ic];
    alignas(32) double sp[40];
    sp[0] = J_c0 * J_c3;
    sp[1] = J_c1 * J_c2;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = J_c0 / sp[2];
    sp[4] = w0_d1_c5 * sp[3];
    sp[5] = -1 * J_c1 / sp[2];
    sp[6] = w0_d0_c5 * sp[5];
    sp[7] = sp[4] + sp[6];
    sp[8] = w0_d1_c2 * sp[3];
    sp[9] = w0_d0_c2 * sp[5];
    sp[10] = sp[8] + sp[9];
    sp[11] = w0_d1_c1 * sp[3];
    sp[12] = w0_d0_c1 * sp[5];
    sp[13] = sp[11] + sp[12];
    sp[14] = w0_d1_c4 * sp[3];
    sp[15] = w0_d0_c4 * sp[5];
    sp[16] = sp[14] + sp[15];
    sp[17] = sp[16] * w[6][0];
    sp[18] = w[26][0] / w[6][0];
    sp[19] = w0_d1_c3 * sp[3];
    sp[20] = w0_d0_c3 * sp[5];
    sp[21] = sp[19] + sp[20];
    sp[22] = w[28][0] / w[6][0];
    sp[23] = w[20][0] * w[21][0];
    sp[24] = sp[23] / w[42][0];
    sp[25] = w[22][0] * w[23][0];
    sp[26] = sp[25] / w[42][0];
    sp[27] = w[4][0] * w[38][0];
    sp[28] = w[0][18] * sp[27];
    sp[29] = w[38][0] * w[39][0];
    sp[30] = J_c0 * triangle_reference_facet_jacobian[facet][0][0];
    sp[31] = J_c1 * triangle_reference_facet_jacobian[facet][1][0];
    sp[32] = sp[30] + sp[31];
    sp[33] = sp[32] * sp[32];
    sp[34] = triangle_reference_facet_jacobian[facet][0][0] * J_c2;
    sp[35] = triangle_reference_facet_jacobian[facet][1][0] * J_c3;
    sp[36] = sp[34] + sp[35];
    sp[37] = sp[36] * sp[36];
    sp[38] = sp[33] + sp[37];
    sp[39] = std::sqrt(sp[38]);
    alignas(32) double BF0[3] = {};
    alignas(32) double BF1[3] = {};
    alignas(32) double BF2[3] = {};
    alignas(32) double BF3[3] = {};
    alignas(32) double BF4[3] = {};
    alignas(32) double BF5[1] = {};
    for (int iq = 0; iq < 4; ++iq)
    {
        // Quadrature loop body setup (num_points=4)
        // Unstructured varying computations for num_points=4
        double w0_c2 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c2 += w[0][ic + 6] * FE29_C0_F_Q4[facet][iq][ic];
        double w0_c5 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c5 += w[0][ic + 15] * FE29_C0_F_Q4[facet][iq][ic];
        double w0_c1 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c1 += w[0][ic + 3] * FE29_C0_F_Q4[facet][iq][ic];
        double w0_c3 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c3 += w[0][ic + 9] * FE29_C0_F_Q4[facet][iq][ic];
        double w0_c0 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c0 += w[0][ic] * FE29_C0_F_Q4[facet][iq][ic];
        double w0_c4 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c4 += w[0][ic + 12] * FE29_C0_F_Q4[facet][iq][ic];
        double w1_c4 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w1_c4 += w[1][ic + 12] * FE29_C0_F_Q4[facet][iq][ic];
        alignas(32) double sv4[55];
        sv4[0] = w0_c2 * w[5][0];
        sv4[1] = sp[7] * sv4[0];
        sv4[2] = w0_c5 * w[5][0];
        sv4[3] = sp[10] * sv4[2];
        sv4[4] = sv4[1] + sv4[3];
        sv4[5] = w0_c1 * w[19][0];
        sv4[6] = sp[13] * sv4[5];
        sv4[7] = sv4[4] + sv4[6];
        sv4[8] = sv4[7] + -1 * sp[17];
        sv4[9] = std::exp(-1 * w0_c2);
        sv4[10] = 1.32934038825 * std::pow(4 + std::pow(w0_c2, 2), -0.75) + sv4[9];
        sv4[11] = 1 / sv4[10] * w[24][0];
        sv4[12] = -1 * sv4[11] * sp[18];
        sv4[13] = sv4[8] * sv4[12];
        sv4[14] = w0_c3 * w[5][0];
        sv4[15] = sp[7] * sv4[14];
        sv4[16] = sp[21] * sv4[2];
        sv4[17] = sv4[15] + sv4[16];
        sv4[18] = sv4[17] + sv4[6];
        sv4[19] = sv4[18] + sp[17];
        sv4[20] = std::exp(-1 * w0_c3);
        sv4[21] = 1.32934038825 * std::pow(4 + std::pow(w0_c3, 2), -0.75) + sv4[20];
        sv4[22] = 1 / sv4[21] * w[25][0];
        sv4[23] = -1 * sv4[22] * sp[22];
        sv4[24] = sv4[19] * sv4[23];
        sv4[25] = -1 * sv4[13] + sv4[24];
        sv4[26] = sv4[25] * w[6][0];
        sv4[27] = sv4[26] * w[3][0];
        sv4[28] = w[0][18] + -1 * sv4[27];
        sv4[29] = -1 * w0_c0 + w[40][0];
        sv4[30] = sv4[29] * sp[24];
        sv4[31] = -1 * w0_c1 + w[41][0];
        sv4[32] = sv4[31] * sp[26];
        sv4[33] = w0_c5 * sv4[14];
        sv4[34] = std::pow(w0_c1, 2) * w[19][0];
        sv4[35] = sv4[33] + sv4[34] / 2;
        sv4[36] = sv4[35] + w[35][0];
        sv4[37] = sv4[36] * (-1.0 / w[43][0]);
        sv4[38] = w0_c5 * sv4[0];
        sv4[39] = sv4[38] + sv4[34] / 2;
        sv4[40] = sv4[39] + -1 * w[35][0];
        sv4[41] = sv4[40] * (-1.0 / w[43][0]);
        sv4[42] = w0_c4 + sp[28];
        sv4[43] = sv4[42] + -1 * w[37][0];
        sv4[44] = w0_c4 + -1 * w1_c4;
        sv4[45] = sv4[44] * sp[29];
        sv4[46] = sv4[45] / w[2][0];
        sv4[47] = sv4[43] + sv4[46];
        sv4[48] = sv4[47] * (-1.0 / w[43][0]);
        sv4[49] = sv4[28] * sp[39];
        sv4[50] = -1 * sv4[30] * sp[39];
        sv4[51] = -1 * sv4[32] * sp[39];
        sv4[52] = sv4[37] * sp[39];
        sv4[53] = sv4[41] * sp[39];
        sv4[54] = sv4[48] * sp[39];
        const double fw0 = sv4[50] * weights4[iq];
        for (int i = 0; i < 3; ++i)
            BF0[i] += fw0 * FE29_C0_F_Q4[facet][iq][i];
        const double fw1 = sv4[51] * weights4[iq];
        for (int i = 0; i < 3; ++i)
            BF1[i] += fw1 * FE29_C0_F_Q4[facet][iq][i];
        const double fw2 = sv4[53] * weights4[iq];
        for (int i = 0; i < 3; ++i)
            BF2[i] += fw2 * FE29_C0_F_Q4[facet][iq][i];
        const double fw3 = sv4[52] * weights4[iq];
        for (int i = 0; i < 3; ++i)
            BF3[i] += fw3 * FE29_C0_F_Q4[facet][iq][i];
        const double fw4 = sv4[54] * weights4[iq];
        for (int i = 0; i < 3; ++i)
            BF4[i] += fw4 * FE29_C0_F_Q4[facet][iq][i];
        const double fw5 = sv4[49] * weights4[iq];
        for (int i = 0; i < 1; ++i)
            BF5[i] += fw5;
    }
    std::fill(A, A + 19, 0.0);
    for (int i = 0; i < 3; ++i)
        A[i] += BF0[i];
    for (int i = 0; i < 3; ++i)
        A[i + 3] += BF1[i];
    for (int i = 0; i < 3; ++i)
        A[i + 6] += BF2[i];
    for (int i = 0; i < 3; ++i)
        A[i + 9] += BF3[i];
    for (int i = 0; i < 3; ++i)
        A[i + 12] += BF4[i];
    for (int i = 0; i < 1; ++i)
        A[i + 18] += BF5[i];
}


vo2_2tdevice_exterior_facet_integral_0_1::vo2_2tdevice_exterior_facet_integral_0_1() : ufc::exterior_facet_integral()
{

}

vo2_2tdevice_exterior_facet_integral_0_1::~vo2_2tdevice_exterior_facet_integral_0_1()
{

}

const std::vector<bool> & vo2_2tdevice_exterior_facet_integral_0_1::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, false, false, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, false, false, false, false, false, false, false, false, false, false, false, true, false, false, false, false, true, true, true, true, false});
return enabled;
}

void vo2_2tdevice_exterior_facet_integral_0_1::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    std::size_t facet,
                                    int cell_orientation) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 3
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 3
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           3
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Quadrature rules
    alignas(32) static const double weights2[2] = { 0.5, 0.5 };
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE14_C0_F_Q2[3][2][3] =
        { { { 0.0, 0.7886751345948129, 0.2113248654051871 },
            { 0.0, 0.2113248654051872, 0.7886751345948129 } },
          { { 0.7886751345948129, 0.0, 0.2113248654051871 },
            { 0.2113248654051872, 0.0, 0.7886751345948129 } },
          { { 0.7886751345948129, 0.2113248654051871, 0.0 },
            { 0.2113248654051871, 0.7886751345948129, 0.0 } } };
    alignas(32) static const double FE3_C0_D01_F_Q2[1][1][2] = { { { -1.0, 1.0 } } };
    // Unstructured piecewise computations
    const double J_c0 = coordinate_dofs[0] * FE3_C0_D01_F_Q2[0][0][0] + coordinate_dofs[2] * FE3_C0_D01_F_Q2[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE3_C0_D01_F_Q2[0][0][0] + coordinate_dofs[4] * FE3_C0_D01_F_Q2[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE3_C0_D01_F_Q2[0][0][0] + coordinate_dofs[3] * FE3_C0_D01_F_Q2[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE3_C0_D01_F_Q2[0][0][0] + coordinate_dofs[5] * FE3_C0_D01_F_Q2[0][0][1];
    alignas(32) double sp[14];
    sp[0] = w[20][0] * w[21][0];
    sp[1] = sp[0] / w[42][0];
    sp[2] = w[22][0] * w[23][0];
    sp[3] = sp[2] / w[42][0];
    sp[4] = J_c0 * triangle_reference_facet_jacobian[facet][0][0];
    sp[5] = J_c1 * triangle_reference_facet_jacobian[facet][1][0];
    sp[6] = sp[4] + sp[5];
    sp[7] = sp[6] * sp[6];
    sp[8] = triangle_reference_facet_jacobian[facet][0][0] * J_c2;
    sp[9] = triangle_reference_facet_jacobian[facet][1][0] * J_c3;
    sp[10] = sp[8] + sp[9];
    sp[11] = sp[10] * sp[10];
    sp[12] = sp[7] + sp[11];
    sp[13] = std::sqrt(sp[12]);
    alignas(32) double BF0[3] = {};
    alignas(32) double BF1[3] = {};
    alignas(32) double BF2[3] = {};
    alignas(32) double BF3[3] = {};
    for (int iq = 0; iq < 2; ++iq)
    {
        // Quadrature loop body setup (num_points=2)
        // Unstructured varying computations for num_points=2
        double w0_c0 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c0 += w[0][ic] * FE14_C0_F_Q2[facet][iq][ic];
        double w0_c1 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c1 += w[0][ic + 3] * FE14_C0_F_Q2[facet][iq][ic];
        double w0_c5 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c5 += w[0][ic + 15] * FE14_C0_F_Q2[facet][iq][ic];
        double w0_c3 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c3 += w[0][ic + 9] * FE14_C0_F_Q2[facet][iq][ic];
        double w0_c2 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c2 += w[0][ic + 6] * FE14_C0_F_Q2[facet][iq][ic];
        alignas(32) double sv2[19];
        sv2[0] = -1 * w0_c0 + w[40][0];
        sv2[1] = sv2[0] * sp[1];
        sv2[2] = -1 * w0_c1 + w[41][0];
        sv2[3] = sv2[2] * sp[3];
        sv2[4] = w0_c3 * w[5][0];
        sv2[5] = w0_c5 * sv2[4];
        sv2[6] = std::pow(w0_c1, 2) * w[19][0];
        sv2[7] = sv2[5] + sv2[6] / 2;
        sv2[8] = sv2[7] + w[35][0];
        sv2[9] = sv2[8] * (1.0 / w[43][0]);
        sv2[10] = w0_c2 * w[5][0];
        sv2[11] = w0_c5 * sv2[10];
        sv2[12] = sv2[11] + sv2[6] / 2;
        sv2[13] = sv2[12] + -1 * w[35][0];
        sv2[14] = sv2[13] * (1.0 / w[43][0]);
        sv2[15] = -1 * sv2[1] * sp[13];
        sv2[16] = -1 * sv2[3] * sp[13];
        sv2[17] = -1 * sv2[9] * sp[13];
        sv2[18] = -1 * sv2[14] * sp[13];
        const double fw0 = sv2[15] * weights2[iq];
        for (int i = 0; i < 3; ++i)
            BF0[i] += fw0 * FE14_C0_F_Q2[facet][iq][i];
        const double fw1 = sv2[16] * weights2[iq];
        for (int i = 0; i < 3; ++i)
            BF1[i] += fw1 * FE14_C0_F_Q2[facet][iq][i];
        const double fw2 = sv2[18] * weights2[iq];
        for (int i = 0; i < 3; ++i)
            BF2[i] += fw2 * FE14_C0_F_Q2[facet][iq][i];
        const double fw3 = sv2[17] * weights2[iq];
        for (int i = 0; i < 3; ++i)
            BF3[i] += fw3 * FE14_C0_F_Q2[facet][iq][i];
    }
    std::fill(A, A + 19, 0.0);
    for (int i = 0; i < 3; ++i)
        A[i] += BF0[i];
    for (int i = 0; i < 3; ++i)
        A[i + 3] += BF1[i];
    for (int i = 0; i < 3; ++i)
        A[i + 6] += BF2[i];
    for (int i = 0; i < 3; ++i)
        A[i + 9] += BF3[i];
}


vo2_2tdevice_exterior_facet_integral_0_otherwise::vo2_2tdevice_exterior_facet_integral_0_otherwise() : ufc::exterior_facet_integral()
{

}

vo2_2tdevice_exterior_facet_integral_0_otherwise::~vo2_2tdevice_exterior_facet_integral_0_otherwise()
{

}

const std::vector<bool> & vo2_2tdevice_exterior_facet_integral_0_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, false, false});
return enabled;
}

void vo2_2tdevice_exterior_facet_integral_0_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    std::size_t facet,
                                    int cell_orientation) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 2
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 2
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           2
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Quadrature rules
    alignas(32) static const double weights2[2] = { 0.5, 0.5 };
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE3_C0_D01_F_Q2[1][1][2] = { { { -1.0, 1.0 } } };
    alignas(32) static const double FE3_C0_F_Q2[3][2][3] =
        { { { 0.0, 0.7886751345948129, 0.2113248654051871 },
            { 0.0, 0.2113248654051872, 0.7886751345948129 } },
          { { 0.7886751345948129, 0.0, 0.2113248654051871 },
            { 0.2113248654051872, 0.0, 0.7886751345948129 } },
          { { 0.7886751345948129, 0.2113248654051871, 0.0 },
            { 0.2113248654051871, 0.7886751345948129, 0.0 } } };
    // Unstructured piecewise computations
    const double J_c0 = coordinate_dofs[0] * FE3_C0_D01_F_Q2[0][0][0] + coordinate_dofs[2] * FE3_C0_D01_F_Q2[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE3_C0_D01_F_Q2[0][0][0] + coordinate_dofs[4] * FE3_C0_D01_F_Q2[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE3_C0_D01_F_Q2[0][0][0] + coordinate_dofs[3] * FE3_C0_D01_F_Q2[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE3_C0_D01_F_Q2[0][0][0] + coordinate_dofs[5] * FE3_C0_D01_F_Q2[0][0][1];
    alignas(32) double sp[14];
    sp[0] = w[20][0] * w[21][0];
    sp[1] = sp[0] / w[42][0];
    sp[2] = w[22][0] * w[23][0];
    sp[3] = sp[2] / w[42][0];
    sp[4] = J_c0 * triangle_reference_facet_jacobian[facet][0][0];
    sp[5] = J_c1 * triangle_reference_facet_jacobian[facet][1][0];
    sp[6] = sp[4] + sp[5];
    sp[7] = sp[6] * sp[6];
    sp[8] = triangle_reference_facet_jacobian[facet][0][0] * J_c2;
    sp[9] = triangle_reference_facet_jacobian[facet][1][0] * J_c3;
    sp[10] = sp[8] + sp[9];
    sp[11] = sp[10] * sp[10];
    sp[12] = sp[7] + sp[11];
    sp[13] = std::sqrt(sp[12]);
    alignas(32) double BF0[3] = {};
    alignas(32) double BF1[3] = {};
    for (int iq = 0; iq < 2; ++iq)
    {
        // Quadrature loop body setup (num_points=2)
        // Unstructured varying computations for num_points=2
        double w0_c0 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c0 += w[0][ic] * FE3_C0_F_Q2[facet][iq][ic];
        double w0_c1 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c1 += w[0][ic + 3] * FE3_C0_F_Q2[facet][iq][ic];
        alignas(32) double sv2[6];
        sv2[0] = -1 * w0_c0 + w[40][0];
        sv2[1] = sv2[0] * sp[1];
        sv2[2] = -1 * w0_c1 + w[41][0];
        sv2[3] = sv2[2] * sp[3];
        sv2[4] = -1 * sv2[1] * sp[13];
        sv2[5] = -1 * sv2[3] * sp[13];
        const double fw0 = sv2[4] * weights2[iq];
        for (int i = 0; i < 3; ++i)
            BF0[i] += fw0 * FE3_C0_F_Q2[facet][iq][i];
        const double fw1 = sv2[5] * weights2[iq];
        for (int i = 0; i < 3; ++i)
            BF1[i] += fw1 * FE3_C0_F_Q2[facet][iq][i];
    }
    std::fill(A, A + 19, 0.0);
    for (int i = 0; i < 3; ++i)
        A[i] += BF0[i];
    for (int i = 0; i < 3; ++i)
        A[i + 3] += BF1[i];
}


vo2_2tdevice_cell_integral_1_otherwise::vo2_2tdevice_cell_integral_1_otherwise() : ufc::cell_integral()
{

}

vo2_2tdevice_cell_integral_1_otherwise::~vo2_2tdevice_cell_integral_1_otherwise()
{

}

const std::vector<bool> & vo2_2tdevice_cell_integral_1_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, true, true, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, true});
return enabled;
}

void vo2_2tdevice_cell_integral_1_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 43
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 43
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           43
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Quadrature rules
    alignas(32) static const double weights484[484] = { 5.108283279655129e-5, 0.0001166147694859507, 0.0001768834501643591, 0.0002291299708065146, 0.0002711814864745793, 0.0003015005725772319, 0.0003192648018749864, 0.0003244004504969336, 0.0003175646364920157, 0.0003000772018983532, 0.000273807667831913, 0.0002410259084858041, 0.0002042278115597915, 0.0001659489646276622, 0.0001285802071067258, 9.419866000058917e-5, 6.442660951898148e-5, 4.032846953459186e-5, 2.235314283883879e-5, 1.032565944499038e-5, 3.488249580797398e-6, 5.87300969910357e-7, 0.0001179462814416423, 0.0002692544181490804, 0.0004084101067484787, 0.0005290432527713102, 0.0006261369265263808, 0.0006961413344017068, 0.0007371575559705363, 0.0007490153685582217, 0.0007332320065485641, 0.0006928548823884555, 0.0006322005746941031, 0.0005565100461482903, 0.0004715461070136283, 0.000383163231469121, 0.0002968816814767249, 0.0002174973676206372, 0.0001487560223788058, 9.311529446265939e-5, 5.161166544688776e-5, 2.38411432627442e-5, 8.054096538342268e-6, 1.356032187249275e-6, 0.0001826150228728916, 0.000416883865501515, 0.0006323371968474928, 0.0008191122647082629, 0.0009694414080850142, 0.001077828517785298, 0.001141333514707625, 0.001159692844823463, 0.001135255626632478, 0.001072740137700442, 0.0009788296926100304, 0.0008616388203526983, 0.0007300900211976847, 0.0005932477177197415, 0.0004596588751315512, 0.0003367489528060134, 0.0002303174300804625, 0.0001441694593527985, 7.99098144586677e-5, 3.691299860433562e-5, 1.24700754071469e-5, 2.09953078523656e-6, 0.0002437382056542408, 0.0005564193117576571, 0.0008439871556203688, 0.001093277817391499, 0.001293923717645238, 0.001438589141216577, 0.001523349933381523, 0.0015478543257861, 0.001515237711778403, 0.001431797626410958, 0.001306454360460378, 0.001150038461736979, 0.0009744588858751905, 0.0007918140137141378, 0.0006135115702698431, 0.0004494623948327231, 0.0003074071139140728, 0.0001924245047312011, 0.0001066564759235384, 4.926817029396678e-5, 1.66439417540508e-5, 2.802265981510131e-6, 0.0003001190943212876, 0.0006851287817572259, 0.001039216072357992, 0.00134617200252365, 0.001593230791283482, 0.001771359844893672, 0.001875727283351738, 0.001905899968161717, 0.001865738563717379, 0.00176299733452292, 0.001608659989848595, 0.001416062371693855, 0.00119986818437918, 0.0009749743747760947, 0.0007554274732218726, 0.0005534308686100185, 0.0003785157290715749, 0.0002369356413785743, 0.0001313279749137089, 6.066475548141054e-5, 2.049397513103862e-5, 3.450478869985648e-6, 0.0003506590511134687, 0.0008005042433065706, 0.001214219717206016, 0.001572866925071813, 0.001861530332615692, 0.002069656260277666, 0.002191599141051756, 0.002226852896061714, 0.002179928324315674, 0.002059885505910417, 0.001879557803145413, 0.001654526809427448, 0.001401925592062538, 0.001139159738876644, 0.0008826412112967576, 0.0006466284448930736, 0.0004422576533756607, 0.000276835525472525, 0.0001534435627031284, 7.088068035540896e-5, 2.394515380384211e-5, 4.031538377031612e-6, 0.0003943740396672249, 0.0009002992827394936, 0.001365590688155886, 0.001768948729912627, 0.002093598425323878, 0.00232767041802137, 0.002464815335133391, 0.002504464007348091, 0.002451689573434643, 0.002316681590389023, 0.002113873294474446, 0.001860788761903328, 0.001576696957625837, 0.00128117334094328, 0.0009926758741020984, 0.0007272405237122993, 0.0004973918020415455, 0.0003113472877922962, 0.0001725726385559124, 7.971703612771869e-5, 2.693028172547722e-5, 4.534131004959922e-6, 0.0004304130831333102, 0.0009825712421476537, 0.001490382325579229, 0.001930600394967434, 0.002284917521059594, 0.002540379691280272, 0.002690057308650971, 0.002733329191517476, 0.002675732076782265, 0.002528386672710263, 0.002307045166552142, 0.002030833035426057, 0.001720780098181106, 0.001398250676360198, 0.001083389474329656, 0.0007936978718341015, 0.0005428449073944623, 0.0003397991058867691, 0.0001883428267438101, 8.700181007586837e-5, 2.939124896986619e-5, 4.948473045593627e-6, 0.0004580746763821116, 0.001045718686087781, 0.001586165542425838, 0.002054675347482351, 0.002431763566292457, 0.002703643663662696, 0.002862940694411857, 0.002908993555064283, 0.002847694815024116, 0.002690879883202519, 0.002455313301291934, 0.002161349693918952, 0.001831370414813687, 0.001488112818067813, 0.001153016258791637, 0.0008447068874831778, 0.000577732218245276, 0.0003616371610521019, 0.0002004471583008114, 9.259320303425283e-5, 3.128015245802266e-5, 5.266499271918798e-6, 0.0004768203972983156, 0.001088512474212207, 0.001651075955767289, 0.002138758516937411, 0.002531278260071089, 0.00281428446567378, 0.002980100384794568, 0.003028037859719935, 0.002964230600583311, 0.002800998354950267, 0.00255579171732528, 0.002249798281569605, 0.001906315310177545, 0.001549010634554083, 0.001200200969306226, 0.0008792747000804984, 0.0006013746667059968, 0.000376436384068648, 0.0002086500271378976, 9.638238072145081e-5, 3.25602254208539e-5, 5.482019427576626e-6, 0.0004862853721679167, 0.001110119652244107, 0.001683850125072304, 0.002181213277114738, 0.002581524611224038, 0.0028701485434155, 0.00303925593982281, 0.003088144982671973, 0.003023071137400092, 0.002856598700886834, 0.002606524665230787, 0.002294457202029766, 0.001944156028835136, 0.001579758787971745, 0.001224025185043052, 0.000896728468809547, 0.000613312067328617, 0.0003839087173316567, 0.0002127917695520046, 9.829558916758636e-5, 3.320655204006544e-5, 5.590838547754102e-6, 0.0004862853721679163, 0.001110119652244106, 0.001683850125072303, 0.002181213277114736, 0.002581524611224037, 0.002870148543415497, 0.003039255939822808, 0.003088144982671971, 0.003023071137400089, 0.002856598700886832, 0.002606524665230784, 0.002294457202029765, 0.001944156028835134, 0.001579758787971744, 0.001224025185043051, 0.0008967284688095463, 0.0006133120673286166, 0.0003839087173316564, 0.0002127917695520044, 9.829558916758628e-5, 3.320655204006541e-5, 5.590838547754097e-6, 0.0004768203972983154, 0.001088512474212206, 0.001651075955767288, 0.00213875851693741, 0.002531278260071087, 0.002814284465673778, 0.002980100384794566, 0.003028037859719934, 0.00296423060058331, 0.002800998354950265, 0.002555791717325279, 0.002249798281569604, 0.001906315310177544, 0.001549010634554082, 0.001200200969306225, 0.0008792747000804979, 0.0006013746667059965, 0.0003764363840686478, 0.0002086500271378975, 9.638238072145074e-5, 3.256022542085388e-5, 5.482019427576622e-6, 0.0004580746763821116, 0.001045718686087781, 0.001586165542425838, 0.002054675347482351, 0.002431763566292457, 0.002703643663662696, 0.002862940694411857, 0.002908993555064283, 0.002847694815024116, 0.002690879883202519, 0.002455313301291934, 0.002161349693918952, 0.001831370414813687, 0.001488112818067813, 0.001153016258791637, 0.0008447068874831778, 0.000577732218245276, 0.0003616371610521019, 0.0002004471583008114, 9.259320303425283e-5, 3.128015245802266e-5, 5.266499271918798e-6, 0.0004304130831333103, 0.0009825712421476542, 0.00149038232557923, 0.001930600394967435, 0.002284917521059595, 0.002540379691280273, 0.002690057308650972, 0.002733329191517478, 0.002675732076782266, 0.002528386672710264, 0.002307045166552143, 0.002030833035426058, 0.001720780098181107, 0.001398250676360198, 0.001083389474329657, 0.0007936978718341019, 0.0005428449073944625, 0.0003397991058867692, 0.0001883428267438101, 8.700181007586839e-5, 2.93912489698662e-5, 4.948473045593629e-6, 0.0003943740396672249, 0.0009002992827394936, 0.001365590688155886, 0.001768948729912627, 0.002093598425323878, 0.00232767041802137, 0.002464815335133391, 0.002504464007348091, 0.002451689573434643, 0.002316681590389023, 0.002113873294474446, 0.001860788761903328, 0.001576696957625837, 0.00128117334094328, 0.0009926758741020984, 0.0007272405237122993, 0.0004973918020415455, 0.0003113472877922962, 0.0001725726385559124, 7.971703612771869e-5, 2.693028172547722e-5, 4.534131004959922e-6, 0.0003506590511134687, 0.0008005042433065706, 0.001214219717206016, 0.001572866925071813, 0.001861530332615692, 0.002069656260277666, 0.002191599141051756, 0.002226852896061714, 0.002179928324315674, 0.002059885505910417, 0.001879557803145413, 0.001654526809427448, 0.001401925592062538, 0.001139159738876644, 0.0008826412112967576, 0.0006466284448930736, 0.0004422576533756607, 0.000276835525472525, 0.0001534435627031284, 7.088068035540896e-5, 2.394515380384211e-5, 4.031538377031612e-6, 0.0003001190943212874, 0.0006851287817572256, 0.001039216072357992, 0.00134617200252365, 0.001593230791283481, 0.001771359844893671, 0.001875727283351737, 0.001905899968161716, 0.001865738563717379, 0.001762997334522919, 0.001608659989848594, 0.001416062371693854, 0.001199868184379179, 0.0009749743747760943, 0.0007554274732218722, 0.0005534308686100183, 0.0003785157290715747, 0.0002369356413785741, 0.0001313279749137088, 6.06647554814105e-5, 2.049397513103861e-5, 3.450478869985647e-6, 0.000243738205654241, 0.0005564193117576575, 0.0008439871556203695, 0.0010932778173915, 0.001293923717645239, 0.001438589141216578, 0.001523349933381524, 0.001547854325786101, 0.001515237711778404, 0.001431797626410959, 0.00130645436046038, 0.00115003846173698, 0.0009744588858751912, 0.0007918140137141385, 0.0006135115702698436, 0.0004494623948327235, 0.0003074071139140731, 0.0001924245047312012, 0.0001066564759235385, 4.926817029396682e-5, 1.664394175405081e-5, 2.802265981510133e-6, 0.0001826150228728916, 0.000416883865501515, 0.0006323371968474928, 0.0008191122647082629, 0.0009694414080850142, 0.001077828517785298, 0.001141333514707625, 0.001159692844823463, 0.001135255626632478, 0.001072740137700442, 0.0009788296926100304, 0.0008616388203526983, 0.0007300900211976847, 0.0005932477177197415, 0.0004596588751315512, 0.0003367489528060134, 0.0002303174300804625, 0.0001441694593527985, 7.99098144586677e-5, 3.691299860433562e-5, 1.24700754071469e-5, 2.09953078523656e-6, 0.0001179462814416423, 0.0002692544181490804, 0.0004084101067484787, 0.0005290432527713102, 0.0006261369265263808, 0.0006961413344017068, 0.0007371575559705363, 0.0007490153685582217, 0.0007332320065485641, 0.0006928548823884555, 0.0006322005746941031, 0.0005565100461482903, 0.0004715461070136283, 0.000383163231469121, 0.0002968816814767249, 0.0002174973676206372, 0.0001487560223788058, 9.311529446265939e-5, 5.161166544688776e-5, 2.38411432627442e-5, 8.054096538342268e-6, 1.356032187249275e-6, 5.108283279655129e-5, 0.0001166147694859507, 0.0001768834501643591, 0.0002291299708065146, 0.0002711814864745793, 0.0003015005725772319, 0.0003192648018749864, 0.0003244004504969336, 0.0003175646364920157, 0.0003000772018983532, 0.000273807667831913, 0.0002410259084858041, 0.0002042278115597915, 0.0001659489646276622, 0.0001285802071067258, 9.419866000058917e-5, 6.442660951898148e-5, 4.032846953459186e-5, 2.235314283883879e-5, 1.032565944499038e-5, 3.488249580797398e-6, 5.87300969910357e-7 };
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE3_C0_D01_Q484[1][1][2] = { { { -1.0, 1.0 } } };
    alignas(32) static const double FE3_C0_Q484[1][484][3] =
        { { { 0.9944236387481719, 0.002844915242943752, 0.002731446008884253 },
            { 0.9828522554790107, 0.002811811037289716, 0.01433593348369973 },
            { 0.9622607701428295, 0.002752901505954078, 0.03498632835121647 },
            { 0.9330280882201585, 0.002669270647682605, 0.06430264113215883 },
            { 0.8956981818526072, 0.002562474695228724, 0.101739343452164 },
            { 0.8509662971859584, 0.002434502656376291, 0.1465992001576654 },
            { 0.7996656576081658, 0.002287738273651688, 0.1980466041181826 },
            { 0.7427518775939292, 0.002124915434383819, 0.255123206971687 },
            { 0.6812851440955464, 0.00194906719400647, 0.3167657887104472 },
            { 0.6164104614838174, 0.001763469259432472, 0.3818260692567502 },
            { 0.5493363200507374, 0.001571578962445362, 0.4490921009868173 },
            { 0.4813121831955092, 0.001376970853499832, 0.5173108459509911 },
            { 0.4136052119350939, 0.001183270113607154, 0.5852115179512991 },
            { 0.3474766600801475, 0.0009940850240383505, 0.6515292548958143 },
            { 0.2841583797734781, 0.0008129397517595944, 0.7150286804747623 },
            { 0.2248298752319714, 0.0006432087032060119, 0.7745269160648225 },
            { 0.1705963327073848, 0.000488053670888791, 0.8289156136217264 },
            { 0.1224680375861554, 0.0003503649484247161, 0.87718159746542 },
            { 0.08134156748369792, 0.0002327075264528777, 0.9184257249898493 },
            { 0.04798313333659054, 0.0001372734336900758, 0.9518795932297195 },
            { 0.02301449531865218, 6.584144421906071e-5, 0.9769196632371289 },
            { 0.006902767046988667, 1.974790866321444e-5, 0.9930774850443482 },
            { 0.9823396919756778, 0.01492886201543804, 0.002731446008884234 },
            { 0.9709089207897978, 0.01475514572650249, 0.01433593348369973 },
            { 0.9505676571931987, 0.01444601445558487, 0.03498632835121647 },
            { 0.9216902023172375, 0.0140071565506037, 0.06430264113215885 },
            { 0.8848139181123044, 0.01344673843553148, 0.101739343452164 },
            { 0.8406256022952713, 0.0127751975470632, 0.1465992001576654 },
            { 0.7899483531658729, 0.01200504271594442, 0.1980466041181826 },
            { 0.733726172849708, 0.01115062017860511, 0.255123206971687 },
            { 0.6730063652156464, 0.01022784607390641, 0.3167657887104472 },
            { 0.6089200208744653, 0.009253909868784587, 0.3818260692567502 },
            { 0.5426609448956904, 0.008246954117492362, 0.4490921009868173 },
            { 0.4754634175627763, 0.007225736486232718, 0.5173108459509911 },
            { 0.4085792017206328, 0.006209280328068184, 0.5852115179512991 },
            { 0.3432542247905175, 0.005216520313668306, 0.6515292548958143 },
            { 0.2807053698063544, 0.004265949718883343, 0.7150286804747623 },
            { 0.2220978079929125, 0.0033752759422649, 0.7745269160648225 },
            { 0.1685232957001252, 0.002561090678148428, 0.8289156136217264 },
            { 0.1209798416203134, 0.001838560914266648, 0.87718159746542 },
            { 0.08035312841853087, 0.001221146591619924, 0.9184257249898493 },
            { 0.04740005625895111, 0.0007203505113295137, 0.9518795932297195 },
            { 0.02273482986663566, 0.0003455068962355805, 0.9769196632371289 },
            { 0.006818886629902321, 0.0001036283257495605, 0.9930774850443482 },
            { 0.9608466969012456, 0.03642185708987034, 0.002731446008884234 },
            { 0.9496660240375671, 0.03599804247873322, 0.01433593348369973 },
            { 0.9297698149184167, 0.03524385673036689, 0.03498632835121647 },
            { 0.9015241811940196, 0.0341731776738217, 0.06430264113215885 },
            { 0.8654547276620749, 0.03280592888576104, 0.101739343452164 },
            { 0.8222332253230689, 0.03116757451926582, 0.1465992001576654 },
            { 0.7726647635864849, 0.0292886322953325, 0.1980466041181826 },
            { 0.717672690385486, 0.02720410264282717, 0.255123206971687 },
            { 0.6582813952171831, 0.02495281607236959, 0.3167657887104472 },
            { 0.5955972211176352, 0.02257670962561466, 0.3818260692567502 },
            { 0.5307878534274301, 0.0201200455857527, 0.4490921009868173 },
            { 0.465060567128018, 0.01762858692099105, 0.5173108459509911 },
            { 0.3996397372544911, 0.01514874479420982, 0.5852115179512991 },
            { 0.3357440310938107, 0.01272671401037516, 0.6515292548958143 },
            { 0.2745637070191358, 0.01040761250610183, 0.7150286804747622 },
            { 0.2172384430174086, 0.008234640917768833, 0.7745269160648225 },
            { 0.1648361084735507, 0.006248277904722946, 0.8289156136217264 },
            { 0.1183328762566097, 0.004485526277970383, 0.87718159746542 },
            { 0.07859505083353446, 0.002979224176616333, 0.9184257249898493 },
            { 0.04636297185319682, 0.001757434917083799, 0.9518795932297195 },
            { 0.0222374056147876, 0.000842931148083647, 0.9769196632371289 },
            { 0.006669693537180166, 0.0002528214184717157, 0.9930774850443482 },
            { 0.9303581057007801, 0.06691044829033578, 0.002731446008884234 },
            { 0.9195322063565258, 0.06613186015977454, 0.01433593348369973 },
            { 0.9002673231171741, 0.06474634853160949, 0.03498632835121647 },
            { 0.8729179505576417, 0.06277940831019939, 0.06430264113215883 },
            { 0.8379930155291234, 0.06026764101871245, 0.101739343452164 },
            { 0.7961429730911962, 0.05725782675113846, 0.1465992001576654 },
            { 0.7481473663909011, 0.0538060294909164, 0.1980466041181826 },
            { 0.6949002446420937, 0.04997654838621946, 0.255123206971687 },
            { 0.6373934924764284, 0.04584071881312446, 0.3167657887104472 },
            { 0.5766983475997767, 0.04147558314347324, 0.3818260692567502 },
            { 0.5139454435721306, 0.03696245544105217, 0.4490921009868173 },
            { 0.4503037473769063, 0.0323854066721028, 0.5173108459509911 },
            { 0.3869587834499886, 0.02782969859871239, 0.5852115179512991 },
            { 0.3250905495914773, 0.02338019551270858, 0.6515292548958143 },
            { 0.2658515361298694, 0.01911978339536825, 0.7150286804747623 },
            { 0.2103452579718195, 0.01512782596335794, 0.7745269160648225 },
            { 0.1596056999780712, 0.01147868640020246, 0.8289156136217264 },
            { 0.1145780601122671, 0.008240342422312971, 0.87718159746542 },
            { 0.07610115416617702, 0.005473120843973775, 0.9184257249898493 },
            { 0.04489183009850328, 0.003228576671777338, 0.9518795932297195 },
            { 0.02153179131509264, 0.001548545447778604, 0.9769196632371289 },
            { 0.006458057736856038, 0.0004644572187958438, 0.9930774850443482 },
            { 0.8914667404499501, 0.1058018135411657, 0.002731446008884234 },
            { 0.8810933915838249, 0.1045706749324754, 0.01433593348369973 },
            { 0.8626338300866983, 0.1023798415620853, 0.03498632835121647 },
            { 0.8364277317471424, 0.09926962712069887, 0.06430264113215885 },
            { 0.8029627489630692, 0.09529790758476664, 0.101739343452164 },
            { 0.762862146097112, 0.09053865374522251, 0.1465992001576654 },
            { 0.7168728793848052, 0.08508051649701232, 0.1980466041181826 },
            { 0.6658516244799572, 0.07902516854835594, 0.255123206971687 },
            { 0.6107488026817059, 0.07248540860784693, 0.3167657887104472 },
            { 0.5525908712005045, 0.06558305954274521, 0.3818260692567501 },
            { 0.4924612002012322, 0.05844669881195051, 0.4490921009868173 },
            { 0.4314798908363526, 0.05120926321265641, 0.5173108459509911 },
            { 0.3707829095666363, 0.04400557248206464, 0.5852115179512991 },
            { 0.3115009272446801, 0.03696981785950567, 0.6515292548958143 },
            { 0.2547382571346454, 0.03023306239059232, 0.7150286804747623 },
            { 0.2015522843776354, 0.02392079955754202, 0.7745269160648225 },
            { 0.1529337706038589, 0.01815061577441475, 0.8289156136217264 },
            { 0.1097884020674208, 0.01303000046715929, 0.87718159746542 },
            { 0.07291992989935864, 0.008654345110792159, 0.9184257249898493 },
            { 0.04301523596723161, 0.005105170803049007, 0.9518795932297195 },
            { 0.02063170697616046, 0.002448629786710787, 0.9769196632371289 },
            { 0.006188094288678392, 0.0007344206669734896, 0.9930774850443482 },
            { 0.8449294313572732, 0.1523391226338427, 0.002731446008884234 },
            { 0.8350976032463311, 0.1505664632699692, 0.01433593348369973 },
            { 0.8176016877049397, 0.1474119839438439, 0.03498632835121647 },
            { 0.7927636283994878, 0.1429337304683534, 0.06430264113215885 },
            { 0.7610456207710077, 0.1372150357768283, 0.101739343452164 },
            { 0.7230383928630818, 0.1303624069792529, 0.1465992001576654 },
            { 0.6794499074955236, 0.1225034883862938, 0.1980466041181826 },
            { 0.6310921192149097, 0.1137846738134034, 0.255123206971687 },
            { 0.578865834401773, 0.1043683768877798, 0.3167657887104472 },
            { 0.5237439260392417, 0.09443000470400816, 0.3818260692567502 },
            { 0.4667532090333866, 0.08415468997979607, 0.4490921009868173 },
            { 0.4089553118072002, 0.0737338422418088, 0.5173108459509911 },
            { 0.3514268998740309, 0.06336158217467004, 0.5852115179512991 },
            { 0.2952396195861079, 0.05323112551807787, 0.6515292548958143 },
            { 0.2414401356545088, 0.04353118387072892, 0.7150286804747623 },
            { 0.19103063445979, 0.03444244947538745, 0.7745269160648225 },
            { 0.1449501568240469, 0.02613422955422674, 0.8289156136217264 },
            { 0.1040571093898904, 0.01876129314468966, 0.87718159746542 },
            { 0.06911328500419406, 0.01246099000595674, 0.9184257249898493 },
            { 0.04076970818580133, 0.007350698584479285, 0.9518795932297195 },
            { 0.01955466833737229, 0.003525668425498951, 0.9769196632371289 },
            { 0.005865056710785688, 0.001057458244866194, 0.9930774850443482 },
            { 0.7916519247316047, 0.2056166292595111, 0.002731446008884234 },
            { 0.7824400481431012, 0.2032240183731991, 0.01433593348369973 },
            { 0.7660473475230806, 0.198966324125703, 0.03498632835121647 },
            { 0.7427754661966455, 0.1929218926711958, 0.06430264113215885 },
            { 0.7130574556079948, 0.1852032009398411, 0.101739343452164 },
            { 0.6774467951074027, 0.175954004734932, 0.1465992001576654 },
            { 0.6366068065157733, 0.165346589366044, 0.1980466041181826 },
            { 0.5912982461232027, 0.1535785469051104, 0.255123206971687 },
            { 0.5423651194507361, 0.1408690918388167, 0.3167657887104472 },
            { 0.4907189544213334, 0.1274549763219165, 0.3818260692567502 },
            { 0.4373218195422172, 0.1135860794709656, 0.4490921009868173 },
            { 0.3831684016513892, 0.09952075239761977, 0.5173108459509911 },
            { 0.3292674765049095, 0.08552100554379151, 0.5852115179512991 },
            { 0.2766231171837819, 0.07184762792040399, 0.6515292548958143 },
            { 0.2262159903594727, 0.05875532916576505, 0.7150286804747623 },
            { 0.1789850889793964, 0.046487994955781, 0.7745269160648225 },
            { 0.1358102421116673, 0.03527414426660631, 0.8289156136217264 },
            { 0.09749572907903747, 0.02532267345554262, 0.87718159746542 },
            { 0.06475530744644975, 0.01681896756370104, 0.9184257249898493 },
            { 0.03819895101084247, 0.009921455759438145, 0.9518795932297195 },
            { 0.01832163758564015, 0.004758699177231095, 0.9769196632371289 },
            { 0.005495232218736823, 0.001427282736915058, 0.9930774850443482 },
            { 0.7326711859237288, 0.264597368067387, 0.002731446008884234 },
            { 0.7241456252147466, 0.2615184413015538, 0.01433593348369973 },
            { 0.7089742360870878, 0.2560394355616958, 0.03498632835121647 },
            { 0.6874361884206261, 0.2482611704472151, 0.06430264113215885 },
            { 0.65993226986619, 0.2383283866816458, 0.101739343452164 },
            { 0.6269747236954513, 0.2264260761468835, 0.1465992001576654 },
            { 0.5891774520161267, 0.2127759438656907, 0.1980466041181826 },
            { 0.5472445322085027, 0.1976322608198105, 0.255123206971687 },
            { 0.501957088535291, 0.1812771227542618, 0.3167657887104472 },
            { 0.4541587370144077, 0.1640151937288421, 0.3818260692567502 },
            { 0.4047398688040194, 0.1461680302091633, 0.4490921009868173 },
            { 0.3546210632174002, 0.1280680908316088, 0.5173108459509911 },
            { 0.304735938813962, 0.110052543234739, 0.5852115179512991 },
            { 0.2560137618432153, 0.09245698326097056, 0.6515292548958143 },
            { 0.2093621360015988, 0.07560918352363895, 0.7150286804747623 },
            { 0.1656500960945155, 0.05982298784066194, 0.7745269160648225 },
            { 0.1256919209566492, 0.04539246542162446, 0.8289156136217264 },
            { 0.09023196838819636, 0.03258643414638374, 0.87718159746542 },
            { 0.0599308186078511, 0.0216434564022997, 0.9184257249898493 },
            { 0.03535300030710459, 0.01276740646317603, 0.9518795932297195 },
            { 0.0169566137826126, 0.006123722980258649, 0.9769196632371289 },
            { 0.005085818881818804, 0.001836696073833077, 0.9930774850443482 },
            { 0.669135197824965, 0.3281333561661509, 0.002731446008884234 },
            { 0.6613489591121906, 0.3243151074041097, 0.01433593348369973 },
            { 0.6474932068180472, 0.3175204648307363, 0.03498632835121647 },
            { 0.6278229016894358, 0.3078744571784054, 0.06430264113215885 },
            { 0.6027040757597913, 0.2955565807880445, 0.101739343452164 },
            { 0.5726045514431922, 0.2807962483991422, 0.1465992001576654 },
            { 0.5380849943099306, 0.2638684015718868, 0.1980466041181826 },
            { 0.4997884253579562, 0.2450883676703569, 0.255123206971687 },
            { 0.4584282310942009, 0.2248059801953519, 0.3167657887104472 },
            { 0.4147748706030147, 0.2033990601402351, 0.3818260692567502 },
            { 0.3696415218490944, 0.1812663771640884, 0.4490921009868173 },
            { 0.3238689330872313, 0.1588202209617777, 0.5173108459509911 },
            { 0.2783097610773025, 0.1364787209713985, 0.5852115179512991 },
            { 0.2338126876941309, 0.1146580574100549, 0.6515292548958143 },
            { 0.1912066107989001, 0.09376470872633759, 0.7150286804747623 },
            { 0.151285203989811, 0.07418787994536637, 0.7745269160648225 },
            { 0.1147921332381736, 0.05629225314010007, 0.8289156136217264 },
            { 0.08240720691294806, 0.04041119562163203, 0.87718159746542 },
            { 0.05473372084971162, 0.02684055416043917, 0.9184257249898493 },
            { 0.03228724878046874, 0.01583315798981189, 0.9518795932297195 },
            { 0.01548616533017466, 0.007594171432696583, 0.9769196632371289 },
            { 0.004644785394825157, 0.002277729560826725, 0.9930774850443482 },
            { 0.6022806105732273, 0.3949879434178885, 0.002731446008884234 },
            { 0.5952723099768129, 0.3903917565394874, 0.01433593348369973 },
            { 0.5828009125988334, 0.3822127590499502, 0.03498632835121647 },
            { 0.5650959055665762, 0.370601453301265, 0.06430264113215885 },
            { 0.5424867499475554, 0.3557739066002805, 0.101739343452164 },
            { 0.5153945271168158, 0.3380062727255187, 0.1465992001576654 },
            { 0.4843238854669401, 0.3176295104148774, 0.1980466041181826 },
            { 0.4498536005286661, 0.295023192499647, 0.255123206971687 },
            { 0.4126257829880948, 0.270608428301458, 0.3167657887104472 },
            { 0.3733339138775384, 0.2448400168657115, 0.3818260692567502 },
            { 0.3327099249839872, 0.2181979740291955, 0.4490921009868173 },
            { 0.2915105637837064, 0.1911785902653027, 0.5173108459509911 },
            { 0.2505032964563517, 0.1642851855923492, 0.585211517951299 },
            { 0.2104520114349522, 0.1380187336692337, 0.6515292548958143 },
            { 0.1721027897978295, 0.1128685297274082, 0.7150286804747623 },
            { 0.1361700076843262, 0.08930307625085117, 0.7745269160648225 },
            { 0.103323029965277, 0.06776135641299658, 0.8289156136217263 },
            { 0.07417374404529181, 0.04864465848928828, 0.87718159746542 },
            { 0.04926516931027147, 0.03230910569987933, 0.9184257249898493 },
            { 0.02906136752698091, 0.01905903924329971, 0.9518795932297195 },
            { 0.01393891270525477, 0.009141424057616476, 0.9769196632371289 },
            { 0.004180715934044621, 0.002741799021607261, 0.9930774850443482 },
            { 0.5334086691255333, 0.4638598848655826, 0.002731446008884234 },
            { 0.5272017811262547, 0.4584622853900456, 0.01433593348369973 },
            { 0.5161565119265834, 0.4488571597222002, 0.03498632835121647 },
            { 0.5004761063612339, 0.4352212525066073, 0.06430264113215885 },
            { 0.4804523509935893, 0.4178083055542466, 0.101739343452164 },
            { 0.4564581757369043, 0.3969426241054302, 0.1465992001576654 },
            { 0.4289405214734495, 0.373012874408368, 0.1980466041181826 },
            { 0.3984119796434164, 0.3464648133848967, 0.255123206971687 },
            { 0.3654412343460298, 0.3177929769435229, 0.3167657887104472 },
            { 0.3306424657292402, 0.2875314650140096, 0.3818260692567501 },
            { 0.2946639077782284, 0.2562439912349542, 0.4490921009868172 },
            { 0.2581757724458491, 0.2245133816031598, 0.517310845950991 },
            { 0.221857764684084, 0.192930717364617, 0.5852115179512991 },
            { 0.186386420820467, 0.1620843242837189, 0.6515292548958143 },
            { 0.1524225061329451, 0.1325488133922926, 0.7150286804747623 },
            { 0.1205987064809867, 0.1048743774541907, 0.7745269160648225 },
            { 0.0915078435803225, 0.07957654279795114, 0.8289156136217264 },
            { 0.06569183433881542, 0.05712656819576467, 0.87718159746542 },
            { 0.04363160283547091, 0.03794267217467989, 0.9184257249898493 },
            { 0.02573814448514467, 0.02238226228513596, 0.9518795932297195 },
            { 0.01234497133834417, 0.01073536542452708, 0.9769196632371289 },
            { 0.003702643059101951, 0.003219871896549931, 0.9930774850443482 },
            { 0.4638598848655827, 0.5334086691255332, 0.002731446008884234 },
            { 0.4584622853900456, 0.5272017811262547, 0.01433593348369973 },
            { 0.4488571597222001, 0.5161565119265834, 0.03498632835121647 },
            { 0.4352212525066073, 0.5004761063612339, 0.06430264113215885 },
            { 0.4178083055542466, 0.4804523509935893, 0.101739343452164 },
            { 0.3969426241054302, 0.4564581757369043, 0.1465992001576654 },
            { 0.373012874408368, 0.4289405214734495, 0.1980466041181826 },
            { 0.3464648133848967, 0.3984119796434164, 0.255123206971687 },
            { 0.317792976943523, 0.3654412343460299, 0.3167657887104472 },
            { 0.2875314650140097, 0.3306424657292402, 0.3818260692567502 },
            { 0.2562439912349542, 0.2946639077782285, 0.4490921009868173 },
            { 0.2245133816031599, 0.2581757724458492, 0.5173108459509911 },
            { 0.192930717364617, 0.221857764684084, 0.5852115179512991 },
            { 0.1620843242837189, 0.1863864208204669, 0.6515292548958143 },
            { 0.1325488133922926, 0.1524225061329451, 0.7150286804747623 },
            { 0.1048743774541907, 0.1205987064809867, 0.7745269160648225 },
            { 0.07957654279795114, 0.0915078435803225, 0.8289156136217264 },
            { 0.05712656819576467, 0.06569183433881542, 0.87718159746542 },
            { 0.03794267217467984, 0.04363160283547096, 0.9184257249898493 },
            { 0.0223822622851359, 0.02573814448514472, 0.9518795932297195 },
            { 0.01073536542452708, 0.01234497133834417, 0.9769196632371289 },
            { 0.003219871896549875, 0.003702643059102007, 0.9930774850443482 },
            { 0.3949879434178886, 0.6022806105732273, 0.002731446008884234 },
            { 0.3903917565394874, 0.5952723099768129, 0.01433593348369973 },
            { 0.3822127590499501, 0.5828009125988335, 0.03498632835121647 },
            { 0.370601453301265, 0.5650959055665762, 0.06430264113215885 },
            { 0.3557739066002805, 0.5424867499475554, 0.101739343452164 },
            { 0.3380062727255188, 0.5153945271168158, 0.1465992001576654 },
            { 0.3176295104148774, 0.4843238854669401, 0.1980466041181826 },
            { 0.295023192499647, 0.4498536005286661, 0.255123206971687 },
            { 0.270608428301458, 0.4126257829880948, 0.3167657887104472 },
            { 0.2448400168657114, 0.3733339138775383, 0.3818260692567501 },
            { 0.2181979740291954, 0.3327099249839872, 0.4490921009868172 },
            { 0.1911785902653027, 0.2915105637837062, 0.517310845950991 },
            { 0.1642851855923492, 0.2505032964563518, 0.5852115179512991 },
            { 0.1380187336692337, 0.2104520114349521, 0.6515292548958143 },
            { 0.1128685297274082, 0.1721027897978295, 0.7150286804747623 },
            { 0.08930307625085111, 0.1361700076843263, 0.7745269160648225 },
            { 0.06776135641299659, 0.103323029965277, 0.8289156136217264 },
            { 0.04864465848928828, 0.07417374404529181, 0.87718159746542 },
            { 0.03230910569987927, 0.04926516931027153, 0.9184257249898493 },
            { 0.01905903924329966, 0.02906136752698096, 0.9518795932297195 },
            { 0.009141424057616476, 0.01393891270525477, 0.9769196632371289 },
            { 0.002741799021607205, 0.004180715934044676, 0.9930774850443482 },
            { 0.3281333561661509, 0.6691351978249647, 0.002731446008884253 },
            { 0.3243151074041096, 0.6613489591121907, 0.01433593348369973 },
            { 0.3175204648307362, 0.6474932068180473, 0.03498632835121647 },
            { 0.3078744571784053, 0.6278229016894358, 0.06430264113215883 },
            { 0.2955565807880445, 0.6027040757597913, 0.101739343452164 },
            { 0.2807962483991423, 0.5726045514431922, 0.1465992001576654 },
            { 0.2638684015718868, 0.5380849943099306, 0.1980466041181826 },
            { 0.2450883676703569, 0.4997884253579562, 0.255123206971687 },
            { 0.2248059801953519, 0.4584282310942008, 0.3167657887104472 },
            { 0.2033990601402351, 0.4147748706030147, 0.3818260692567501 },
            { 0.1812663771640883, 0.3696415218490944, 0.4490921009868172 },
            { 0.1588202209617777, 0.3238689330872312, 0.517310845950991 },
            { 0.1364787209713985, 0.2783097610773025, 0.5852115179512991 },
            { 0.114658057410055, 0.2338126876941309, 0.6515292548958143 },
            { 0.09376470872633759, 0.1912066107989001, 0.7150286804747623 },
            { 0.07418787994536637, 0.151285203989811, 0.7745269160648225 },
            { 0.05629225314010005, 0.1147921332381736, 0.8289156136217263 },
            { 0.04041119562163203, 0.08240720691294806, 0.87718159746542 },
            { 0.02684055416043912, 0.05473372084971168, 0.9184257249898493 },
            { 0.01583315798981183, 0.03228724878046879, 0.9518795932297195 },
            { 0.007594171432696583, 0.01548616533017466, 0.9769196632371289 },
            { 0.002277729560826669, 0.004644785394825213, 0.9930774850443482 },
            { 0.2645973680673872, 0.7326711859237287, 0.002731446008884234 },
            { 0.2615184413015537, 0.7241456252147466, 0.01433593348369973 },
            { 0.2560394355616957, 0.7089742360870879, 0.03498632835121647 },
            { 0.2482611704472151, 0.6874361884206261, 0.06430264113215885 },
            { 0.2383283866816458, 0.65993226986619, 0.101739343452164 },
            { 0.2264260761468835, 0.6269747236954512, 0.1465992001576654 },
            { 0.2127759438656908, 0.5891774520161267, 0.1980466041181826 },
            { 0.1976322608198105, 0.5472445322085027, 0.255123206971687 },
            { 0.1812771227542619, 0.5019570885352909, 0.3167657887104472 },
            { 0.1640151937288421, 0.4541587370144077, 0.3818260692567502 },
            { 0.1461680302091633, 0.4047398688040195, 0.4490921009868173 },
            { 0.1280680908316087, 0.3546210632174002, 0.517310845950991 },
            { 0.110052543234739, 0.304735938813962, 0.5852115179512991 },
            { 0.09245698326097061, 0.2560137618432152, 0.6515292548958143 },
            { 0.07560918352363895, 0.2093621360015988, 0.7150286804747623 },
            { 0.05982298784066188, 0.1656500960945155, 0.7745269160648225 },
            { 0.04539246542162446, 0.1256919209566492, 0.8289156136217264 },
            { 0.03258643414638374, 0.09023196838819636, 0.87718159746542 },
            { 0.02164345640229964, 0.05993081860785116, 0.9184257249898493 },
            { 0.01276740646317598, 0.03535300030710464, 0.9518795932297195 },
            { 0.006123722980258649, 0.0169566137826126, 0.9769196632371289 },
            { 0.001836696073833022, 0.00508581888181886, 0.9930774850443482 },
            { 0.205616629259511, 0.7916519247316046, 0.002731446008884253 },
            { 0.2032240183731991, 0.7824400481431012, 0.01433593348369973 },
            { 0.198966324125703, 0.7660473475230806, 0.03498632835121647 },
            { 0.1929218926711957, 0.7427754661966454, 0.06430264113215883 },
            { 0.1852032009398411, 0.7130574556079947, 0.101739343452164 },
            { 0.175954004734932, 0.6774467951074027, 0.1465992001576654 },
            { 0.1653465893660441, 0.6366068065157734, 0.1980466041181826 },
            { 0.1535785469051104, 0.5912982461232027, 0.255123206971687 },
            { 0.1408690918388167, 0.5423651194507362, 0.3167657887104472 },
            { 0.1274549763219165, 0.4907189544213334, 0.3818260692567502 },
            { 0.1135860794709655, 0.4373218195422172, 0.4490921009868172 },
            { 0.09952075239761982, 0.3831684016513891, 0.517310845950991 },
            { 0.08552100554379151, 0.3292674765049095, 0.5852115179512991 },
            { 0.07184762792040404, 0.2766231171837818, 0.6515292548958143 },
            { 0.05875532916576503, 0.2262159903594727, 0.7150286804747622 },
            { 0.04648799495578106, 0.1789850889793964, 0.7745269160648225 },
            { 0.03527414426660631, 0.1358102421116673, 0.8289156136217264 },
            { 0.02532267345554262, 0.09749572907903747, 0.87718159746542 },
            { 0.01681896756370099, 0.06475530744644981, 0.9184257249898493 },
            { 0.00992145575943809, 0.03819895101084253, 0.9518795932297195 },
            { 0.004758699177231095, 0.01832163758564015, 0.9769196632371289 },
            { 0.001427282736915003, 0.005495232218736879, 0.9930774850443482 },
            { 0.1523391226338427, 0.8449294313572732, 0.002731446008884234 },
            { 0.1505664632699692, 0.8350976032463311, 0.01433593348369973 },
            { 0.1474119839438439, 0.8176016877049397, 0.03498632835121647 },
            { 0.1429337304683535, 0.7927636283994878, 0.06430264113215885 },
            { 0.1372150357768282, 0.7610456207710077, 0.101739343452164 },
            { 0.1303624069792529, 0.7230383928630818, 0.1465992001576654 },
            { 0.1225034883862939, 0.6794499074955236, 0.1980466041181826 },
            { 0.1137846738134034, 0.6310921192149097, 0.255123206971687 },
            { 0.1043683768877798, 0.5788658344017731, 0.3167657887104472 },
            { 0.0944300047040081, 0.5237439260392418, 0.3818260692567502 },
            { 0.08415468997979599, 0.4667532090333867, 0.4490921009868173 },
            { 0.07373384224180889, 0.4089553118072001, 0.5173108459509911 },
            { 0.06336158217467013, 0.3514268998740309, 0.5852115179512991 },
            { 0.05323112551807795, 0.2952396195861079, 0.6515292548958143 },
            { 0.04353118387072892, 0.2414401356545088, 0.7150286804747623 },
            { 0.03444244947538745, 0.19103063445979, 0.7745269160648225 },
            { 0.02613422955422674, 0.1449501568240469, 0.8289156136217264 },
            { 0.01876129314468966, 0.1040571093898904, 0.87718159746542 },
            { 0.01246099000595668, 0.06911328500419411, 0.9184257249898493 },
            { 0.00735069858447923, 0.04076970818580139, 0.9518795932297195 },
            { 0.003525668425498951, 0.01955466833737229, 0.9769196632371289 },
            { 0.001057458244866138, 0.005865056710785743, 0.9930774850443482 },
            { 0.1058018135411657, 0.8914667404499501, 0.002731446008884234 },
            { 0.1045706749324754, 0.8810933915838249, 0.01433593348369973 },
            { 0.1023798415620853, 0.8626338300866983, 0.03498632835121647 },
            { 0.09926962712069887, 0.8364277317471424, 0.06430264113215885 },
            { 0.09529790758476664, 0.8029627489630692, 0.101739343452164 },
            { 0.09053865374522251, 0.762862146097112, 0.1465992001576654 },
            { 0.08508051649701225, 0.716872879384805, 0.1980466041181826 },
            { 0.07902516854835581, 0.6658516244799572, 0.2551232069716869 },
            { 0.07248540860784693, 0.6107488026817059, 0.3167657887104472 },
            { 0.06558305954274526, 0.5525908712005047, 0.3818260692567502 },
            { 0.05844669881195044, 0.4924612002012322, 0.4490921009868173 },
            { 0.05120926321265647, 0.4314798908363525, 0.5173108459509911 },
            { 0.04400557248206464, 0.3707829095666363, 0.5852115179512991 },
            { 0.03696981785950575, 0.3115009272446801, 0.6515292548958143 },
            { 0.03023306239059232, 0.2547382571346454, 0.7150286804747623 },
            { 0.02392079955754202, 0.2015522843776354, 0.7745269160648225 },
            { 0.01815061577441475, 0.1529337706038589, 0.8289156136217264 },
            { 0.01303000046715929, 0.1097884020674208, 0.87718159746542 },
            { 0.008654345110792104, 0.07291992989935869, 0.9184257249898493 },
            { 0.005105170803048951, 0.04301523596723167, 0.9518795932297195 },
            { 0.002448629786710787, 0.02063170697616046, 0.9769196632371289 },
            { 0.0007344206669734341, 0.006188094288678447, 0.9930774850443482 },
            { 0.06691044829033581, 0.9303581057007798, 0.002731446008884253 },
            { 0.06613186015977461, 0.9195322063565258, 0.01433593348369973 },
            { 0.06474634853160961, 0.9002673231171739, 0.03498632835121647 },
            { 0.06277940831019958, 0.8729179505576417, 0.06430264113215885 },
            { 0.06026764101871252, 0.8379930155291233, 0.101739343452164 },
            { 0.05725782675113859, 0.7961429730911961, 0.1465992001576654 },
            { 0.05380602949091653, 0.748147366390901, 0.1980466041181826 },
            { 0.04997654838621952, 0.6949002446420934, 0.2551232069716869 },
            { 0.04584071881312458, 0.6373934924764283, 0.3167657887104472 },
            { 0.04147558314347334, 0.5766983475997766, 0.3818260692567502 },
            { 0.0369624554410521, 0.5139454435721307, 0.4490921009868173 },
            { 0.03238540667210285, 0.4503037473769061, 0.5173108459509911 },
            { 0.02782969859871245, 0.3869587834499885, 0.585211517951299 },
            { 0.02338019551270864, 0.3250905495914772, 0.6515292548958143 },
            { 0.01911978339536825, 0.2658515361298694, 0.7150286804747623 },
            { 0.01512782596335794, 0.2103452579718195, 0.7745269160648225 },
            { 0.01147868640020246, 0.1596056999780712, 0.8289156136217264 },
            { 0.008240342422313026, 0.1145780601122671, 0.87718159746542 },
            { 0.00547312084397372, 0.07610115416617708, 0.9184257249898493 },
            { 0.003228576671777282, 0.04489183009850334, 0.9518795932297195 },
            { 0.001548545447778604, 0.02153179131509264, 0.9769196632371289 },
            { 0.0004644572187957883, 0.006458057736856093, 0.9930774850443482 },
            { 0.03642185708987025, 0.9608466969012454, 0.002731446008884253 },
            { 0.03599804247873335, 0.9496660240375669, 0.01433593348369973 },
            { 0.03524385673036689, 0.9297698149184167, 0.03498632835121647 },
            { 0.03417317767382177, 0.9015241811940194, 0.06430264113215885 },
            { 0.03280592888576111, 0.8654547276620748, 0.101739343452164 },
            { 0.03116757451926595, 0.8222332253230688, 0.1465992001576654 },
            { 0.0292886322953325, 0.7726647635864849, 0.1980466041181826 },
            { 0.02720410264282723, 0.7176726903854859, 0.255123206971687 },
            { 0.02495281607236965, 0.6582813952171832, 0.3167657887104472 },
            { 0.02257670962561461, 0.5955972211176351, 0.3818260692567501 },
            { 0.0201200455857526, 0.5307878534274302, 0.4490921009868173 },
            { 0.01762858692099109, 0.4650605671280178, 0.517310845950991 },
            { 0.01514874479420982, 0.3996397372544911, 0.5852115179512991 },
            { 0.01272671401037525, 0.3357440310938106, 0.6515292548958143 },
            { 0.01040761250610185, 0.2745637070191358, 0.7150286804747623 },
            { 0.008234640917768833, 0.2172384430174086, 0.7745269160648225 },
            { 0.006248277904723001, 0.1648361084735506, 0.8289156136217264 },
            { 0.004485526277970438, 0.1183328762566097, 0.87718159746542 },
            { 0.002979224176616278, 0.07859505083353452, 0.9184257249898493 },
            { 0.001757434917083743, 0.04636297185319688, 0.9518795932297195 },
            { 0.000842931148083647, 0.0222374056147876, 0.9769196632371289 },
            { 0.0002528214184716602, 0.006669693537180221, 0.9930774850443482 },
            { 0.01492886201543804, 0.9823396919756778, 0.002731446008884234 },
            { 0.01475514572650249, 0.9709089207897978, 0.01433593348369973 },
            { 0.01444601445558487, 0.9505676571931987, 0.03498632835121647 },
            { 0.0140071565506037, 0.9216902023172375, 0.06430264113215885 },
            { 0.0134467384355316, 0.8848139181123043, 0.101739343452164 },
            { 0.0127751975470632, 0.8406256022952713, 0.1465992001576654 },
            { 0.01200504271594448, 0.789948353165873, 0.1980466041181826 },
            { 0.01115062017860505, 0.733726172849708, 0.2551232069716869 },
            { 0.01022784607390641, 0.6730063652156464, 0.3167657887104472 },
            { 0.00925390986878465, 0.6089200208744652, 0.3818260692567502 },
            { 0.008246954117492234, 0.5426609448956905, 0.4490921009868172 },
            { 0.007225736486232788, 0.4754634175627762, 0.5173108459509911 },
            { 0.006209280328068184, 0.4085792017206328, 0.5852115179512991 },
            { 0.00521652031366839, 0.3432542247905174, 0.6515292548958143 },
            { 0.004265949718883371, 0.2807053698063543, 0.7150286804747623 },
            { 0.003375275942264928, 0.2220978079929125, 0.7745269160648225 },
            { 0.002561090678148428, 0.1685232957001252, 0.8289156136217264 },
            { 0.001838560914266648, 0.1209798416203134, 0.87718159746542 },
            { 0.001221146591619868, 0.08035312841853093, 0.9184257249898493 },
            { 0.0007203505113294582, 0.04740005625895116, 0.9518795932297195 },
            { 0.0003455068962355805, 0.02273482986663566, 0.9769196632371289 },
            { 0.000103628325749505, 0.006818886629902376, 0.9930774850443482 },
            { 0.002844915242943845, 0.994423638748172, 0.002731446008884234 },
            { 0.002811811037289716, 0.9828522554790107, 0.01433593348369973 },
            { 0.002752901505954078, 0.9622607701428295, 0.03498632835121647 },
            { 0.002669270647682679, 0.9330280882201586, 0.06430264113215885 },
            { 0.002562474695228794, 0.8956981818526071, 0.101739343452164 },
            { 0.002434502656376217, 0.8509662971859583, 0.1465992001576654 },
            { 0.002287738273651688, 0.7996656576081658, 0.1980466041181826 },
            { 0.002124915434383881, 0.7427518775939292, 0.255123206971687 },
            { 0.00194906719400647, 0.6812851440955464, 0.3167657887104472 },
            { 0.00176346925943241, 0.6164104614838175, 0.3818260692567502 },
            { 0.001571578962445362, 0.5493363200507374, 0.4490921009868173 },
            { 0.001376970853499864, 0.4813121831955091, 0.517310845950991 },
            { 0.001183270113607154, 0.4136052119350939, 0.5852115179512991 },
            { 0.0009940850240383783, 0.3474766600801475, 0.6515292548958143 },
            { 0.0008129397517595944, 0.2841583797734781, 0.7150286804747623 },
            { 0.0006432087032060119, 0.2248298752319714, 0.7745269160648225 },
            { 0.000488053670888791, 0.1705963327073848, 0.8289156136217264 },
            { 0.0003503649484247161, 0.1224680375861554, 0.87718159746542 },
            { 0.0002327075264528222, 0.08134156748369797, 0.9184257249898493 },
            { 0.0001372734336900203, 0.0479831333365906, 0.9518795932297195 },
            { 6.584144421906071e-5, 0.02301449531865218, 0.9769196632371289 },
            { 1.974790866315893e-5, 0.006902767046988723, 0.9930774850443482 } } };
    alignas(32) static const double PI0[1][2][2] =
        { { { 0.5, -0.5 },
            { -0.5, 0.5 } } };
    // Unstructured piecewise computations
    const double w0_d1_c5 = w[0][15] * FE3_C0_D01_Q484[0][0][0] + w[0][17] * FE3_C0_D01_Q484[0][0][1];
    const double J_c0 = coordinate_dofs[0] * FE3_C0_D01_Q484[0][0][0] + coordinate_dofs[2] * FE3_C0_D01_Q484[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE3_C0_D01_Q484[0][0][0] + coordinate_dofs[5] * FE3_C0_D01_Q484[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE3_C0_D01_Q484[0][0][0] + coordinate_dofs[4] * FE3_C0_D01_Q484[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE3_C0_D01_Q484[0][0][0] + coordinate_dofs[3] * FE3_C0_D01_Q484[0][0][1];
    double w0_d0_c5 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c5 += w[0][ic + 15] * FE3_C0_D01_Q484[0][0][ic];
    const double w0_d1_c2 = w[0][6] * FE3_C0_D01_Q484[0][0][0] + w[0][8] * FE3_C0_D01_Q484[0][0][1];
    double w0_d0_c2 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c2 += w[0][ic + 6] * FE3_C0_D01_Q484[0][0][ic];
    const double w0_d1_c1 = w[0][3] * FE3_C0_D01_Q484[0][0][0] + w[0][5] * FE3_C0_D01_Q484[0][0][1];
    double w0_d0_c1 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c1 += w[0][ic + 3] * FE3_C0_D01_Q484[0][0][ic];
    const double w0_d1_c4 = w[0][12] * FE3_C0_D01_Q484[0][0][0] + w[0][14] * FE3_C0_D01_Q484[0][0][1];
    double w0_d0_c4 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c4 += w[0][ic + 12] * FE3_C0_D01_Q484[0][0][ic];
    const double w0_d1_c3 = w[0][9] * FE3_C0_D01_Q484[0][0][0] + w[0][11] * FE3_C0_D01_Q484[0][0][1];
    double w0_d0_c3 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c3 += w[0][ic + 9] * FE3_C0_D01_Q484[0][0][ic];
    alignas(32) double sp[93];
    sp[0] = J_c0 * J_c3;
    sp[1] = J_c1 * J_c2;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = J_c0 / sp[2];
    sp[4] = w0_d1_c5 * sp[3];
    sp[5] = -1 * J_c1 / sp[2];
    sp[6] = w0_d0_c5 * sp[5];
    sp[7] = sp[4] + sp[6];
    sp[8] = w0_d1_c2 * sp[3];
    sp[9] = w0_d0_c2 * sp[5];
    sp[10] = sp[8] + sp[9];
    sp[11] = w0_d1_c1 * sp[3];
    sp[12] = w0_d0_c1 * sp[5];
    sp[13] = sp[11] + sp[12];
    sp[14] = w0_d1_c4 * sp[3];
    sp[15] = w0_d0_c4 * sp[5];
    sp[16] = sp[14] + sp[15];
    sp[17] = sp[16] * w[6][0];
    sp[18] = w[26][0] / w[6][0];
    sp[19] = w0_d1_c3 * sp[3];
    sp[20] = w0_d0_c3 * sp[5];
    sp[21] = sp[19] + sp[20];
    sp[22] = w[28][0] / w[6][0];
    sp[23] = sp[7] * w[5][0];
    sp[24] = sp[21] * w[5][0];
    sp[25] = sp[13] * w[19][0];
    sp[26] = sp[3] * w[6][0];
    sp[27] = sp[5] * w[6][0];
    sp[28] = sp[10] * w[5][0];
    sp[29] = J_c3 / sp[2];
    sp[30] = w0_d0_c5 * sp[29];
    sp[31] = -1 * J_c2 / sp[2];
    sp[32] = w0_d1_c5 * sp[31];
    sp[33] = sp[30] + sp[32];
    sp[34] = w0_d0_c2 * sp[29];
    sp[35] = w0_d1_c2 * sp[31];
    sp[36] = sp[34] + sp[35];
    sp[37] = w0_d0_c1 * sp[29];
    sp[38] = w0_d1_c1 * sp[31];
    sp[39] = sp[37] + sp[38];
    sp[40] = w0_d0_c4 * sp[29];
    sp[41] = w0_d1_c4 * sp[31];
    sp[42] = sp[40] + sp[41];
    sp[43] = sp[42] * w[6][0];
    sp[44] = w[27][0] / w[6][0];
    sp[45] = w0_d0_c3 * sp[29];
    sp[46] = w0_d1_c3 * sp[31];
    sp[47] = sp[45] + sp[46];
    sp[48] = w[29][0] / w[6][0];
    sp[49] = sp[33] * w[5][0];
    sp[50] = sp[47] * w[5][0];
    sp[51] = sp[39] * w[19][0];
    sp[52] = sp[31] * w[6][0];
    sp[53] = sp[29] * w[6][0];
    sp[54] = sp[36] * w[5][0];
    sp[55] = w[32][0] / w[2][0];
    sp[56] = w[34][0] / w[4][0];
    sp[57] = w[9][0] / w[7][0];
    sp[58] = w[13][0] / w[7][0];
    sp[59] = w[6][0] / w[31][0];
    sp[60] = sp[3] * sp[3];
    sp[61] = sp[3] * sp[5];
    sp[62] = sp[5] * sp[5];
    sp[63] = sp[31] * sp[31];
    sp[64] = sp[29] * sp[31];
    sp[65] = sp[29] * sp[29];
    sp[66] = sp[60] + sp[63];
    sp[67] = sp[61] + sp[64];
    sp[68] = sp[65] + sp[62];
    sp[69] = w[20][0] * w[21][0];
    sp[70] = sp[66] * sp[69];
    sp[71] = sp[67] * sp[69];
    sp[72] = sp[68] * sp[69];
    sp[73] = w[22][0] * w[23][0];
    sp[74] = sp[66] * sp[73];
    sp[75] = sp[67] * sp[73];
    sp[76] = sp[68] * sp[73];
    sp[77] = sp[66] * w[33][0];
    sp[78] = sp[67] * w[33][0];
    sp[79] = sp[68] * w[33][0];
    sp[80] = std::abs(sp[2]);
    sp[81] = sp[77] * sp[80];
    sp[82] = sp[78] * sp[80];
    sp[83] = sp[79] * sp[80];
    sp[84] = sp[74] * sp[80];
    sp[85] = sp[75] * sp[80];
    sp[86] = sp[76] * sp[80];
    sp[87] = sp[66] * sp[80];
    sp[88] = sp[67] * sp[80];
    sp[89] = sp[68] * sp[80];
    sp[90] = sp[70] * sp[80];
    sp[91] = sp[71] * sp[80];
    sp[92] = sp[72] * sp[80];
    alignas(32) double BF0[3][3] = {};
    alignas(32) double BF1[3][3] = {};
    alignas(32) double BF2[3][3] = {};
    alignas(32) double BF3[3][3] = {};
    alignas(32) double BF4[3][3] = {};
    alignas(32) double BF5[3][3] = {};
    alignas(32) double BF6[3][3] = {};
    alignas(32) double BF7[3][3] = {};
    alignas(32) double TP0[2] = {};
    alignas(32) double TP1[3] = {};
    alignas(32) double TP2[2] = {};
    alignas(32) double TP3[2] = {};
    alignas(32) double TP4[3] = {};
    alignas(32) double TP5[2] = {};
    alignas(32) double TP6[2] = {};
    alignas(32) double TP7[2] = {};
    alignas(32) double TP8[2] = {};
    alignas(32) double TP9[3] = {};
    alignas(32) double TP10[2] = {};
    alignas(32) double BF8[3][3] = {};
    alignas(32) double BF9[3][3] = {};
    alignas(32) double BF10[3][3] = {};
    alignas(32) double BF11[3][3] = {};
    alignas(32) double BF12[3][3] = {};
    alignas(32) double TP11[2] = {};
    alignas(32) double TP12[3] = {};
    alignas(32) double TP13[2] = {};
    alignas(32) double TP14[2] = {};
    alignas(32) double TP15[3] = {};
    alignas(32) double TP16[2] = {};
    alignas(32) double TP17[2] = {};
    alignas(32) double TP18[2] = {};
    alignas(32) double TP19[2] = {};
    alignas(32) double TP20[3] = {};
    alignas(32) double TP21[2] = {};
    alignas(32) double TP22[2] = {};
    alignas(32) double TP23[3] = {};
    alignas(32) double TP24[2] = {};
    alignas(32) double TP25[2] = {};
    alignas(32) double TP26[3] = {};
    alignas(32) double TP27[2] = {};
    alignas(32) double TP28[2] = {};
    alignas(32) double TP29[2] = {};
    alignas(32) double TP30[2] = {};
    alignas(32) double TP31[3] = {};
    alignas(32) double TP32[2] = {};
    alignas(32) double BF13[3][3] = {};
    alignas(32) double BF14[3][3] = {};
    alignas(32) double TP33[2] = {};
    alignas(32) double TP34[3] = {};
    alignas(32) double TP35[2] = {};
    alignas(32) double TP36[2] = {};
    alignas(32) double TP37[3] = {};
    alignas(32) double TP38[2] = {};
    alignas(32) double TP39[2] = {};
    alignas(32) double TP40[2] = {};
    alignas(32) double TP41[2] = {};
    alignas(32) double TP42[3] = {};
    alignas(32) double TP43[2] = {};
    alignas(32) double BF15[3][3] = {};
    alignas(32) double BF16[3][3] = {};
    alignas(32) double BF17[3][3] = {};
    alignas(32) double TP44[3] = {};
    alignas(32) double BF18[3][3] = {};
    alignas(32) double TP45[3] = {};
    alignas(32) double TP46[3] = {};
    alignas(32) double BF19[3][3] = {};
    alignas(32) double TP47[3] = {};
    alignas(32) double TP48[3] = {};
    alignas(32) double BF20[3][3] = {};
    alignas(32) double TP49[3] = {};
    alignas(32) double TP50[3] = {};
    alignas(32) double TP51[3] = {};
    alignas(32) double TP52[3] = {};
    alignas(32) double BF21[3][3] = {};
    alignas(32) double TP53[3] = {};
    for (int iq = 0; iq < 484; ++iq)
    {
        // Quadrature loop body setup (num_points=484)
        // Unstructured varying computations for num_points=484
        double w40 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w40 += w[40][ic] * FE3_C0_Q484[0][iq][ic];
        double w0_c0 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c0 += w[0][ic] * FE3_C0_Q484[0][iq][ic];
        double w0_c1 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c1 += w[0][ic + 3] * FE3_C0_Q484[0][iq][ic];
        double w1_c0 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w1_c0 += w[1][ic] * FE3_C0_Q484[0][iq][ic];
        double w1_c1 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w1_c1 += w[1][ic + 3] * FE3_C0_Q484[0][iq][ic];
        double w0_c2 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c2 += w[0][ic + 6] * FE3_C0_Q484[0][iq][ic];
        double w0_c5 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c5 += w[0][ic + 15] * FE3_C0_Q484[0][iq][ic];
        double w0_c3 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c3 += w[0][ic + 9] * FE3_C0_Q484[0][iq][ic];
        double w0_c4 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c4 += w[0][ic + 12] * FE3_C0_Q484[0][iq][ic];
        double w1_c2 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w1_c2 += w[1][ic + 6] * FE3_C0_Q484[0][iq][ic];
        double w1_c3 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w1_c3 += w[1][ic + 9] * FE3_C0_Q484[0][iq][ic];
        alignas(32) double sv484[705];
        sv484[0] = -1 * w[8][0] + -1 * w40;
        sv484[1] = sv484[0] * w[9][0];
        sv484[2] = sv484[1] / w[7][0];
        sv484[3] = 3.0 * std::pow(w0_c0, 2) * w[10][0];
        sv484[4] = sv484[3] + sv484[2];
        sv484[5] = 5.0 * std::pow(w0_c0, 4) * w[11][0];
        sv484[6] = sv484[4] + sv484[5];
        sv484[7] = w0_c0 * w[17][0];
        sv484[8] = 2.0 * w0_c1 * sv484[7];
        sv484[9] = std::pow(w0_c1, 2) * w[17][0];
        sv484[10] = sv484[6] + -1 * sv484[9];
        sv484[11] = -1 * sv484[8] + w[16][0];
        sv484[12] = 2.0 * w0_c0 * (1.5 * w[18][0]);
        sv484[13] = w0_c1 * sv484[12];
        sv484[14] = 1.5 * w[18][0] * std::pow(w0_c0, 2);
        sv484[15] = sv484[10] + sv484[13];
        sv484[16] = sv484[11] + sv484[14];
        sv484[17] = w0_c0 + -1 * w1_c0;
        sv484[18] = sv484[17] * sv484[15];
        sv484[19] = sv484[17] * sv484[16];
        sv484[20] = w0_c0 * sv484[2];
        sv484[21] = std::pow(w0_c0, 3) * w[10][0];
        sv484[22] = sv484[20] + sv484[21];
        sv484[23] = std::pow(w0_c0, 5) * w[11][0];
        sv484[24] = sv484[22] + sv484[23];
        sv484[25] = w0_c1 * w[16][0];
        sv484[26] = sv484[24] + sv484[25];
        sv484[27] = sv484[7] * std::pow(w0_c1, 2);
        sv484[28] = sv484[26] + -1 * sv484[27];
        sv484[29] = w0_c1 * sv484[14];
        sv484[30] = sv484[28] + sv484[29];
        sv484[31] = sv484[30] + sv484[18];
        sv484[32] = sv484[31] / w[2][0];
        sv484[33] = sv484[19] / w[2][0];
        sv484[34] = w0_c1 + -1 * w1_c1;
        sv484[35] = -1 * w[12][0] + -1 * w40;
        sv484[36] = sv484[35] * w[13][0];
        sv484[37] = sv484[36] / w[7][0];
        sv484[38] = 3.0 * std::pow(w0_c1, 2) * w[14][0];
        sv484[39] = sv484[38] + sv484[37];
        sv484[40] = 5.0 * std::pow(w0_c1, 4) * w[15][0];
        sv484[41] = sv484[39] + sv484[40];
        sv484[42] = 2.0 * w0_c0 * w[17][0];
        sv484[43] = w0_c1 * sv484[42];
        sv484[44] = std::pow(w0_c0, 2) * w[17][0];
        sv484[45] = -1 * sv484[43] + w[16][0];
        sv484[46] = sv484[41] + -1 * sv484[44];
        sv484[47] = 3.0 * std::pow(w0_c0, 2) * (0.5 * w[18][0]);
        sv484[48] = sv484[45] + sv484[47];
        sv484[49] = sv484[34] * sv484[48];
        sv484[50] = sv484[34] * sv484[46];
        sv484[51] = w0_c1 * sv484[37];
        sv484[52] = std::pow(w0_c1, 3) * w[14][0];
        sv484[53] = sv484[51] + sv484[52];
        sv484[54] = std::pow(w0_c1, 5) * w[15][0];
        sv484[55] = sv484[53] + sv484[54];
        sv484[56] = w0_c0 * w[16][0];
        sv484[57] = sv484[55] + sv484[56];
        sv484[58] = w0_c1 * sv484[44];
        sv484[59] = sv484[57] + -1 * sv484[58];
        sv484[60] = 0.5 * w[18][0] * std::pow(w0_c0, 3);
        sv484[61] = sv484[59] + sv484[60];
        sv484[62] = sv484[61] + sv484[50];
        sv484[63] = sv484[49] / w[2][0];
        sv484[64] = sv484[62] / w[2][0];
        sv484[65] = sv484[32] + sv484[63];
        sv484[66] = sv484[64] + sv484[33];
        sv484[67] = w0_c2 * w[5][0];
        sv484[68] = sp[7] * sv484[67];
        sv484[69] = w0_c5 * w[5][0];
        sv484[70] = sp[10] * sv484[69];
        sv484[71] = sv484[68] + sv484[70];
        sv484[72] = w0_c1 * w[19][0];
        sv484[73] = sp[13] * sv484[72];
        sv484[74] = sv484[71] + sv484[73];
        sv484[75] = sv484[74] + -1 * sp[17];
        sv484[76] = std::exp(-1 * w0_c2);
        sv484[77] = 1.32934038825 * std::pow(4 + std::pow(w0_c2, 2), -0.75) + sv484[76];
        sv484[78] = 1 / sv484[77] * w[24][0];
        sv484[79] = -1 * sv484[78] * sp[18];
        sv484[80] = sv484[75] * sv484[79];
        sv484[81] = w0_c3 * w[5][0];
        sv484[82] = sp[7] * sv484[81];
        sv484[83] = sp[21] * sv484[69];
        sv484[84] = sv484[82] + sv484[83];
        sv484[85] = sv484[84] + sv484[73];
        sv484[86] = sv484[85] + sp[17];
        sv484[87] = std::exp(-1 * w0_c3);
        sv484[88] = 1.32934038825 * std::pow(4 + std::pow(w0_c3, 2), -0.75) + sv484[87];
        sv484[89] = 1 / sv484[88] * w[25][0];
        sv484[90] = -1 * sv484[89] * sp[22];
        sv484[91] = sv484[86] * sv484[90];
        sv484[92] = -1 * sv484[80] + sv484[91];
        sv484[93] = sv484[81] * sp[3];
        sv484[94] = sv484[81] * sp[5];
        sv484[95] = sv484[69] * sp[3];
        sv484[96] = sv484[69] * sp[5];
        sv484[97] = sv484[72] * sp[3];
        sv484[98] = sv484[72] * sp[5];
        sv484[99] = sv484[90] * sp[25];
        sv484[100] = sv484[90] * sp[23];
        sv484[101] = sv484[93] * sv484[90];
        sv484[102] = sv484[94] * sv484[90];
        sv484[103] = sv484[90] * sp[24];
        sv484[104] = sv484[95] * sv484[90];
        sv484[105] = sv484[96] * sv484[90];
        sv484[106] = sv484[97] * sv484[90];
        sv484[107] = sv484[98] * sv484[90];
        sv484[108] = sv484[90] * sp[26];
        sv484[109] = sv484[90] * sp[27];
        sv484[110] = -0.75 * (2.0 * w0_c3) * std::pow(4 + std::pow(w0_c3, 2), -1.75);
        sv484[111] = 1.32934038825 * sv484[110] + -1.0 * sv484[87];
        sv484[112] = sv484[111] * (1 / sv484[88]);
        sv484[113] = -1 * sv484[112] / sv484[88];
        sv484[114] = sv484[113] * w[25][0];
        sv484[115] = -1 * sv484[114] * sp[22];
        sv484[116] = sv484[86] * sv484[115];
        sv484[117] = sv484[116] + sv484[100];
        sv484[118] = sv484[67] * sp[3];
        sv484[119] = sv484[67] * sp[5];
        sv484[120] = sv484[79] * sp[25];
        sv484[121] = sv484[118] * sv484[79];
        sv484[122] = sv484[119] * sv484[79];
        sv484[123] = sv484[79] * sp[28];
        sv484[124] = sv484[97] * sv484[79];
        sv484[125] = sv484[98] * sv484[79];
        sv484[126] = -1 * sp[26] * sv484[79];
        sv484[127] = -1 * sp[27] * sv484[79];
        sv484[128] = sv484[79] * sp[23];
        sv484[129] = sv484[95] * sv484[79];
        sv484[130] = sv484[96] * sv484[79];
        sv484[131] = -0.75 * (2.0 * w0_c2) * std::pow(4 + std::pow(w0_c2, 2), -1.75);
        sv484[132] = 1.32934038825 * sv484[131] + -1.0 * sv484[76];
        sv484[133] = sv484[132] * (1 / sv484[77]);
        sv484[134] = -1 * sv484[133] / sv484[77];
        sv484[135] = sv484[134] * w[24][0];
        sv484[136] = -1 * sv484[135] * sp[18];
        sv484[137] = sv484[75] * sv484[136];
        sv484[138] = sv484[137] + sv484[128];
        sv484[139] = -1 * sv484[120] + sv484[99];
        sv484[140] = -1 * sv484[121] + sv484[101];
        sv484[141] = -1 * sv484[122] + sv484[102];
        sv484[142] = -1 * sv484[123] + sv484[103];
        sv484[143] = -1 * sv484[124] + sv484[106];
        sv484[144] = -1 * sv484[125] + sv484[107];
        sv484[145] = -1 * sv484[126] + sv484[108];
        sv484[146] = -1 * sv484[127] + sv484[109];
        sv484[147] = sv484[92] * (2 * sv484[139]);
        sv484[148] = sv484[92] * (2 * sv484[117]);
        sv484[149] = sv484[92] * (2 * sv484[140]);
        sv484[150] = sv484[92] * (2 * sv484[141]);
        sv484[151] = sv484[92] * (2 * sv484[142]);
        sv484[152] = sv484[92] * (2 * sv484[104]);
        sv484[153] = sv484[92] * (2 * sv484[105]);
        sv484[154] = sv484[92] * (2 * sv484[143]);
        sv484[155] = sv484[92] * (2 * sv484[144]);
        sv484[156] = sv484[92] * (2 * sv484[145]);
        sv484[157] = sv484[92] * (2 * sv484[146]);
        sv484[158] = sv484[92] * (2 * (-1 * sv484[138]));
        sv484[159] = sv484[92] * (2 * (-1 * sv484[129]));
        sv484[160] = sv484[92] * (2 * (-1 * sv484[130]));
        sv484[161] = sv484[135] * w[26][0];
        sv484[162] = sv484[114] * w[28][0];
        sv484[163] = sv484[78] * w[26][0];
        sv484[164] = sv484[89] * w[28][0];
        sv484[165] = sv484[163] + sv484[164];
        sv484[166] = std::pow(sv484[92], 2) / sv484[165];
        sv484[167] = sv484[162] * sv484[166];
        sv484[168] = sv484[161] * sv484[166];
        sv484[169] = sv484[148] + -1 * sv484[167];
        sv484[170] = sv484[158] + -1 * sv484[168];
        sv484[171] = sv484[147] / sv484[165];
        sv484[172] = sv484[169] / sv484[165];
        sv484[173] = sv484[149] / sv484[165];
        sv484[174] = sv484[150] / sv484[165];
        sv484[175] = sv484[151] / sv484[165];
        sv484[176] = sv484[152] / sv484[165];
        sv484[177] = sv484[153] / sv484[165];
        sv484[178] = sv484[154] / sv484[165];
        sv484[179] = sv484[155] / sv484[165];
        sv484[180] = sv484[156] / sv484[165];
        sv484[181] = sv484[157] / sv484[165];
        sv484[182] = sv484[170] / sv484[165];
        sv484[183] = sv484[159] / sv484[165];
        sv484[184] = sv484[160] / sv484[165];
        sv484[185] = sp[33] * sv484[67];
        sv484[186] = sp[36] * sv484[69];
        sv484[187] = sv484[185] + sv484[186];
        sv484[188] = sp[39] * sv484[72];
        sv484[189] = sv484[187] + sv484[188];
        sv484[190] = sv484[189] + -1 * sp[43];
        sv484[191] = -1 * sv484[78] * sp[44];
        sv484[192] = sv484[190] * sv484[191];
        sv484[193] = sp[33] * sv484[81];
        sv484[194] = sp[47] * sv484[69];
        sv484[195] = sv484[193] + sv484[194];
        sv484[196] = sv484[195] + sv484[188];
        sv484[197] = sv484[196] + sp[43];
        sv484[198] = -1 * sv484[89] * sp[48];
        sv484[199] = sv484[197] * sv484[198];
        sv484[200] = -1 * sv484[192] + sv484[199];
        sv484[201] = sv484[81] * sp[31];
        sv484[202] = sv484[81] * sp[29];
        sv484[203] = sv484[69] * sp[31];
        sv484[204] = sv484[69] * sp[29];
        sv484[205] = sv484[72] * sp[31];
        sv484[206] = sv484[72] * sp[29];
        sv484[207] = sv484[198] * sp[51];
        sv484[208] = sv484[198] * sp[49];
        sv484[209] = sv484[201] * sv484[198];
        sv484[210] = sv484[202] * sv484[198];
        sv484[211] = sv484[198] * sp[50];
        sv484[212] = sv484[203] * sv484[198];
        sv484[213] = sv484[204] * sv484[198];
        sv484[214] = sv484[205] * sv484[198];
        sv484[215] = sv484[206] * sv484[198];
        sv484[216] = sv484[198] * sp[52];
        sv484[217] = sv484[198] * sp[53];
        sv484[218] = -1 * sv484[114] * sp[48];
        sv484[219] = sv484[197] * sv484[218];
        sv484[220] = sv484[219] + sv484[208];
        sv484[221] = sv484[67] * sp[31];
        sv484[222] = sv484[67] * sp[29];
        sv484[223] = sv484[191] * sp[51];
        sv484[224] = sv484[221] * sv484[191];
        sv484[225] = sv484[222] * sv484[191];
        sv484[226] = sv484[191] * sp[54];
        sv484[227] = sv484[205] * sv484[191];
        sv484[228] = sv484[206] * sv484[191];
        sv484[229] = -1 * sp[52] * sv484[191];
        sv484[230] = -1 * sp[53] * sv484[191];
        sv484[231] = sv484[191] * sp[49];
        sv484[232] = sv484[203] * sv484[191];
        sv484[233] = sv484[204] * sv484[191];
        sv484[234] = -1 * sv484[135] * sp[44];
        sv484[235] = sv484[190] * sv484[234];
        sv484[236] = sv484[235] + sv484[231];
        sv484[237] = -1 * sv484[223] + sv484[207];
        sv484[238] = -1 * sv484[224] + sv484[209];
        sv484[239] = -1 * sv484[225] + sv484[210];
        sv484[240] = -1 * sv484[226] + sv484[211];
        sv484[241] = -1 * sv484[227] + sv484[214];
        sv484[242] = -1 * sv484[228] + sv484[215];
        sv484[243] = -1 * sv484[229] + sv484[216];
        sv484[244] = -1 * sv484[230] + sv484[217];
        sv484[245] = sv484[200] * (2 * sv484[237]);
        sv484[246] = sv484[200] * (2 * sv484[220]);
        sv484[247] = sv484[200] * (2 * sv484[238]);
        sv484[248] = sv484[200] * (2 * sv484[239]);
        sv484[249] = sv484[200] * (2 * sv484[240]);
        sv484[250] = sv484[200] * (2 * sv484[212]);
        sv484[251] = sv484[200] * (2 * sv484[213]);
        sv484[252] = sv484[200] * (2 * sv484[241]);
        sv484[253] = sv484[200] * (2 * sv484[242]);
        sv484[254] = sv484[200] * (2 * sv484[243]);
        sv484[255] = sv484[200] * (2 * sv484[244]);
        sv484[256] = sv484[200] * (2 * (-1 * sv484[236]));
        sv484[257] = sv484[200] * (2 * (-1 * sv484[232]));
        sv484[258] = sv484[200] * (2 * (-1 * sv484[233]));
        sv484[259] = sv484[135] * w[27][0];
        sv484[260] = sv484[114] * w[29][0];
        sv484[261] = sv484[78] * w[27][0];
        sv484[262] = sv484[89] * w[29][0];
        sv484[263] = sv484[261] + sv484[262];
        sv484[264] = std::pow(sv484[200], 2) / sv484[263];
        sv484[265] = sv484[260] * sv484[264];
        sv484[266] = sv484[259] * sv484[264];
        sv484[267] = sv484[246] + -1 * sv484[265];
        sv484[268] = sv484[256] + -1 * sv484[266];
        sv484[269] = sv484[245] / sv484[263];
        sv484[270] = sv484[267] / sv484[263];
        sv484[271] = sv484[247] / sv484[263];
        sv484[272] = sv484[248] / sv484[263];
        sv484[273] = sv484[249] / sv484[263];
        sv484[274] = sv484[250] / sv484[263];
        sv484[275] = sv484[251] / sv484[263];
        sv484[276] = sv484[252] / sv484[263];
        sv484[277] = sv484[253] / sv484[263];
        sv484[278] = sv484[254] / sv484[263];
        sv484[279] = sv484[255] / sv484[263];
        sv484[280] = sv484[268] / sv484[263];
        sv484[281] = sv484[257] / sv484[263];
        sv484[282] = sv484[258] / sv484[263];
        sv484[283] = sv484[171] + sv484[269];
        sv484[284] = sv484[172] + sv484[270];
        sv484[285] = sv484[173] + sv484[271];
        sv484[286] = sv484[174] + sv484[272];
        sv484[287] = sv484[175] + sv484[273];
        sv484[288] = sv484[176] + sv484[274];
        sv484[289] = sv484[177] + sv484[275];
        sv484[290] = sv484[178] + sv484[276];
        sv484[291] = sv484[179] + sv484[277];
        sv484[292] = sv484[180] + sv484[278];
        sv484[293] = sv484[181] + sv484[279];
        sv484[294] = sv484[182] + sv484[280];
        sv484[295] = sv484[183] + sv484[281];
        sv484[296] = sv484[184] + sv484[282];
        sv484[297] = sv484[283] * w[6][0];
        sv484[298] = sv484[284] * w[6][0];
        sv484[299] = sv484[285] * w[6][0];
        sv484[300] = sv484[286] * w[6][0];
        sv484[301] = sv484[287] * w[6][0];
        sv484[302] = sv484[288] * w[6][0];
        sv484[303] = sv484[289] * w[6][0];
        sv484[304] = sv484[290] * w[6][0];
        sv484[305] = sv484[291] * w[6][0];
        sv484[306] = sv484[292] * w[6][0];
        sv484[307] = sv484[293] * w[6][0];
        sv484[308] = sv484[294] * w[6][0];
        sv484[309] = sv484[295] * w[6][0];
        sv484[310] = sv484[296] * w[6][0];
        sv484[311] = -1 * sv484[301] + sp[55];
        sv484[312] = sv484[66] + -1 * sv484[297];
        sv484[313] = sv484[311] + sp[56];
        sv484[314] = w0_c0 * sp[57];
        sv484[315] = w0_c5 + -1 * w[8][0];
        sv484[316] = sv484[315] + -1 * w40;
        sv484[317] = sv484[316] * w[9][0];
        sv484[318] = sv484[317] / w[7][0];
        sv484[319] = sv484[3] + sv484[318];
        sv484[320] = sv484[319] + sv484[5];
        sv484[321] = sv484[320] + -1 * sv484[9];
        sv484[322] = sv484[321] + sv484[13];
        sv484[323] = sv484[322] * (2.0 * w[20][0]);
        sv484[324] = sv484[16] * (2.0 * w[20][0]);
        sv484[325] = sv484[314] * (2.0 * w[20][0]);
        sv484[326] = sv484[323] + 1.0 / w[2][0];
        sv484[327] = w0_c1 * sp[58];
        sv484[328] = w0_c5 + -1 * w[12][0];
        sv484[329] = sv484[328] + -1 * w40;
        sv484[330] = sv484[329] * w[13][0];
        sv484[331] = sv484[330] / w[7][0];
        sv484[332] = sv484[38] + sv484[331];
        sv484[333] = sv484[332] + sv484[40];
        sv484[334] = sv484[333] + -1 * sv484[44];
        sv484[335] = sv484[78] + sv484[89];
        sv484[336] = std::pow(w0_c1, 2) * w[19][0];
        sv484[337] = -1 * w[35][0] + sv484[336] / 2;
        sv484[338] = -1 * sv484[337] / sv484[69];
        sv484[339] = std::exp(-1 * sv484[338]);
        sv484[340] = 1.32934038825 * std::pow(4 + std::pow(sv484[338], 2), -0.75) + sv484[339];
        sv484[341] = 1 / sv484[340] * w[24][0];
        sv484[342] = sv484[335] + -1 * (2 * sv484[341]);
        sv484[343] = sv484[342] * w[19][0];
        sv484[344] = sv484[338] * w[5][0];
        sv484[345] = 2.0 * w0_c1 * w[19][0];
        sv484[346] = -1 * (sv484[345] / 2) / sv484[69];
        sv484[347] = -1 * sv484[344] / sv484[69];
        sv484[348] = 2 * sv484[346] * sv484[338];
        sv484[349] = 2 * sv484[347] * sv484[338];
        sv484[350] = -0.75 * sv484[348] * std::pow(4 + std::pow(sv484[338], 2), -1.75);
        sv484[351] = -0.75 * sv484[349] * std::pow(4 + std::pow(sv484[338], 2), -1.75);
        sv484[352] = -1 * sv484[346] * sv484[339];
        sv484[353] = -1 * sv484[347] * sv484[339];
        sv484[354] = 1.32934038825 * sv484[350] + sv484[352];
        sv484[355] = 1.32934038825 * sv484[351] + sv484[353];
        sv484[356] = sv484[354] * (1 / sv484[340]);
        sv484[357] = sv484[355] * (1 / sv484[340]);
        sv484[358] = -1 * sv484[356] / sv484[340];
        sv484[359] = -1 * sv484[357] / sv484[340];
        sv484[360] = sv484[358] * w[24][0];
        sv484[361] = sv484[359] * w[24][0];
        sv484[362] = -1 * (2 * sv484[360]) * sv484[72];
        sv484[363] = sv484[72] * sv484[114];
        sv484[364] = -1 * (2 * sv484[361]) * sv484[72];
        sv484[365] = sv484[72] * sv484[135];
        sv484[366] = sv484[362] + sv484[343];
        sv484[367] = sv484[334] + sv484[366];
        sv484[368] = sv484[364] + sv484[327];
        sv484[369] = sv484[48] * (2.0 * w[22][0]);
        sv484[370] = sv484[367] * (2.0 * w[22][0]);
        sv484[371] = sv484[363] * (2.0 * w[22][0]);
        sv484[372] = sv484[368] * (2.0 * w[22][0]);
        sv484[373] = sv484[365] * (2.0 * w[22][0]);
        sv484[374] = sv484[370] + 1.0 / w[2][0];
        sv484[375] = sv484[78] * sv484[89];
        sv484[376] = w0_c4 * w[6][0];
        sv484[377] = -1 * sv484[376] + sv484[336] / 2;
        sv484[378] = sv484[377] + -1 * w[35][0];
        sv484[379] = -1 * sv484[378] / sv484[69];
        sv484[380] = std::exp(-1 * sv484[379]);
        sv484[381] = 1.32934038825 * std::pow(4 + std::pow(sv484[379], 2), -0.75) + sv484[380];
        sv484[382] = 1 / sv484[381] * w[24][0];
        sv484[383] = sv484[376] + sv484[336] / 2;
        sv484[384] = sv484[383] + w[35][0];
        sv484[385] = -1 * sv484[384] / sv484[69];
        sv484[386] = std::exp(-1 * sv484[385]);
        sv484[387] = 1.32934038825 * std::pow(4 + std::pow(sv484[385], 2), -0.75) + sv484[386];
        sv484[388] = 1 / sv484[387] * w[25][0];
        sv484[389] = sv484[382] * sv484[388];
        sv484[390] = -1 * sv484[375] + sv484[389];
        sv484[391] = 2.0 * w0_c1 * w[30][0];
        sv484[392] = sv484[390] * sv484[391];
        sv484[393] = sv484[379] * w[5][0];
        sv484[394] = -1 * sv484[393] / sv484[69];
        sv484[395] = -1 * (-1 * w[6][0]) / sv484[69];
        sv484[396] = 2 * sv484[346] * sv484[379];
        sv484[397] = 2 * sv484[394] * sv484[379];
        sv484[398] = 2 * sv484[395] * sv484[379];
        sv484[399] = -0.75 * sv484[396] * std::pow(4 + std::pow(sv484[379], 2), -1.75);
        sv484[400] = -0.75 * sv484[397] * std::pow(4 + std::pow(sv484[379], 2), -1.75);
        sv484[401] = -0.75 * sv484[398] * std::pow(4 + std::pow(sv484[379], 2), -1.75);
        sv484[402] = -1 * sv484[346] * sv484[380];
        sv484[403] = -1 * sv484[394] * sv484[380];
        sv484[404] = -1 * sv484[395] * sv484[380];
        sv484[405] = 1.32934038825 * sv484[399] + sv484[402];
        sv484[406] = 1.32934038825 * sv484[400] + sv484[403];
        sv484[407] = 1.32934038825 * sv484[401] + sv484[404];
        sv484[408] = sv484[405] * (1 / sv484[381]);
        sv484[409] = sv484[406] * (1 / sv484[381]);
        sv484[410] = sv484[407] * (1 / sv484[381]);
        sv484[411] = -1 * sv484[408] / sv484[381];
        sv484[412] = -1 * sv484[409] / sv484[381];
        sv484[413] = -1 * sv484[410] / sv484[381];
        sv484[414] = sv484[411] * w[24][0];
        sv484[415] = sv484[412] * w[24][0];
        sv484[416] = sv484[413] * w[24][0];
        sv484[417] = sv484[414] * sv484[388];
        sv484[418] = sv484[415] * sv484[388];
        sv484[419] = sv484[416] * sv484[388];
        sv484[420] = sv484[385] * w[5][0];
        sv484[421] = -1 * sv484[420] / sv484[69];
        sv484[422] = -1 * w[6][0] / sv484[69];
        sv484[423] = 2 * sv484[346] * sv484[385];
        sv484[424] = 2 * sv484[421] * sv484[385];
        sv484[425] = 2 * sv484[422] * sv484[385];
        sv484[426] = -0.75 * sv484[423] * std::pow(4 + std::pow(sv484[385], 2), -1.75);
        sv484[427] = -0.75 * sv484[424] * std::pow(4 + std::pow(sv484[385], 2), -1.75);
        sv484[428] = -0.75 * sv484[425] * std::pow(4 + std::pow(sv484[385], 2), -1.75);
        sv484[429] = -1 * sv484[346] * sv484[386];
        sv484[430] = -1 * sv484[421] * sv484[386];
        sv484[431] = -1 * sv484[422] * sv484[386];
        sv484[432] = 1.32934038825 * sv484[426] + sv484[429];
        sv484[433] = 1.32934038825 * sv484[427] + sv484[430];
        sv484[434] = 1.32934038825 * sv484[428] + sv484[431];
        sv484[435] = sv484[432] * (1 / sv484[387]);
        sv484[436] = sv484[433] * (1 / sv484[387]);
        sv484[437] = sv484[434] * (1 / sv484[387]);
        sv484[438] = -1 * sv484[435] / sv484[387];
        sv484[439] = -1 * sv484[436] / sv484[387];
        sv484[440] = -1 * sv484[437] / sv484[387];
        sv484[441] = sv484[438] * w[25][0];
        sv484[442] = sv484[439] * w[25][0];
        sv484[443] = sv484[440] * w[25][0];
        sv484[444] = sv484[382] * sv484[441];
        sv484[445] = sv484[382] * sv484[442];
        sv484[446] = sv484[382] * sv484[443];
        sv484[447] = sv484[417] + sv484[444];
        sv484[448] = sv484[418] + sv484[445];
        sv484[449] = sv484[419] + sv484[446];
        sv484[450] = sv484[135] * sv484[89];
        sv484[451] = sv484[78] * sv484[114];
        sv484[452] = std::pow(w0_c1, 2) * w[30][0];
        sv484[453] = sv484[447] * sv484[452];
        sv484[454] = -1 * sv484[451] * sv484[452];
        sv484[455] = sv484[448] * sv484[452];
        sv484[456] = -1 * sv484[450] * sv484[452];
        sv484[457] = sv484[449] * sv484[452];
        sv484[458] = sv484[392] + sv484[453];
        sv484[459] = w0_c2 + -1 * w1_c2;
        sv484[460] = w0_c2 * (1.994010582375 * std::pow(4 + std::pow(w0_c2, 2), -1.75));
        sv484[461] = sv484[460] + sv484[76];
        sv484[462] = 2 * sv484[134] * (1 / sv484[77]);
        sv484[463] = sv484[461] * sv484[462];
        sv484[464] = -1.75 * (2.0 * w0_c2) * std::pow(4 + std::pow(w0_c2, 2), -2.75);
        sv484[465] = w0_c2 * (1.994010582375 * sv484[464]);
        sv484[466] = sv484[465] + 1.994010582375 * std::pow(4 + std::pow(w0_c2, 2), -1.75);
        sv484[467] = sv484[466] + -1.0 * sv484[76];
        sv484[468] = sv484[467] * std::pow(1 / sv484[77], 2);
        sv484[469] = sv484[463] + sv484[468];
        sv484[470] = sv484[469] * w[24][0];
        sv484[471] = sv484[459] * sv484[470];
        sv484[472] = sv484[461] * std::pow(1 / sv484[77], 2);
        sv484[473] = sv484[472] * w[24][0];
        sv484[474] = sv484[471] + sv484[473];
        sv484[475] = sv484[474] / w[2][0];
        sv484[476] = -1 * sv484[456] + sv484[475];
        sv484[477] = w0_c3 + -1 * w1_c3;
        sv484[478] = w0_c3 * (1.994010582375 * std::pow(4 + std::pow(w0_c3, 2), -1.75));
        sv484[479] = sv484[478] + sv484[87];
        sv484[480] = 2 * sv484[113] * (1 / sv484[88]);
        sv484[481] = sv484[479] * sv484[480];
        sv484[482] = -1.75 * (2.0 * w0_c3) * std::pow(4 + std::pow(w0_c3, 2), -2.75);
        sv484[483] = w0_c3 * (1.994010582375 * sv484[482]);
        sv484[484] = sv484[483] + 1.994010582375 * std::pow(4 + std::pow(w0_c3, 2), -1.75);
        sv484[485] = sv484[484] + -1.0 * sv484[87];
        sv484[486] = sv484[485] * std::pow(1 / sv484[88], 2);
        sv484[487] = sv484[481] + sv484[486];
        sv484[488] = sv484[487] * w[25][0];
        sv484[489] = sv484[477] * sv484[488];
        sv484[490] = sv484[479] * std::pow(1 / sv484[88], 2);
        sv484[491] = sv484[490] * w[25][0];
        sv484[492] = sv484[489] + sv484[491];
        sv484[493] = sv484[492] / w[2][0];
        sv484[494] = -1 * sv484[454] + sv484[493];
        sv484[495] = sv484[114] * sp[59];
        sv484[496] = -1 * sv484[135] * sp[59];
        sv484[497] = sv484[120] * sp[3];
        sv484[498] = sv484[120] * sp[5];
        sv484[499] = sv484[121] * sp[3];
        sv484[500] = sv484[121] * sp[5];
        sv484[501] = sv484[122] * sp[3];
        sv484[502] = sv484[122] * sp[5];
        sv484[503] = sv484[123] * sp[3];
        sv484[504] = sv484[123] * sp[5];
        sv484[505] = sv484[124] * sp[3];
        sv484[506] = sv484[124] * sp[5];
        sv484[507] = sv484[125] * sp[3];
        sv484[508] = sv484[125] * sp[5];
        sv484[509] = sv484[126] * sp[3];
        sv484[510] = sv484[126] * sp[5];
        sv484[511] = sv484[127] * sp[3];
        sv484[512] = sv484[127] * sp[5];
        sv484[513] = sv484[138] * sp[3];
        sv484[514] = sv484[138] * sp[5];
        sv484[515] = sv484[129] * sp[3];
        sv484[516] = sv484[129] * sp[5];
        sv484[517] = sv484[130] * sp[3];
        sv484[518] = sv484[130] * sp[5];
        sv484[519] = sv484[223] * sp[31];
        sv484[520] = sv484[223] * sp[29];
        sv484[521] = sv484[224] * sp[31];
        sv484[522] = sv484[224] * sp[29];
        sv484[523] = sv484[225] * sp[31];
        sv484[524] = sv484[225] * sp[29];
        sv484[525] = sv484[226] * sp[31];
        sv484[526] = sv484[226] * sp[29];
        sv484[527] = sv484[227] * sp[31];
        sv484[528] = sv484[227] * sp[29];
        sv484[529] = sv484[228] * sp[31];
        sv484[530] = sv484[228] * sp[29];
        sv484[531] = sv484[229] * sp[31];
        sv484[532] = sv484[229] * sp[29];
        sv484[533] = sv484[230] * sp[31];
        sv484[534] = sv484[230] * sp[29];
        sv484[535] = sv484[236] * sp[31];
        sv484[536] = sv484[236] * sp[29];
        sv484[537] = sv484[232] * sp[31];
        sv484[538] = sv484[232] * sp[29];
        sv484[539] = sv484[233] * sp[31];
        sv484[540] = sv484[233] * sp[29];
        sv484[541] = sv484[497] + sv484[519];
        sv484[542] = sv484[520] + sv484[498];
        sv484[543] = sv484[499] + sv484[521];
        sv484[544] = sv484[522] + sv484[500];
        sv484[545] = sv484[501] + sv484[523];
        sv484[546] = sv484[524] + sv484[502];
        sv484[547] = sv484[503] + sv484[525];
        sv484[548] = sv484[526] + sv484[504];
        sv484[549] = sv484[505] + sv484[527];
        sv484[550] = sv484[528] + sv484[506];
        sv484[551] = sv484[507] + sv484[529];
        sv484[552] = sv484[530] + sv484[508];
        sv484[553] = sv484[509] + sv484[531];
        sv484[554] = sv484[532] + sv484[510];
        sv484[555] = sv484[511] + sv484[533];
        sv484[556] = sv484[534] + sv484[512];
        sv484[557] = sv484[513] + sv484[535];
        sv484[558] = sv484[536] + sv484[514];
        sv484[559] = sv484[515] + sv484[537];
        sv484[560] = sv484[538] + sv484[516];
        sv484[561] = sv484[517] + sv484[539];
        sv484[562] = sv484[540] + sv484[518];
        sv484[563] = sv484[99] * sp[3];
        sv484[564] = sv484[99] * sp[5];
        sv484[565] = sv484[117] * sp[3];
        sv484[566] = sv484[117] * sp[5];
        sv484[567] = sv484[101] * sp[3];
        sv484[568] = sv484[101] * sp[5];
        sv484[569] = sv484[102] * sp[3];
        sv484[570] = sv484[102] * sp[5];
        sv484[571] = sv484[103] * sp[3];
        sv484[572] = sv484[103] * sp[5];
        sv484[573] = sv484[104] * sp[3];
        sv484[574] = sv484[104] * sp[5];
        sv484[575] = sv484[105] * sp[3];
        sv484[576] = sv484[105] * sp[5];
        sv484[577] = sv484[106] * sp[3];
        sv484[578] = sv484[106] * sp[5];
        sv484[579] = sv484[107] * sp[3];
        sv484[580] = sv484[107] * sp[5];
        sv484[581] = sv484[108] * sp[3];
        sv484[582] = sv484[108] * sp[5];
        sv484[583] = sv484[109] * sp[3];
        sv484[584] = sv484[109] * sp[5];
        sv484[585] = sv484[207] * sp[31];
        sv484[586] = sv484[207] * sp[29];
        sv484[587] = sv484[220] * sp[31];
        sv484[588] = sv484[220] * sp[29];
        sv484[589] = sv484[209] * sp[31];
        sv484[590] = sv484[209] * sp[29];
        sv484[591] = sv484[210] * sp[31];
        sv484[592] = sv484[210] * sp[29];
        sv484[593] = sv484[211] * sp[31];
        sv484[594] = sv484[211] * sp[29];
        sv484[595] = sv484[212] * sp[31];
        sv484[596] = sv484[212] * sp[29];
        sv484[597] = sv484[213] * sp[31];
        sv484[598] = sv484[213] * sp[29];
        sv484[599] = sv484[214] * sp[31];
        sv484[600] = sv484[214] * sp[29];
        sv484[601] = sv484[215] * sp[31];
        sv484[602] = sv484[215] * sp[29];
        sv484[603] = sv484[216] * sp[31];
        sv484[604] = sv484[216] * sp[29];
        sv484[605] = sv484[217] * sp[31];
        sv484[606] = sv484[217] * sp[29];
        sv484[607] = sv484[563] + sv484[585];
        sv484[608] = sv484[586] + sv484[564];
        sv484[609] = sv484[565] + sv484[587];
        sv484[610] = sv484[588] + sv484[566];
        sv484[611] = sv484[567] + sv484[589];
        sv484[612] = sv484[590] + sv484[568];
        sv484[613] = sv484[569] + sv484[591];
        sv484[614] = sv484[592] + sv484[570];
        sv484[615] = sv484[571] + sv484[593];
        sv484[616] = sv484[594] + sv484[572];
        sv484[617] = sv484[573] + sv484[595];
        sv484[618] = sv484[596] + sv484[574];
        sv484[619] = sv484[575] + sv484[597];
        sv484[620] = sv484[598] + sv484[576];
        sv484[621] = sv484[577] + sv484[599];
        sv484[622] = sv484[600] + sv484[578];
        sv484[623] = sv484[579] + sv484[601];
        sv484[624] = sv484[602] + sv484[580];
        sv484[625] = sv484[581] + sv484[603];
        sv484[626] = sv484[604] + sv484[582];
        sv484[627] = sv484[583] + sv484[605];
        sv484[628] = sv484[606] + sv484[584];
        sv484[629] = sv484[65] * sp[80];
        sv484[630] = sv484[312] * sp[80];
        sv484[631] = -1 * sv484[298] * sp[80];
        sv484[632] = -1 * sv484[299] * sp[80];
        sv484[633] = -1 * sv484[300] * sp[80];
        sv484[634] = sv484[313] * sp[80];
        sv484[635] = -1 * sv484[302] * sp[80];
        sv484[636] = -1 * sv484[303] * sp[80];
        sv484[637] = -1 * sv484[304] * sp[80];
        sv484[638] = -1 * sv484[305] * sp[80];
        sv484[639] = -1 * sv484[306] * sp[80];
        sv484[640] = -1 * sv484[307] * sp[80];
        sv484[641] = -1 * sv484[308] * sp[80];
        sv484[642] = -1 * sv484[309] * sp[80];
        sv484[643] = -1 * sv484[310] * sp[80];
        sv484[644] = sv484[326] * sp[80];
        sv484[645] = sv484[369] * sp[80];
        sv484[646] = sv484[324] * sp[80];
        sv484[647] = sv484[374] * sp[80];
        sv484[648] = -1 * sv484[458] * sp[80];
        sv484[649] = -1 * sv484[541] * sp[80];
        sv484[650] = -1 * sv484[542] * sp[80];
        sv484[651] = -1 * sv484[607] * sp[80];
        sv484[652] = -1 * sv484[608] * sp[80];
        sv484[653] = sv484[371] * sp[80];
        sv484[654] = -1 * sv484[454] * sp[80];
        sv484[655] = sv484[494] * sp[80];
        sv484[656] = -1 * sv484[495] * sp[80];
        sv484[657] = -1 * sv484[609] * sp[80];
        sv484[658] = -1 * sv484[610] * sp[80];
        sv484[659] = -1 * sv484[543] * sp[80];
        sv484[660] = -1 * sv484[544] * sp[80];
        sv484[661] = -1 * sv484[611] * sp[80];
        sv484[662] = -1 * sv484[612] * sp[80];
        sv484[663] = -1 * sv484[545] * sp[80];
        sv484[664] = -1 * sv484[546] * sp[80];
        sv484[665] = -1 * sv484[613] * sp[80];
        sv484[666] = -1 * sv484[614] * sp[80];
        sv484[667] = sv484[325] * sp[80];
        sv484[668] = sv484[372] * sp[80];
        sv484[669] = -1 * sv484[455] * sp[80];
        sv484[670] = -1 * sv484[547] * sp[80];
        sv484[671] = -1 * sv484[548] * sp[80];
        sv484[672] = -1 * sv484[615] * sp[80];
        sv484[673] = -1 * sv484[616] * sp[80];
        sv484[674] = -1 * sv484[617] * sp[80];
        sv484[675] = -1 * sv484[618] * sp[80];
        sv484[676] = -1 * sv484[619] * sp[80];
        sv484[677] = -1 * sv484[620] * sp[80];
        sv484[678] = -1 * sv484[549] * sp[80];
        sv484[679] = -1 * sv484[550] * sp[80];
        sv484[680] = -1 * sv484[621] * sp[80];
        sv484[681] = -1 * sv484[622] * sp[80];
        sv484[682] = -1 * sv484[551] * sp[80];
        sv484[683] = -1 * sv484[552] * sp[80];
        sv484[684] = -1 * sv484[623] * sp[80];
        sv484[685] = -1 * sv484[624] * sp[80];
        sv484[686] = -1 * sv484[553] * sp[80];
        sv484[687] = -1 * sv484[554] * sp[80];
        sv484[688] = -1 * sv484[625] * sp[80];
        sv484[689] = -1 * sv484[626] * sp[80];
        sv484[690] = -1 * sv484[555] * sp[80];
        sv484[691] = -1 * sv484[556] * sp[80];
        sv484[692] = -1 * sv484[627] * sp[80];
        sv484[693] = -1 * sv484[628] * sp[80];
        sv484[694] = sv484[373] * sp[80];
        sv484[695] = sv484[476] * sp[80];
        sv484[696] = -1 * sv484[456] * sp[80];
        sv484[697] = -1 * sv484[496] * sp[80];
        sv484[698] = -1 * sv484[557] * sp[80];
        sv484[699] = -1 * sv484[558] * sp[80];
        sv484[700] = -1 * sv484[559] * sp[80];
        sv484[701] = -1 * sv484[560] * sp[80];
        sv484[702] = -1 * sv484[561] * sp[80];
        sv484[703] = -1 * sv484[562] * sp[80];
        sv484[704] = -1 * sv484[457] * sp[80];
        const double fw0 = sv484[644] * weights484[iq];
        alignas(32) double TF0[3];
        for (int i = 0; i < 3; ++i)
            TF0[i] = fw0 * FE3_C0_Q484[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF0[i][j] += TF0[i] * FE3_C0_Q484[0][iq][j];
        const double fw1 = sv484[646] * weights484[iq];
        alignas(32) double TF1[3];
        for (int i = 0; i < 3; ++i)
            TF1[i] = fw1 * FE3_C0_Q484[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF1[i][j] += TF1[i] * FE3_C0_Q484[0][iq][j];
        const double fw2 = sv484[667] * weights484[iq];
        alignas(32) double TF2[3];
        for (int i = 0; i < 3; ++i)
            TF2[i] = fw2 * FE3_C0_Q484[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF2[i][j] += TF2[i] * FE3_C0_Q484[0][iq][j];
        const double fw3 = sv484[645] * weights484[iq];
        alignas(32) double TF3[3];
        for (int i = 0; i < 3; ++i)
            TF3[i] = fw3 * FE3_C0_Q484[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF3[i][j] += TF3[i] * FE3_C0_Q484[0][iq][j];
        const double fw4 = sv484[647] * weights484[iq];
        alignas(32) double TF4[3];
        for (int i = 0; i < 3; ++i)
            TF4[i] = fw4 * FE3_C0_Q484[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF4[i][j] += TF4[i] * FE3_C0_Q484[0][iq][j];
        const double fw5 = sv484[694] * weights484[iq];
        alignas(32) double TF5[3];
        for (int i = 0; i < 3; ++i)
            TF5[i] = fw5 * FE3_C0_Q484[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF5[i][j] += TF5[i] * FE3_C0_Q484[0][iq][j];
        const double fw6 = sv484[653] * weights484[iq];
        alignas(32) double TF6[3];
        for (int i = 0; i < 3; ++i)
            TF6[i] = fw6 * FE3_C0_Q484[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF6[i][j] += TF6[i] * FE3_C0_Q484[0][iq][j];
        const double fw7 = sv484[668] * weights484[iq];
        alignas(32) double TF7[3];
        for (int i = 0; i < 3; ++i)
            TF7[i] = fw7 * FE3_C0_Q484[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF7[i][j] += TF7[i] * FE3_C0_Q484[0][iq][j];
        const double fw8 = sv484[683] * weights484[iq];
        for (int j = 0; j < 2; ++j)
            TP0[j] += fw8 * FE3_C0_D01_Q484[0][0][j];
        const double fw9 = sv484[650] * weights484[iq];
        for (int j = 0; j < 3; ++j)
            TP1[j] += fw9 * FE3_C0_Q484[0][iq][j];
        const double fw10 = sv484[679] * weights484[iq];
        for (int j = 0; j < 2; ++j)
            TP2[j] += fw10 * FE3_C0_D01_Q484[0][0][j];
        const double fw11 = sv484[703] * weights484[iq];
        for (int j = 0; j < 2; ++j)
            TP3[j] += fw11 * FE3_C0_D01_Q484[0][0][j];
        const double fw12 = sv484[699] * weights484[iq];
        for (int j = 0; j < 3; ++j)
            TP4[j] += fw12 * FE3_C0_Q484[0][iq][j];
        const double fw13 = sv484[701] * weights484[iq];
        for (int j = 0; j < 2; ++j)
            TP5[j] += fw13 * FE3_C0_D01_Q484[0][0][j];
        const double fw14 = sv484[691] * weights484[iq];
        for (int j = 0; j < 2; ++j)
            TP6[j] += fw14 * FE3_C0_D01_Q484[0][0][j];
        const double fw15 = sv484[687] * weights484[iq];
        for (int j = 0; j < 2; ++j)
            TP7[j] += fw15 * FE3_C0_D01_Q484[0][0][j];
        const double fw16 = sv484[664] * weights484[iq];
        for (int j = 0; j < 2; ++j)
            TP8[j] += fw16 * FE3_C0_D01_Q484[0][0][j];
        const double fw17 = sv484[671] * weights484[iq];
        for (int j = 0; j < 3; ++j)
            TP9[j] += fw17 * FE3_C0_Q484[0][iq][j];
        const double fw18 = sv484[660] * weights484[iq];
        for (int j = 0; j < 2; ++j)
            TP10[j] += fw18 * FE3_C0_D01_Q484[0][0][j];
        const double fw19 = sv484[648] * weights484[iq];
        alignas(32) double TF8[3];
        for (int i = 0; i < 3; ++i)
            TF8[i] = fw19 * FE3_C0_Q484[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF8[i][j] += TF8[i] * FE3_C0_Q484[0][iq][j];
        const double fw20 = sv484[695] * weights484[iq];
        alignas(32) double TF9[3];
        for (int i = 0; i < 3; ++i)
            TF9[i] = fw20 * FE3_C0_Q484[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF9[i][j] += TF9[i] * FE3_C0_Q484[0][iq][j];
        const double fw21 = sv484[654] * weights484[iq];
        alignas(32) double TF10[3];
        for (int i = 0; i < 3; ++i)
            TF10[i] = fw21 * FE3_C0_Q484[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF10[i][j] += TF10[i] * FE3_C0_Q484[0][iq][j];
        const double fw22 = sv484[704] * weights484[iq];
        alignas(32) double TF11[3];
        for (int i = 0; i < 3; ++i)
            TF11[i] = fw22 * FE3_C0_Q484[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF11[i][j] += TF11[i] * FE3_C0_Q484[0][iq][j];
        const double fw23 = sv484[669] * weights484[iq];
        alignas(32) double TF12[3];
        for (int i = 0; i < 3; ++i)
            TF12[i] = fw23 * FE3_C0_Q484[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF12[i][j] += TF12[i] * FE3_C0_Q484[0][iq][j];
        const double fw24 = sv484[682] * weights484[iq];
        for (int j = 0; j < 2; ++j)
            TP11[j] += fw24 * FE3_C0_D01_Q484[0][0][j];
        const double fw25 = sv484[649] * weights484[iq];
        for (int j = 0; j < 3; ++j)
            TP12[j] += fw25 * FE3_C0_Q484[0][iq][j];
        const double fw26 = sv484[678] * weights484[iq];
        for (int j = 0; j < 2; ++j)
            TP13[j] += fw26 * FE3_C0_D01_Q484[0][0][j];
        const double fw27 = sv484[702] * weights484[iq];
        for (int j = 0; j < 2; ++j)
            TP14[j] += fw27 * FE3_C0_D01_Q484[0][0][j];
        const double fw28 = sv484[698] * weights484[iq];
        for (int j = 0; j < 3; ++j)
            TP15[j] += fw28 * FE3_C0_Q484[0][iq][j];
        const double fw29 = sv484[700] * weights484[iq];
        for (int j = 0; j < 2; ++j)
            TP16[j] += fw29 * FE3_C0_D01_Q484[0][0][j];
        const double fw30 = sv484[690] * weights484[iq];
        for (int j = 0; j < 2; ++j)
            TP17[j] += fw30 * FE3_C0_D01_Q484[0][0][j];
        const double fw31 = sv484[686] * weights484[iq];
        for (int j = 0; j < 2; ++j)
            TP18[j] += fw31 * FE3_C0_D01_Q484[0][0][j];
        const double fw32 = sv484[663] * weights484[iq];
        for (int j = 0; j < 2; ++j)
            TP19[j] += fw32 * FE3_C0_D01_Q484[0][0][j];
        const double fw33 = sv484[670] * weights484[iq];
        for (int j = 0; j < 3; ++j)
            TP20[j] += fw33 * FE3_C0_Q484[0][iq][j];
        const double fw34 = sv484[659] * weights484[iq];
        for (int j = 0; j < 2; ++j)
            TP21[j] += fw34 * FE3_C0_D01_Q484[0][0][j];
        const double fw35 = sv484[685] * weights484[iq];
        for (int j = 0; j < 2; ++j)
            TP22[j] += fw35 * FE3_C0_D01_Q484[0][0][j];
        const double fw36 = sv484[652] * weights484[iq];
        for (int j = 0; j < 3; ++j)
            TP23[j] += fw36 * FE3_C0_Q484[0][iq][j];
        const double fw37 = sv484[681] * weights484[iq];
        for (int j = 0; j < 2; ++j)
            TP24[j] += fw37 * FE3_C0_D01_Q484[0][0][j];
        const double fw38 = sv484[677] * weights484[iq];
        for (int j = 0; j < 2; ++j)
            TP25[j] += fw38 * FE3_C0_D01_Q484[0][0][j];
        const double fw39 = sv484[658] * weights484[iq];
        for (int j = 0; j < 3; ++j)
            TP26[j] += fw39 * FE3_C0_Q484[0][iq][j];
        const double fw40 = sv484[675] * weights484[iq];
        for (int j = 0; j < 2; ++j)
            TP27[j] += fw40 * FE3_C0_D01_Q484[0][0][j];
        const double fw41 = sv484[693] * weights484[iq];
        for (int j = 0; j < 2; ++j)
            TP28[j] += fw41 * FE3_C0_D01_Q484[0][0][j];
        const double fw42 = sv484[689] * weights484[iq];
        for (int j = 0; j < 2; ++j)
            TP29[j] += fw42 * FE3_C0_D01_Q484[0][0][j];
        const double fw43 = sv484[666] * weights484[iq];
        for (int j = 0; j < 2; ++j)
            TP30[j] += fw43 * FE3_C0_D01_Q484[0][0][j];
        const double fw44 = sv484[673] * weights484[iq];
        for (int j = 0; j < 3; ++j)
            TP31[j] += fw44 * FE3_C0_Q484[0][iq][j];
        const double fw45 = sv484[662] * weights484[iq];
        for (int j = 0; j < 2; ++j)
            TP32[j] += fw45 * FE3_C0_D01_Q484[0][0][j];
        const double fw46 = sv484[696] * weights484[iq];
        alignas(32) double TF13[3];
        for (int i = 0; i < 3; ++i)
            TF13[i] = fw46 * FE3_C0_Q484[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF13[i][j] += TF13[i] * FE3_C0_Q484[0][iq][j];
        const double fw47 = sv484[655] * weights484[iq];
        alignas(32) double TF14[3];
        for (int i = 0; i < 3; ++i)
            TF14[i] = fw47 * FE3_C0_Q484[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF14[i][j] += TF14[i] * FE3_C0_Q484[0][iq][j];
        const double fw48 = sv484[684] * weights484[iq];
        for (int j = 0; j < 2; ++j)
            TP33[j] += fw48 * FE3_C0_D01_Q484[0][0][j];
        const double fw49 = sv484[651] * weights484[iq];
        for (int j = 0; j < 3; ++j)
            TP34[j] += fw49 * FE3_C0_Q484[0][iq][j];
        const double fw50 = sv484[680] * weights484[iq];
        for (int j = 0; j < 2; ++j)
            TP35[j] += fw50 * FE3_C0_D01_Q484[0][0][j];
        const double fw51 = sv484[676] * weights484[iq];
        for (int j = 0; j < 2; ++j)
            TP36[j] += fw51 * FE3_C0_D01_Q484[0][0][j];
        const double fw52 = sv484[657] * weights484[iq];
        for (int j = 0; j < 3; ++j)
            TP37[j] += fw52 * FE3_C0_Q484[0][iq][j];
        const double fw53 = sv484[674] * weights484[iq];
        for (int j = 0; j < 2; ++j)
            TP38[j] += fw53 * FE3_C0_D01_Q484[0][0][j];
        const double fw54 = sv484[692] * weights484[iq];
        for (int j = 0; j < 2; ++j)
            TP39[j] += fw54 * FE3_C0_D01_Q484[0][0][j];
        const double fw55 = sv484[688] * weights484[iq];
        for (int j = 0; j < 2; ++j)
            TP40[j] += fw55 * FE3_C0_D01_Q484[0][0][j];
        const double fw56 = sv484[665] * weights484[iq];
        for (int j = 0; j < 2; ++j)
            TP41[j] += fw56 * FE3_C0_D01_Q484[0][0][j];
        const double fw57 = sv484[672] * weights484[iq];
        for (int j = 0; j < 3; ++j)
            TP42[j] += fw57 * FE3_C0_Q484[0][iq][j];
        const double fw58 = sv484[661] * weights484[iq];
        for (int j = 0; j < 2; ++j)
            TP43[j] += fw58 * FE3_C0_D01_Q484[0][0][j];
        const double fw59 = sv484[697] * weights484[iq];
        alignas(32) double TF15[3];
        for (int i = 0; i < 3; ++i)
            TF15[i] = fw59 * FE3_C0_Q484[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF15[i][j] += TF15[i] * FE3_C0_Q484[0][iq][j];
        const double fw60 = sv484[656] * weights484[iq];
        alignas(32) double TF16[3];
        for (int i = 0; i < 3; ++i)
            TF16[i] = fw60 * FE3_C0_Q484[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF16[i][j] += TF16[i] * FE3_C0_Q484[0][iq][j];
        const double fw61 = sv484[629] * weights484[iq];
        alignas(32) double TF17[3];
        for (int i = 0; i < 3; ++i)
            TF17[i] = fw61 * FE3_C0_Q484[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF17[i][j] += TF17[i] * FE3_C0_Q484[0][iq][j];
        const double fw62 = sv484[638] * weights484[iq];
        for (int i = 0; i < 3; ++i)
            TP44[i] += fw62 * FE3_C0_Q484[0][iq][i];
        const double fw63 = sv484[630] * weights484[iq];
        alignas(32) double TF18[3];
        for (int i = 0; i < 3; ++i)
            TF18[i] = fw63 * FE3_C0_Q484[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF18[i][j] += TF18[i] * FE3_C0_Q484[0][iq][j];
        const double fw64 = sv484[637] * weights484[iq];
        for (int i = 0; i < 3; ++i)
            TP45[i] += fw64 * FE3_C0_Q484[0][iq][i];
        const double fw65 = sv484[643] * weights484[iq];
        for (int i = 0; i < 3; ++i)
            TP46[i] += fw65 * FE3_C0_Q484[0][iq][i];
        const double fw66 = sv484[641] * weights484[iq];
        alignas(32) double TF19[3];
        for (int i = 0; i < 3; ++i)
            TF19[i] = fw66 * FE3_C0_Q484[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF19[i][j] += TF19[i] * FE3_C0_Q484[0][iq][j];
        const double fw67 = sv484[642] * weights484[iq];
        for (int i = 0; i < 3; ++i)
            TP47[i] += fw67 * FE3_C0_Q484[0][iq][i];
        const double fw68 = sv484[636] * weights484[iq];
        for (int i = 0; i < 3; ++i)
            TP48[i] += fw68 * FE3_C0_Q484[0][iq][i];
        const double fw69 = sv484[631] * weights484[iq];
        alignas(32) double TF20[3];
        for (int i = 0; i < 3; ++i)
            TF20[i] = fw69 * FE3_C0_Q484[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF20[i][j] += TF20[i] * FE3_C0_Q484[0][iq][j];
        const double fw70 = sv484[635] * weights484[iq];
        for (int i = 0; i < 3; ++i)
            TP49[i] += fw70 * FE3_C0_Q484[0][iq][i];
        const double fw71 = sv484[640] * weights484[iq];
        for (int i = 0; i < 3; ++i)
            TP50[i] += fw71 * FE3_C0_Q484[0][iq][i];
        const double fw72 = sv484[639] * weights484[iq];
        for (int i = 0; i < 3; ++i)
            TP51[i] += fw72 * FE3_C0_Q484[0][iq][i];
        const double fw73 = sv484[633] * weights484[iq];
        for (int i = 0; i < 3; ++i)
            TP52[i] += fw73 * FE3_C0_Q484[0][iq][i];
        const double fw74 = sv484[634] * weights484[iq];
        alignas(32) double TF21[3];
        for (int i = 0; i < 3; ++i)
            TF21[i] = fw74 * FE3_C0_Q484[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF21[i][j] += TF21[i] * FE3_C0_Q484[0][iq][j];
        const double fw75 = sv484[632] * weights484[iq];
        for (int i = 0; i < 3; ++i)
            TP53[i] += fw75 * FE3_C0_Q484[0][iq][i];
    }
    std::fill_n(A, 361, 0.0);
    {
        int k = 0;
        int l = 0;
        for (int i = 0; i < 2; ++i)
        {
            for (int j = 0; j < 2; ++j)
            {
                A[19 * i + j] += sp[92] * PI0[0][k][l];
                ++l;
            }
            l = 0;
            ++k;
        }
        k = 0;
    }
    {
        int k = 0;
        int l = 0;
        for (int i = 0; i < 2; ++i)
        {
            {
                int j = 0;
                A[19 * i + j] += sp[91] * PI0[0][k][l];
                ++l;
            }
            {
                int j = 2;
                A[19 * i + j] += sp[91] * PI0[0][k][l];
                ++l;
            }
            l = 0;
            ++k;
        }
        k = 0;
    }
    {
        int k = 0;
        int l = 0;
        {
            int i = 0;
            for (int j = 0; j < 2; ++j)
            {
                A[19 * i + j] += sp[91] * PI0[0][k][l];
                ++l;
            }
            l = 0;
            ++k;
        }
        {
            int i = 2;
            for (int j = 0; j < 2; ++j)
            {
                A[19 * i + j] += sp[91] * PI0[0][k][l];
                ++l;
            }
            l = 0;
            ++k;
        }
        k = 0;
    }
    {
        int k = 0;
        int l = 0;
        {
            int i = 0;
            {
                int j = 0;
                A[19 * i + j] += sp[90] * PI0[0][k][l];
                ++l;
            }
            {
                int j = 2;
                A[19 * i + j] += sp[90] * PI0[0][k][l];
                ++l;
            }
            l = 0;
            ++k;
        }
        {
            int i = 2;
            {
                int j = 0;
                A[19 * i + j] += sp[90] * PI0[0][k][l];
                ++l;
            }
            {
                int j = 2;
                A[19 * i + j] += sp[90] * PI0[0][k][l];
                ++l;
            }
            l = 0;
            ++k;
        }
        k = 0;
    }
    {
        int k = 0;
        int l = 0;
        for (int i = 3; i < 5; ++i)
        {
            for (int j = 3; j < 5; ++j)
            {
                A[19 * i + j] += sp[86] * PI0[0][k][l];
                ++l;
            }
            l = 0;
            ++k;
        }
        k = 0;
    }
    {
        int k = 0;
        int l = 0;
        for (int i = 3; i < 5; ++i)
        {
            {
                int j = 3;
                A[19 * i + j] += sp[85] * PI0[0][k][l];
                ++l;
            }
            {
                int j = 5;
                A[19 * i + j] += sp[85] * PI0[0][k][l];
                ++l;
            }
            l = 0;
            ++k;
        }
        k = 0;
    }
    {
        int k = 0;
        int l = 0;
        {
            int i = 3;
            for (int j = 3; j < 5; ++j)
            {
                A[19 * i + j] += sp[85] * PI0[0][k][l];
                ++l;
            }
            l = 0;
            ++k;
        }
        {
            int i = 5;
            for (int j = 3; j < 5; ++j)
            {
                A[19 * i + j] += sp[85] * PI0[0][k][l];
                ++l;
            }
            l = 0;
            ++k;
        }
        k = 0;
    }
    {
        int k = 0;
        int l = 0;
        {
            int i = 3;
            {
                int j = 3;
                A[19 * i + j] += sp[84] * PI0[0][k][l];
                ++l;
            }
            {
                int j = 5;
                A[19 * i + j] += sp[84] * PI0[0][k][l];
                ++l;
            }
            l = 0;
            ++k;
        }
        {
            int i = 5;
            {
                int j = 3;
                A[19 * i + j] += sp[84] * PI0[0][k][l];
                ++l;
            }
            {
                int j = 5;
                A[19 * i + j] += sp[84] * PI0[0][k][l];
                ++l;
            }
            l = 0;
            ++k;
        }
        k = 0;
    }
    {
        int k = 0;
        int l = 0;
        for (int i = 12; i < 14; ++i)
        {
            for (int j = 12; j < 14; ++j)
            {
                A[19 * i + j] += sp[89] * PI0[0][k][l];
                ++l;
            }
            l = 0;
            ++k;
        }
        k = 0;
    }
    {
        int k = 0;
        int l = 0;
        for (int i = 12; i < 14; ++i)
        {
            {
                int j = 12;
                A[19 * i + j] += sp[88] * PI0[0][k][l];
                ++l;
            }
            {
                int j = 14;
                A[19 * i + j] += sp[88] * PI0[0][k][l];
                ++l;
            }
            l = 0;
            ++k;
        }
        k = 0;
    }
    {
        int k = 0;
        int l = 0;
        {
            int i = 12;
            for (int j = 12; j < 14; ++j)
            {
                A[19 * i + j] += sp[88] * PI0[0][k][l];
                ++l;
            }
            l = 0;
            ++k;
        }
        {
            int i = 14;
            for (int j = 12; j < 14; ++j)
            {
                A[19 * i + j] += sp[88] * PI0[0][k][l];
                ++l;
            }
            l = 0;
            ++k;
        }
        k = 0;
    }
    {
        int k = 0;
        int l = 0;
        {
            int i = 12;
            {
                int j = 12;
                A[19 * i + j] += sp[87] * PI0[0][k][l];
                ++l;
            }
            {
                int j = 14;
                A[19 * i + j] += sp[87] * PI0[0][k][l];
                ++l;
            }
            l = 0;
            ++k;
        }
        {
            int i = 14;
            {
                int j = 12;
                A[19 * i + j] += sp[87] * PI0[0][k][l];
                ++l;
            }
            {
                int j = 14;
                A[19 * i + j] += sp[87] * PI0[0][k][l];
                ++l;
            }
            l = 0;
            ++k;
        }
        k = 0;
    }
    {
        int k = 0;
        int l = 0;
        for (int i = 15; i < 17; ++i)
        {
            for (int j = 15; j < 17; ++j)
            {
                A[19 * i + j] += sp[83] * PI0[0][k][l];
                ++l;
            }
            l = 0;
            ++k;
        }
        k = 0;
    }
    {
        int k = 0;
        int l = 0;
        for (int i = 15; i < 17; ++i)
        {
            {
                int j = 15;
                A[19 * i + j] += sp[82] * PI0[0][k][l];
                ++l;
            }
            {
                int j = 17;
                A[19 * i + j] += sp[82] * PI0[0][k][l];
                ++l;
            }
            l = 0;
            ++k;
        }
        k = 0;
    }
    {
        int k = 0;
        int l = 0;
        {
            int i = 15;
            for (int j = 15; j < 17; ++j)
            {
                A[19 * i + j] += sp[82] * PI0[0][k][l];
                ++l;
            }
            l = 0;
            ++k;
        }
        {
            int i = 17;
            for (int j = 15; j < 17; ++j)
            {
                A[19 * i + j] += sp[82] * PI0[0][k][l];
                ++l;
            }
            l = 0;
            ++k;
        }
        k = 0;
    }
    {
        int k = 0;
        int l = 0;
        {
            int i = 15;
            {
                int j = 15;
                A[19 * i + j] += sp[81] * PI0[0][k][l];
                ++l;
            }
            {
                int j = 17;
                A[19 * i + j] += sp[81] * PI0[0][k][l];
                ++l;
            }
            l = 0;
            ++k;
        }
        {
            int i = 17;
            {
                int j = 15;
                A[19 * i + j] += sp[81] * PI0[0][k][l];
                ++l;
            }
            {
                int j = 17;
                A[19 * i + j] += sp[81] * PI0[0][k][l];
                ++l;
            }
            l = 0;
            ++k;
        }
        k = 0;
    }
    static const int DM0[2] = { 3, 5 };
    static const int DM1[2] = { 6, 8 };
    static const int DM2[2] = { 12, 14 };
    static const int DM3[2] = { 15, 17 };
    static const int DM4[2] = { 9, 11 };
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * i + j] += BF0[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * i + (j + 3)] += BF1[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * i + (j + 15)] += BF2[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 3) + j] += BF3[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 3) + (j + 3)] += BF4[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 3) + (j + 6)] += BF5[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 3) + (j + 9)] += BF6[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 3) + (j + 15)] += BF7[i][j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 6) + (j + 3)] += FE3_C0_D01_Q484[0][0][i] * TP0[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 6) + (j + 3)] += FE3_C0_D01_Q484[0][0][i] * TP1[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 6) + DM0[j]] += FE3_C0_D01_Q484[0][0][i] * TP2[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 6) + (j + 6)] += FE3_C0_D01_Q484[0][0][i] * TP3[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 6) + (j + 6)] += FE3_C0_D01_Q484[0][0][i] * TP4[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 6) + DM1[j]] += FE3_C0_D01_Q484[0][0][i] * TP5[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 6) + (j + 12)] += FE3_C0_D01_Q484[0][0][i] * TP6[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 6) + DM2[j]] += FE3_C0_D01_Q484[0][0][i] * TP7[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 6) + (j + 15)] += FE3_C0_D01_Q484[0][0][i] * TP8[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 6) + (j + 15)] += FE3_C0_D01_Q484[0][0][i] * TP9[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 6) + DM3[j]] += FE3_C0_D01_Q484[0][0][i] * TP10[j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 6) + (j + 3)] += BF8[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 6) + (j + 6)] += BF9[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 6) + (j + 9)] += BF10[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 6) + (j + 12)] += BF11[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 6) + (j + 15)] += BF12[i][j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * DM1[i] + (j + 3)] += FE3_C0_D01_Q484[0][0][i] * TP11[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * DM1[i] + (j + 3)] += FE3_C0_D01_Q484[0][0][i] * TP12[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * DM1[i] + DM0[j]] += FE3_C0_D01_Q484[0][0][i] * TP13[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * DM1[i] + (j + 6)] += FE3_C0_D01_Q484[0][0][i] * TP14[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * DM1[i] + (j + 6)] += FE3_C0_D01_Q484[0][0][i] * TP15[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * DM1[i] + DM1[j]] += FE3_C0_D01_Q484[0][0][i] * TP16[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * DM1[i] + (j + 12)] += FE3_C0_D01_Q484[0][0][i] * TP17[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * DM1[i] + DM2[j]] += FE3_C0_D01_Q484[0][0][i] * TP18[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * DM1[i] + (j + 15)] += FE3_C0_D01_Q484[0][0][i] * TP19[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * DM1[i] + (j + 15)] += FE3_C0_D01_Q484[0][0][i] * TP20[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * DM1[i] + DM3[j]] += FE3_C0_D01_Q484[0][0][i] * TP21[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 9) + (j + 3)] += FE3_C0_D01_Q484[0][0][i] * TP22[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 9) + (j + 3)] += FE3_C0_D01_Q484[0][0][i] * TP23[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 9) + DM0[j]] += FE3_C0_D01_Q484[0][0][i] * TP24[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 9) + (j + 9)] += FE3_C0_D01_Q484[0][0][i] * TP25[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 9) + (j + 9)] += FE3_C0_D01_Q484[0][0][i] * TP26[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 9) + DM4[j]] += FE3_C0_D01_Q484[0][0][i] * TP27[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 9) + (j + 12)] += FE3_C0_D01_Q484[0][0][i] * TP28[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 9) + DM2[j]] += FE3_C0_D01_Q484[0][0][i] * TP29[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 9) + (j + 15)] += FE3_C0_D01_Q484[0][0][i] * TP30[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 9) + (j + 15)] += FE3_C0_D01_Q484[0][0][i] * TP31[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 9) + DM3[j]] += FE3_C0_D01_Q484[0][0][i] * TP32[j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 9) + (j + 3)] += BF8[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 9) + (j + 6)] += BF13[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 9) + (j + 9)] += BF14[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 9) + (j + 12)] += BF11[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 9) + (j + 15)] += BF12[i][j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * DM4[i] + (j + 3)] += FE3_C0_D01_Q484[0][0][i] * TP33[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * DM4[i] + (j + 3)] += FE3_C0_D01_Q484[0][0][i] * TP34[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * DM4[i] + DM0[j]] += FE3_C0_D01_Q484[0][0][i] * TP35[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * DM4[i] + (j + 9)] += FE3_C0_D01_Q484[0][0][i] * TP36[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * DM4[i] + (j + 9)] += FE3_C0_D01_Q484[0][0][i] * TP37[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * DM4[i] + DM4[j]] += FE3_C0_D01_Q484[0][0][i] * TP38[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * DM4[i] + (j + 12)] += FE3_C0_D01_Q484[0][0][i] * TP39[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * DM4[i] + DM2[j]] += FE3_C0_D01_Q484[0][0][i] * TP40[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * DM4[i] + (j + 15)] += FE3_C0_D01_Q484[0][0][i] * TP41[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * DM4[i] + (j + 15)] += FE3_C0_D01_Q484[0][0][i] * TP42[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * DM4[i] + DM3[j]] += FE3_C0_D01_Q484[0][0][i] * TP43[j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 12) + (j + 6)] += BF15[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 12) + (j + 9)] += BF16[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 15) + j] += BF17[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 15) + (j + 3)] += FE3_C0_D01_Q484[0][0][j] * TP44[i];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 15) + (j + 3)] += BF18[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 15) + DM0[j]] += FE3_C0_D01_Q484[0][0][j] * TP45[i];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 15) + (j + 6)] += FE3_C0_D01_Q484[0][0][j] * TP46[i];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 15) + (j + 6)] += BF19[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 15) + DM1[j]] += FE3_C0_D01_Q484[0][0][j] * TP47[i];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 15) + (j + 9)] += FE3_C0_D01_Q484[0][0][j] * TP48[i];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 15) + (j + 9)] += BF20[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 15) + DM4[j]] += FE3_C0_D01_Q484[0][0][j] * TP49[i];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 15) + (j + 12)] += FE3_C0_D01_Q484[0][0][j] * TP50[i];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 15) + DM2[j]] += FE3_C0_D01_Q484[0][0][j] * TP51[i];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 15) + (j + 15)] += FE3_C0_D01_Q484[0][0][j] * TP52[i];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 15) + (j + 15)] += BF21[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 15) + DM3[j]] += FE3_C0_D01_Q484[0][0][j] * TP53[i];
}


vo2_2tdevice_exterior_facet_integral_1_0::vo2_2tdevice_exterior_facet_integral_1_0() : ufc::exterior_facet_integral()
{

}

vo2_2tdevice_exterior_facet_integral_1_0::~vo2_2tdevice_exterior_facet_integral_1_0()
{

}

const std::vector<bool> & vo2_2tdevice_exterior_facet_integral_1_0::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, false, true, true, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, true, true, true, false, true, false, false, false, false, false, false, false, true, true, true, true, false});
return enabled;
}

void vo2_2tdevice_exterior_facet_integral_1_0::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    std::size_t facet,
                                    int cell_orientation) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 16
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 16
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           16
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Quadrature rules
    alignas(32) static const double weights9[9] = { 0.04063719418078723, 0.09032408034742867, 0.1303053482014677, 0.1561735385200014, 0.1651196775006299, 0.1561735385200014, 0.1303053482014677, 0.09032408034742867, 0.04063719418078723 };
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE3_C0_D01_F_Q9[1][1][2] = { { { -1.0, 1.0 } } };
    alignas(32) static const double FE3_C0_F_Q9[3][9][3] =
        { { { 0.0, 0.9840801197538129, 0.01591988024618697 },
            { 0.0, 0.9180155536633179, 0.08198444633668212 },
            { 0.0, 0.8066857163502953, 0.1933142836497048 },
            { 0.0, 0.6621267117019045, 0.3378732882980955 },
            { 0.0, 0.5, 0.5 },
            { 0.0, 0.3378732882980958, 0.6621267117019043 },
            { 0.0, 0.1933142836497049, 0.8066857163502952 },
            { 0.0, 0.08198444633668217, 0.9180155536633179 },
            { 0.0, 0.01591988024618701, 0.9840801197538128 } },
          { { 0.9840801197538129, 0.0, 0.01591988024618697 },
            { 0.9180155536633179, 0.0, 0.08198444633668212 },
            { 0.8066857163502953, 0.0, 0.1933142836497048 },
            { 0.6621267117019045, 0.0, 0.3378732882980955 },
            { 0.5, 0.0, 0.5 },
            { 0.3378732882980958, 0.0, 0.6621267117019043 },
            { 0.1933142836497049, 0.0, 0.8066857163502952 },
            { 0.08198444633668217, 0.0, 0.9180155536633179 },
            { 0.01591988024618703, 0.0, 0.9840801197538129 } },
          { { 0.984080119753813, 0.01591988024618688, 0.0 },
            { 0.918015553663318, 0.08198444633668207, 0.0 },
            { 0.8066857163502952, 0.1933142836497048, 0.0 },
            { 0.6621267117019045, 0.3378732882980956, 0.0 },
            { 0.5, 0.5, 0.0 },
            { 0.3378732882980957, 0.6621267117019043, 0.0 },
            { 0.1933142836497048, 0.8066857163502952, 0.0 },
            { 0.08198444633668207, 0.918015553663318, 0.0 },
            { 0.01591988024618696, 0.984080119753813, 0.0 } } };
    alignas(32) static const double PI0[3][3][3] =
        { { { 0.0, 0.0, 0.0 },
            { 0.0, 0.3333333333333334, 0.1666666666666667 },
            { 0.0, 0.1666666666666667, 0.3333333333333333 } },
          { { 0.3333333333333334, 0.0, 0.1666666666666667 },
            { 0.0, 0.0, 0.0 },
            { 0.1666666666666667, 0.0, 0.3333333333333333 } },
          { { 0.3333333333333334, 0.1666666666666667, 0.0 },
            { 0.1666666666666667, 0.3333333333333333, 0.0 },
            { 0.0, 0.0, 0.0 } } };
    alignas(32) static const double PI1[3][3][1] =
        { { { 0.0 },
            { 0.5 },
            { 0.5 } },
          { { 0.5 },
            { 0.0 },
            { 0.5 } },
          { { 0.5 },
            { 0.5 },
            { 0.0 } } };
    alignas(32) static const double PI2[1][1][1] = { { { 1.0 } } };
    // Unstructured piecewise computations
    const double w0_d1_c5 = w[0][15] * FE3_C0_D01_F_Q9[0][0][0] + w[0][17] * FE3_C0_D01_F_Q9[0][0][1];
    const double J_c0 = coordinate_dofs[0] * FE3_C0_D01_F_Q9[0][0][0] + coordinate_dofs[2] * FE3_C0_D01_F_Q9[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE3_C0_D01_F_Q9[0][0][0] + coordinate_dofs[5] * FE3_C0_D01_F_Q9[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE3_C0_D01_F_Q9[0][0][0] + coordinate_dofs[4] * FE3_C0_D01_F_Q9[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE3_C0_D01_F_Q9[0][0][0] + coordinate_dofs[3] * FE3_C0_D01_F_Q9[0][0][1];
    double w0_d0_c5 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c5 += w[0][ic + 15] * FE3_C0_D01_F_Q9[0][0][ic];
    const double w0_d1_c3 = w[0][9] * FE3_C0_D01_F_Q9[0][0][0] + w[0][11] * FE3_C0_D01_F_Q9[0][0][1];
    double w0_d0_c3 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c3 += w[0][ic + 9] * FE3_C0_D01_F_Q9[0][0][ic];
    const double w0_d1_c1 = w[0][3] * FE3_C0_D01_F_Q9[0][0][0] + w[0][5] * FE3_C0_D01_F_Q9[0][0][1];
    double w0_d0_c1 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c1 += w[0][ic + 3] * FE3_C0_D01_F_Q9[0][0][ic];
    const double w0_d1_c4 = w[0][12] * FE3_C0_D01_F_Q9[0][0][0] + w[0][14] * FE3_C0_D01_F_Q9[0][0][1];
    double w0_d0_c4 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c4 += w[0][ic + 12] * FE3_C0_D01_F_Q9[0][0][ic];
    const double w0_d1_c2 = w[0][6] * FE3_C0_D01_F_Q9[0][0][0] + w[0][8] * FE3_C0_D01_F_Q9[0][0][1];
    double w0_d0_c2 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c2 += w[0][ic + 6] * FE3_C0_D01_F_Q9[0][0][ic];
    alignas(32) double sp[52];
    sp[0] = J_c0 * J_c3;
    sp[1] = J_c1 * J_c2;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = J_c0 / sp[2];
    sp[4] = w0_d1_c5 * sp[3];
    sp[5] = -1 * J_c1 / sp[2];
    sp[6] = w0_d0_c5 * sp[5];
    sp[7] = sp[4] + sp[6];
    sp[8] = sp[7] * w[5][0];
    sp[9] = w0_d1_c3 * sp[3];
    sp[10] = w0_d0_c3 * sp[5];
    sp[11] = sp[9] + sp[10];
    sp[12] = sp[11] * w[5][0];
    sp[13] = w0_d1_c1 * sp[3];
    sp[14] = w0_d0_c1 * sp[5];
    sp[15] = sp[13] + sp[14];
    sp[16] = sp[15] * w[19][0];
    sp[17] = sp[3] * w[6][0];
    sp[18] = sp[5] * w[6][0];
    sp[19] = w[28][0] / w[6][0];
    sp[20] = w0_d1_c4 * sp[3];
    sp[21] = w0_d0_c4 * sp[5];
    sp[22] = sp[20] + sp[21];
    sp[23] = sp[22] * w[6][0];
    sp[24] = w0_d1_c2 * sp[3];
    sp[25] = w0_d0_c2 * sp[5];
    sp[26] = sp[24] + sp[25];
    sp[27] = sp[26] * w[5][0];
    sp[28] = w[26][0] / w[6][0];
    sp[29] = w[20][0] * w[21][0];
    sp[30] = sp[29] / w[38][0];
    sp[31] = w[22][0] * w[23][0];
    sp[32] = sp[31] / w[38][0];
    sp[33] = w[4][0] * w[36][0];
    sp[34] = w[36][0] * w[37][0];
    sp[35] = sp[34] / w[2][0];
    sp[36] = sp[33] * (-1.0 / w[39][0]);
    sp[37] = (1.0 + sp[35]) * (-1.0 / w[39][0]);
    sp[38] = J_c0 * triangle_reference_facet_jacobian[facet][0][0];
    sp[39] = J_c1 * triangle_reference_facet_jacobian[facet][1][0];
    sp[40] = sp[38] + sp[39];
    sp[41] = sp[40] * sp[40];
    sp[42] = triangle_reference_facet_jacobian[facet][0][0] * J_c2;
    sp[43] = triangle_reference_facet_jacobian[facet][1][0] * J_c3;
    sp[44] = sp[42] + sp[43];
    sp[45] = sp[44] * sp[44];
    sp[46] = sp[41] + sp[45];
    sp[47] = std::sqrt(sp[46]);
    sp[48] = sp[36] * sp[47];
    sp[49] = -1 * (-1.0 * sp[32]) * sp[47];
    sp[50] = -1 * (-1.0 * sp[30]) * sp[47];
    sp[51] = sp[37] * sp[47];
    alignas(32) double BF0[3][3] = {};
    alignas(32) double BF1[3][3] = {};
    alignas(32) double BF2[3][3] = {};
    alignas(32) double BF3[3][3] = {};
    alignas(32) double TP0[2] = {};
    alignas(32) double TP1[3] = {};
    alignas(32) double TP2[2] = {};
    alignas(32) double TP3[2] = {};
    alignas(32) double TP4[3] = {};
    alignas(32) double TP5[2] = {};
    alignas(32) double TP6[2] = {};
    alignas(32) double TP7[3] = {};
    alignas(32) double TP8[2] = {};
    alignas(32) double TP9[2] = {};
    alignas(32) double TP10[2] = {};
    alignas(32) double TP11[2] = {};
    alignas(32) double TP12[3] = {};
    alignas(32) double TP13[2] = {};
    for (int iq = 0; iq < 9; ++iq)
    {
        // Quadrature loop body setup (num_points=9)
        // Unstructured varying computations for num_points=9
        double w0_c3 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c3 += w[0][ic + 9] * FE3_C0_F_Q9[facet][iq][ic];
        double w0_c5 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c5 += w[0][ic + 15] * FE3_C0_F_Q9[facet][iq][ic];
        double w0_c1 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c1 += w[0][ic + 3] * FE3_C0_F_Q9[facet][iq][ic];
        double w0_c2 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c2 += w[0][ic + 6] * FE3_C0_F_Q9[facet][iq][ic];
        alignas(32) double sv9[128];
        sv9[0] = w0_c3 * w[5][0];
        sv9[1] = sv9[0] * sp[3];
        sv9[2] = sv9[0] * sp[5];
        sv9[3] = w0_c5 * w[5][0];
        sv9[4] = sv9[3] * sp[3];
        sv9[5] = sv9[3] * sp[5];
        sv9[6] = w0_c1 * w[19][0];
        sv9[7] = sv9[6] * sp[3];
        sv9[8] = sv9[6] * sp[5];
        sv9[9] = std::exp(-1 * w0_c3);
        sv9[10] = 1.32934038825 * std::pow(4 + std::pow(w0_c3, 2), -0.75) + sv9[9];
        sv9[11] = 1 / sv9[10] * w[25][0];
        sv9[12] = -1 * sv9[11] * sp[19];
        sv9[13] = sv9[12] * sp[8];
        sv9[14] = sv9[1] * sv9[12];
        sv9[15] = sv9[2] * sv9[12];
        sv9[16] = sv9[12] * sp[12];
        sv9[17] = sv9[4] * sv9[12];
        sv9[18] = sv9[5] * sv9[12];
        sv9[19] = sv9[12] * sp[16];
        sv9[20] = sv9[7] * sv9[12];
        sv9[21] = sv9[8] * sv9[12];
        sv9[22] = sv9[12] * sp[17];
        sv9[23] = sv9[12] * sp[18];
        sv9[24] = sp[7] * sv9[0];
        sv9[25] = sp[11] * sv9[3];
        sv9[26] = sv9[24] + sv9[25];
        sv9[27] = sp[15] * sv9[6];
        sv9[28] = sv9[26] + sv9[27];
        sv9[29] = sv9[28] + sp[23];
        sv9[30] = -0.75 * (2.0 * w0_c3) * std::pow(4 + std::pow(w0_c3, 2), -1.75);
        sv9[31] = 1.32934038825 * sv9[30] + -1.0 * sv9[9];
        sv9[32] = sv9[31] * (1 / sv9[10]);
        sv9[33] = -1 * sv9[32] / sv9[10];
        sv9[34] = sv9[33] * w[25][0];
        sv9[35] = -1 * sv9[34] * sp[19];
        sv9[36] = sv9[29] * sv9[35];
        sv9[37] = sv9[36] + sv9[13];
        sv9[38] = w0_c2 * w[5][0];
        sv9[39] = sv9[38] * sp[3];
        sv9[40] = sv9[38] * sp[5];
        sv9[41] = std::exp(-1 * w0_c2);
        sv9[42] = 1.32934038825 * std::pow(4 + std::pow(w0_c2, 2), -0.75) + sv9[41];
        sv9[43] = 1 / sv9[42] * w[24][0];
        sv9[44] = -1 * sv9[43] * sp[28];
        sv9[45] = sv9[39] * sv9[44];
        sv9[46] = sv9[40] * sv9[44];
        sv9[47] = sv9[44] * sp[27];
        sv9[48] = sv9[44] * sp[16];
        sv9[49] = sv9[7] * sv9[44];
        sv9[50] = sv9[8] * sv9[44];
        sv9[51] = -1 * sp[17] * sv9[44];
        sv9[52] = -1 * sp[18] * sv9[44];
        sv9[53] = sv9[44] * sp[8];
        sv9[54] = sv9[4] * sv9[44];
        sv9[55] = sv9[5] * sv9[44];
        sv9[56] = sp[7] * sv9[38];
        sv9[57] = sp[26] * sv9[3];
        sv9[58] = sv9[56] + sv9[57];
        sv9[59] = sv9[58] + sv9[27];
        sv9[60] = sv9[59] + -1 * sp[23];
        sv9[61] = -0.75 * (2.0 * w0_c2) * std::pow(4 + std::pow(w0_c2, 2), -1.75);
        sv9[62] = 1.32934038825 * sv9[61] + -1.0 * sv9[41];
        sv9[63] = sv9[62] * (1 / sv9[42]);
        sv9[64] = -1 * sv9[63] / sv9[42];
        sv9[65] = sv9[64] * w[24][0];
        sv9[66] = -1 * sv9[65] * sp[28];
        sv9[67] = sv9[60] * sv9[66];
        sv9[68] = sv9[67] + sv9[53];
        sv9[69] = -1 * sv9[45] + sv9[14];
        sv9[70] = -1 * sv9[46] + sv9[15];
        sv9[71] = -1 * sv9[47] + sv9[16];
        sv9[72] = -1 * sv9[48] + sv9[19];
        sv9[73] = -1 * sv9[49] + sv9[20];
        sv9[74] = -1 * sv9[50] + sv9[21];
        sv9[75] = -1 * sv9[51] + sv9[22];
        sv9[76] = -1 * sv9[52] + sv9[23];
        sv9[77] = sv9[37] * w[6][0];
        sv9[78] = sv9[69] * w[6][0];
        sv9[79] = sv9[70] * w[6][0];
        sv9[80] = sv9[71] * w[6][0];
        sv9[81] = sv9[17] * w[6][0];
        sv9[82] = sv9[18] * w[6][0];
        sv9[83] = sv9[72] * w[6][0];
        sv9[84] = sv9[73] * w[6][0];
        sv9[85] = sv9[74] * w[6][0];
        sv9[86] = sv9[75] * w[6][0];
        sv9[87] = sv9[76] * w[6][0];
        sv9[88] = -1 * sv9[68] * w[6][0];
        sv9[89] = -1 * sv9[54] * w[6][0];
        sv9[90] = -1 * sv9[55] * w[6][0];
        sv9[91] = sv9[77] * w[3][0];
        sv9[92] = sv9[78] * w[3][0];
        sv9[93] = sv9[79] * w[3][0];
        sv9[94] = sv9[80] * w[3][0];
        sv9[95] = sv9[81] * w[3][0];
        sv9[96] = sv9[82] * w[3][0];
        sv9[97] = sv9[83] * w[3][0];
        sv9[98] = sv9[84] * w[3][0];
        sv9[99] = sv9[85] * w[3][0];
        sv9[100] = sv9[86] * w[3][0];
        sv9[101] = sv9[87] * w[3][0];
        sv9[102] = sv9[88] * w[3][0];
        sv9[103] = sv9[89] * w[3][0];
        sv9[104] = sv9[90] * w[3][0];
        sv9[105] = 2.0 * w0_c1 * w[19][0];
        sv9[106] = sv9[38] * (-1.0 / w[39][0]);
        sv9[107] = sv9[105] / 2 * (-1.0 / w[39][0]);
        sv9[108] = sv9[3] * (-1.0 / w[39][0]);
        sv9[109] = sv9[0] * (-1.0 / w[39][0]);
        sv9[110] = -1 * sv9[91] * sp[47];
        sv9[111] = -1 * sv9[92] * sp[47];
        sv9[112] = -1 * sv9[93] * sp[47];
        sv9[113] = -1 * sv9[94] * sp[47];
        sv9[114] = -1 * sv9[95] * sp[47];
        sv9[115] = -1 * sv9[96] * sp[47];
        sv9[116] = -1 * sv9[97] * sp[47];
        sv9[117] = -1 * sv9[98] * sp[47];
        sv9[118] = -1 * sv9[99] * sp[47];
        sv9[119] = -1 * sv9[100] * sp[47];
        sv9[120] = -1 * sv9[101] * sp[47];
        sv9[121] = -1 * sv9[102] * sp[47];
        sv9[122] = -1 * sv9[103] * sp[47];
        sv9[123] = -1 * sv9[104] * sp[47];
        sv9[124] = sv9[108] * sp[47];
        sv9[125] = sv9[106] * sp[47];
        sv9[126] = sv9[109] * sp[47];
        sv9[127] = sv9[107] * sp[47];
        const double fw0 = sv9[127] * weights9[iq];
        alignas(32) double TF0[3];
        for (int i = 0; i < 3; ++i)
            TF0[i] = fw0 * FE3_C0_F_Q9[facet][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF0[i][j] += TF0[i] * FE3_C0_F_Q9[facet][iq][j];
        const double fw1 = sv9[124] * weights9[iq];
        alignas(32) double TF1[3];
        for (int i = 0; i < 3; ++i)
            TF1[i] = fw1 * FE3_C0_F_Q9[facet][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF1[i][j] += TF1[i] * FE3_C0_F_Q9[facet][iq][j];
        const double fw2 = sv9[125] * weights9[iq];
        alignas(32) double TF2[3];
        for (int i = 0; i < 3; ++i)
            TF2[i] = fw2 * FE3_C0_F_Q9[facet][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF2[i][j] += TF2[i] * FE3_C0_F_Q9[facet][iq][j];
        const double fw3 = sv9[126] * weights9[iq];
        alignas(32) double TF3[3];
        for (int i = 0; i < 3; ++i)
            TF3[i] = fw3 * FE3_C0_F_Q9[facet][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF3[i][j] += TF3[i] * FE3_C0_F_Q9[facet][iq][j];
        const double fw4 = sv9[118] * weights9[iq];
        for (int j = 0; j < 2; ++j)
            TP0[j] += fw4 * FE3_C0_D01_F_Q9[0][0][j];
        const double fw5 = sv9[116] * weights9[iq];
        for (int j = 0; j < 3; ++j)
            TP1[j] += fw5 * FE3_C0_F_Q9[facet][iq][j];
        const double fw6 = sv9[117] * weights9[iq];
        for (int j = 0; j < 2; ++j)
            TP2[j] += fw6 * FE3_C0_D01_F_Q9[0][0][j];
        const double fw7 = sv9[123] * weights9[iq];
        for (int j = 0; j < 2; ++j)
            TP3[j] += fw7 * FE3_C0_D01_F_Q9[0][0][j];
        const double fw8 = sv9[121] * weights9[iq];
        for (int j = 0; j < 3; ++j)
            TP4[j] += fw8 * FE3_C0_F_Q9[facet][iq][j];
        const double fw9 = sv9[122] * weights9[iq];
        for (int j = 0; j < 2; ++j)
            TP5[j] += fw9 * FE3_C0_D01_F_Q9[0][0][j];
        const double fw10 = sv9[115] * weights9[iq];
        for (int j = 0; j < 2; ++j)
            TP6[j] += fw10 * FE3_C0_D01_F_Q9[0][0][j];
        const double fw11 = sv9[110] * weights9[iq];
        for (int j = 0; j < 3; ++j)
            TP7[j] += fw11 * FE3_C0_F_Q9[facet][iq][j];
        const double fw12 = sv9[114] * weights9[iq];
        for (int j = 0; j < 2; ++j)
            TP8[j] += fw12 * FE3_C0_D01_F_Q9[0][0][j];
        const double fw13 = sv9[120] * weights9[iq];
        for (int j = 0; j < 2; ++j)
            TP9[j] += fw13 * FE3_C0_D01_F_Q9[0][0][j];
        const double fw14 = sv9[119] * weights9[iq];
        for (int j = 0; j < 2; ++j)
            TP10[j] += fw14 * FE3_C0_D01_F_Q9[0][0][j];
        const double fw15 = sv9[112] * weights9[iq];
        for (int j = 0; j < 2; ++j)
            TP11[j] += fw15 * FE3_C0_D01_F_Q9[0][0][j];
        const double fw16 = sv9[113] * weights9[iq];
        for (int j = 0; j < 3; ++j)
            TP12[j] += fw16 * FE3_C0_F_Q9[facet][iq][j];
        const double fw17 = sv9[111] * weights9[iq];
        for (int j = 0; j < 2; ++j)
            TP13[j] += fw17 * FE3_C0_D01_F_Q9[0][0][j];
    }
    A[0] = sp[50] * PI0[facet][0][0];
    A[1] = sp[50] * PI0[facet][0][1];
    A[2] = sp[50] * PI0[facet][0][2];
    std::fill(A + 3, A + 19, 0.0);
    A[19] = sp[50] * PI0[facet][1][0];
    A[20] = sp[50] * PI0[facet][1][1];
    A[21] = sp[50] * PI0[facet][1][2];
    std::fill(A + 22, A + 38, 0.0);
    A[38] = sp[50] * PI0[facet][2][0];
    A[39] = sp[50] * PI0[facet][2][1];
    A[40] = sp[50] * PI0[facet][2][2];
    std::fill(A + 41, A + 60, 0.0);
    A[60] = sp[49] * PI0[facet][0][0];
    A[61] = sp[49] * PI0[facet][0][1];
    A[62] = sp[49] * PI0[facet][0][2];
    std::fill(A + 63, A + 79, 0.0);
    A[79] = sp[49] * PI0[facet][1][0];
    A[80] = sp[49] * PI0[facet][1][1];
    A[81] = sp[49] * PI0[facet][1][2];
    std::fill(A + 82, A + 98, 0.0);
    A[98] = sp[49] * PI0[facet][2][0];
    A[99] = sp[49] * PI0[facet][2][1];
    A[100] = sp[49] * PI0[facet][2][2];
    std::fill(A + 101, A + 240, 0.0);
    A[240] = sp[51] * PI0[facet][0][0];
    A[241] = sp[51] * PI0[facet][0][1];
    A[242] = sp[51] * PI0[facet][0][2];
    std::fill(A + 243, A + 246, 0.0);
    A[246] = sp[48] * PI1[facet][0][0];
    std::fill(A + 247, A + 259, 0.0);
    A[259] = sp[51] * PI0[facet][1][0];
    A[260] = sp[51] * PI0[facet][1][1];
    A[261] = sp[51] * PI0[facet][1][2];
    std::fill(A + 262, A + 265, 0.0);
    A[265] = sp[48] * PI1[facet][1][0];
    std::fill(A + 266, A + 278, 0.0);
    A[278] = sp[51] * PI0[facet][2][0];
    A[279] = sp[51] * PI0[facet][2][1];
    A[280] = sp[51] * PI0[facet][2][2];
    std::fill(A + 281, A + 284, 0.0);
    A[284] = sp[48] * PI1[facet][2][0];
    std::fill(A + 285, A + 360, 0.0);
    A[360] = sp[47] * PI2[0][0][0];
    static const int DM0[2] = { 3, 5 };
    static const int DM1[2] = { 6, 8 };
    static const int DM2[2] = { 9, 11 };
    static const int DM3[2] = { 12, 14 };
    static const int DM4[2] = { 15, 17 };
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 6) + (j + 3)] += BF0[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 6) + (j + 6)] += BF1[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 6) + (j + 15)] += BF2[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 9) + (j + 3)] += BF0[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 9) + (j + 9)] += BF1[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 9) + (j + 15)] += BF3[i][j];
    for (int i = 0; i < 1; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 18) + (j + 3)] += TP0[j];
    for (int i = 0; i < 1; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 18) + (j + 3)] += TP1[j];
    for (int i = 0; i < 1; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 18) + DM0[j]] += TP2[j];
    for (int i = 0; i < 1; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 18) + (j + 6)] += TP3[j];
    for (int i = 0; i < 1; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 18) + (j + 6)] += TP4[j];
    for (int i = 0; i < 1; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 18) + DM1[j]] += TP5[j];
    for (int i = 0; i < 1; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 18) + (j + 9)] += TP6[j];
    for (int i = 0; i < 1; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 18) + (j + 9)] += TP7[j];
    for (int i = 0; i < 1; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 18) + DM2[j]] += TP8[j];
    for (int i = 0; i < 1; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 18) + (j + 12)] += TP9[j];
    for (int i = 0; i < 1; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 18) + DM3[j]] += TP10[j];
    for (int i = 0; i < 1; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 18) + (j + 15)] += TP11[j];
    for (int i = 0; i < 1; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 18) + (j + 15)] += TP12[j];
    for (int i = 0; i < 1; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 18) + DM4[j]] += TP13[j];
}


vo2_2tdevice_exterior_facet_integral_1_1::vo2_2tdevice_exterior_facet_integral_1_1() : ufc::exterior_facet_integral()
{

}

vo2_2tdevice_exterior_facet_integral_1_1::~vo2_2tdevice_exterior_facet_integral_1_1()
{

}

const std::vector<bool> & vo2_2tdevice_exterior_facet_integral_1_1::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, false, false, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, false});
return enabled;
}

void vo2_2tdevice_exterior_facet_integral_1_1::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    std::size_t facet,
                                    int cell_orientation) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 3
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 3
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           3
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Quadrature rules
    alignas(32) static const double weights2[2] = { 0.5, 0.5 };
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE18_C0_F_Q2[3][2][3] =
        { { { 0.0, 0.7886751345948129, 0.2113248654051871 },
            { 0.0, 0.2113248654051872, 0.7886751345948129 } },
          { { 0.7886751345948129, 0.0, 0.2113248654051871 },
            { 0.2113248654051872, 0.0, 0.7886751345948129 } },
          { { 0.7886751345948129, 0.2113248654051871, 0.0 },
            { 0.2113248654051871, 0.7886751345948129, 0.0 } } };
    alignas(32) static const double FE3_C0_D01_F_Q2[1][1][2] = { { { -1.0, 1.0 } } };
    alignas(32) static const double PI0[3][3][3] =
        { { { 0.0, 0.0, 0.0 },
            { 0.0, 0.3333333333333334, 0.1666666666666667 },
            { 0.0, 0.1666666666666667, 0.3333333333333334 } },
          { { 0.3333333333333334, 0.0, 0.1666666666666667 },
            { 0.0, 0.0, 0.0 },
            { 0.1666666666666667, 0.0, 0.3333333333333334 } },
          { { 0.3333333333333334, 0.1666666666666667, 0.0 },
            { 0.1666666666666667, 0.3333333333333334, 0.0 },
            { 0.0, 0.0, 0.0 } } };
    // Unstructured piecewise computations
    const double J_c0 = coordinate_dofs[0] * FE3_C0_D01_F_Q2[0][0][0] + coordinate_dofs[2] * FE3_C0_D01_F_Q2[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE3_C0_D01_F_Q2[0][0][0] + coordinate_dofs[4] * FE3_C0_D01_F_Q2[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE3_C0_D01_F_Q2[0][0][0] + coordinate_dofs[3] * FE3_C0_D01_F_Q2[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE3_C0_D01_F_Q2[0][0][0] + coordinate_dofs[5] * FE3_C0_D01_F_Q2[0][0][1];
    alignas(32) double sp[16];
    sp[0] = w[20][0] * w[21][0];
    sp[1] = sp[0] / w[38][0];
    sp[2] = w[22][0] * w[23][0];
    sp[3] = sp[2] / w[38][0];
    sp[4] = J_c0 * triangle_reference_facet_jacobian[facet][0][0];
    sp[5] = J_c1 * triangle_reference_facet_jacobian[facet][1][0];
    sp[6] = sp[4] + sp[5];
    sp[7] = sp[6] * sp[6];
    sp[8] = triangle_reference_facet_jacobian[facet][0][0] * J_c2;
    sp[9] = triangle_reference_facet_jacobian[facet][1][0] * J_c3;
    sp[10] = sp[8] + sp[9];
    sp[11] = sp[10] * sp[10];
    sp[12] = sp[7] + sp[11];
    sp[13] = std::sqrt(sp[12]);
    sp[14] = -1 * (-1.0 * sp[1]) * sp[13];
    sp[15] = -1 * (-1.0 * sp[3]) * sp[13];
    alignas(32) double BF0[3][3] = {};
    alignas(32) double BF1[3][3] = {};
    alignas(32) double BF2[3][3] = {};
    alignas(32) double BF3[3][3] = {};
    for (int iq = 0; iq < 2; ++iq)
    {
        // Quadrature loop body setup (num_points=2)
        // Unstructured varying computations for num_points=2
        double w0_c5 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c5 += w[0][ic + 15] * FE18_C0_F_Q2[facet][iq][ic];
        double w0_c2 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c2 += w[0][ic + 6] * FE18_C0_F_Q2[facet][iq][ic];
        double w0_c1 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c1 += w[0][ic + 3] * FE18_C0_F_Q2[facet][iq][ic];
        double w0_c3 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c3 += w[0][ic + 9] * FE18_C0_F_Q2[facet][iq][ic];
        alignas(32) double sv2[12];
        sv2[0] = w0_c5 * w[5][0];
        sv2[1] = w0_c2 * w[5][0];
        sv2[2] = 2.0 * w0_c1 * w[19][0];
        sv2[3] = sv2[2] / 2 * (1.0 / w[39][0]);
        sv2[4] = sv2[0] * (1.0 / w[39][0]);
        sv2[5] = sv2[1] * (1.0 / w[39][0]);
        sv2[6] = w0_c3 * w[5][0];
        sv2[7] = sv2[6] * (1.0 / w[39][0]);
        sv2[8] = -1 * sv2[3] * sp[13];
        sv2[9] = -1 * sv2[4] * sp[13];
        sv2[10] = -1 * sv2[5] * sp[13];
        sv2[11] = -1 * sv2[7] * sp[13];
        const double fw0 = sv2[8] * weights2[iq];
        alignas(32) double TF0[3];
        for (int i = 0; i < 3; ++i)
            TF0[i] = fw0 * FE18_C0_F_Q2[facet][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF0[i][j] += TF0[i] * FE18_C0_F_Q2[facet][iq][j];
        const double fw1 = sv2[9] * weights2[iq];
        alignas(32) double TF1[3];
        for (int i = 0; i < 3; ++i)
            TF1[i] = fw1 * FE18_C0_F_Q2[facet][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF1[i][j] += TF1[i] * FE18_C0_F_Q2[facet][iq][j];
        const double fw2 = sv2[10] * weights2[iq];
        alignas(32) double TF2[3];
        for (int i = 0; i < 3; ++i)
            TF2[i] = fw2 * FE18_C0_F_Q2[facet][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF2[i][j] += TF2[i] * FE18_C0_F_Q2[facet][iq][j];
        const double fw3 = sv2[11] * weights2[iq];
        alignas(32) double TF3[3];
        for (int i = 0; i < 3; ++i)
            TF3[i] = fw3 * FE18_C0_F_Q2[facet][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF3[i][j] += TF3[i] * FE18_C0_F_Q2[facet][iq][j];
    }
    A[0] = sp[14] * PI0[facet][0][0];
    A[1] = sp[14] * PI0[facet][0][1];
    A[2] = sp[14] * PI0[facet][0][2];
    std::fill(A + 3, A + 19, 0.0);
    A[19] = sp[14] * PI0[facet][1][0];
    A[20] = sp[14] * PI0[facet][1][1];
    A[21] = sp[14] * PI0[facet][1][2];
    std::fill(A + 22, A + 38, 0.0);
    A[38] = sp[14] * PI0[facet][2][0];
    A[39] = sp[14] * PI0[facet][2][1];
    A[40] = sp[14] * PI0[facet][2][2];
    std::fill(A + 41, A + 60, 0.0);
    A[60] = sp[15] * PI0[facet][0][0];
    A[61] = sp[15] * PI0[facet][0][1];
    A[62] = sp[15] * PI0[facet][0][2];
    std::fill(A + 63, A + 79, 0.0);
    A[79] = sp[15] * PI0[facet][1][0];
    A[80] = sp[15] * PI0[facet][1][1];
    A[81] = sp[15] * PI0[facet][1][2];
    std::fill(A + 82, A + 98, 0.0);
    A[98] = sp[15] * PI0[facet][2][0];
    A[99] = sp[15] * PI0[facet][2][1];
    A[100] = sp[15] * PI0[facet][2][2];
    std::fill(A + 101, A + 361, 0.0);
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 6) + (j + 3)] += BF0[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 6) + (j + 6)] += BF1[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 6) + (j + 15)] += BF2[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 9) + (j + 3)] += BF0[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 9) + (j + 9)] += BF1[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 9) + (j + 15)] += BF3[i][j];
}


vo2_2tdevice_exterior_facet_integral_1_otherwise::vo2_2tdevice_exterior_facet_integral_1_otherwise() : ufc::exterior_facet_integral()
{

}

vo2_2tdevice_exterior_facet_integral_1_otherwise::~vo2_2tdevice_exterior_facet_integral_1_otherwise()
{

}

const std::vector<bool> & vo2_2tdevice_exterior_facet_integral_1_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, false});
return enabled;
}

void vo2_2tdevice_exterior_facet_integral_1_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    std::size_t facet,
                                    int cell_orientation) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 2
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 2
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           2
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE3_C0_D01_F_Q2[1][1][2] = { { { -1.0, 1.0 } } };
    alignas(32) static const double PI0[3][3][3] =
        { { { 0.0, 0.0, 0.0 },
            { 0.0, 0.3333333333333334, 0.1666666666666667 },
            { 0.0, 0.1666666666666667, 0.3333333333333334 } },
          { { 0.3333333333333334, 0.0, 0.1666666666666667 },
            { 0.0, 0.0, 0.0 },
            { 0.1666666666666667, 0.0, 0.3333333333333334 } },
          { { 0.3333333333333334, 0.1666666666666667, 0.0 },
            { 0.1666666666666667, 0.3333333333333334, 0.0 },
            { 0.0, 0.0, 0.0 } } };
    // Unstructured piecewise computations
    const double J_c0 = coordinate_dofs[0] * FE3_C0_D01_F_Q2[0][0][0] + coordinate_dofs[2] * FE3_C0_D01_F_Q2[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE3_C0_D01_F_Q2[0][0][0] + coordinate_dofs[4] * FE3_C0_D01_F_Q2[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE3_C0_D01_F_Q2[0][0][0] + coordinate_dofs[3] * FE3_C0_D01_F_Q2[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE3_C0_D01_F_Q2[0][0][0] + coordinate_dofs[5] * FE3_C0_D01_F_Q2[0][0][1];
    alignas(32) double sp[16];
    sp[0] = w[20][0] * w[21][0];
    sp[1] = sp[0] / w[38][0];
    sp[2] = w[22][0] * w[23][0];
    sp[3] = sp[2] / w[38][0];
    sp[4] = J_c0 * triangle_reference_facet_jacobian[facet][0][0];
    sp[5] = J_c1 * triangle_reference_facet_jacobian[facet][1][0];
    sp[6] = sp[4] + sp[5];
    sp[7] = sp[6] * sp[6];
    sp[8] = triangle_reference_facet_jacobian[facet][0][0] * J_c2;
    sp[9] = triangle_reference_facet_jacobian[facet][1][0] * J_c3;
    sp[10] = sp[8] + sp[9];
    sp[11] = sp[10] * sp[10];
    sp[12] = sp[7] + sp[11];
    sp[13] = std::sqrt(sp[12]);
    sp[14] = -1 * (-1.0 * sp[1]) * sp[13];
    sp[15] = -1 * (-1.0 * sp[3]) * sp[13];
    A[0] = sp[14] * PI0[facet][0][0];
    A[1] = sp[14] * PI0[facet][0][1];
    A[2] = sp[14] * PI0[facet][0][2];
    std::fill(A + 3, A + 19, 0.0);
    A[19] = sp[14] * PI0[facet][1][0];
    A[20] = sp[14] * PI0[facet][1][1];
    A[21] = sp[14] * PI0[facet][1][2];
    std::fill(A + 22, A + 38, 0.0);
    A[38] = sp[14] * PI0[facet][2][0];
    A[39] = sp[14] * PI0[facet][2][1];
    A[40] = sp[14] * PI0[facet][2][2];
    std::fill(A + 41, A + 60, 0.0);
    A[60] = sp[15] * PI0[facet][0][0];
    A[61] = sp[15] * PI0[facet][0][1];
    A[62] = sp[15] * PI0[facet][0][2];
    std::fill(A + 63, A + 79, 0.0);
    A[79] = sp[15] * PI0[facet][1][0];
    A[80] = sp[15] * PI0[facet][1][1];
    A[81] = sp[15] * PI0[facet][1][2];
    std::fill(A + 82, A + 98, 0.0);
    A[98] = sp[15] * PI0[facet][2][0];
    A[99] = sp[15] * PI0[facet][2][1];
    A[100] = sp[15] * PI0[facet][2][2];
    std::fill(A + 101, A + 361, 0.0);
}


vo2_2tdevice_cell_integral_2_otherwise::vo2_2tdevice_cell_integral_2_otherwise() : ufc::cell_integral()
{

}

vo2_2tdevice_cell_integral_2_otherwise::~vo2_2tdevice_cell_integral_2_otherwise()
{

}

const std::vector<bool> & vo2_2tdevice_cell_integral_2_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({true});
return enabled;
}

void vo2_2tdevice_cell_integral_2_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 2
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 2
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           2
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Quadrature rules
    alignas(32) static const double weights3[3] = { 0.1666666666666667, 0.1666666666666667, 0.1666666666666667 };
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE3_C0_D01_Q3[1][1][2] = { { { -1.0, 1.0 } } };
    alignas(32) static const double FE3_C0_Q3[1][3][3] =
        { { { 0.6666666666666669, 0.1666666666666666, 0.1666666666666667 },
            { 0.1666666666666667, 0.1666666666666666, 0.6666666666666665 },
            { 0.1666666666666667, 0.6666666666666666, 0.1666666666666666 } } };
    // Unstructured piecewise computations
    const double J_c0 = coordinate_dofs[0] * FE3_C0_D01_Q3[0][0][0] + coordinate_dofs[2] * FE3_C0_D01_Q3[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE3_C0_D01_Q3[0][0][0] + coordinate_dofs[5] * FE3_C0_D01_Q3[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE3_C0_D01_Q3[0][0][0] + coordinate_dofs[4] * FE3_C0_D01_Q3[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE3_C0_D01_Q3[0][0][0] + coordinate_dofs[3] * FE3_C0_D01_Q3[0][0][1];
    alignas(32) double sp[4];
    sp[0] = J_c0 * J_c3;
    sp[1] = J_c1 * J_c2;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = std::abs(sp[2]);
    alignas(32) double BF0 = {};
    for (int iq = 0; iq < 3; ++iq)
    {
        // Quadrature loop body setup (num_points=3)
        // Unstructured varying computations for num_points=3
        double w0 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0 += w[0][ic] * FE3_C0_Q3[0][iq][ic];
        alignas(32) double sv3[1];
        sv3[0] = std::pow(w0, 2) * sp[3];
        const double fw0 = sv3[0] * weights3[iq];
        BF0 += fw0;
    }
    A[0] = 0.0;
    A[0] += BF0;
}


vo2_2tdevice_exterior_facet_integral_3_0::vo2_2tdevice_exterior_facet_integral_3_0() : ufc::exterior_facet_integral()
{

}

vo2_2tdevice_exterior_facet_integral_3_0::~vo2_2tdevice_exterior_facet_integral_3_0()
{

}

const std::vector<bool> & vo2_2tdevice_exterior_facet_integral_3_0::enabled_coefficients() const
{
static const std::vector<bool> enabled({true});
return enabled;
}

void vo2_2tdevice_exterior_facet_integral_3_0::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    std::size_t facet,
                                    int cell_orientation) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 1
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 1
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           1
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Quadrature rules
    alignas(32) static const double weights1[1] = { 1.0 };
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE3_C0_D01_F_Q1[1][1][2] = { { { -1.0, 1.0 } } };
    alignas(32) static const double FE3_C0_F_Q1[3][1][3] =
        { { { 0.0, 0.5, 0.5 } },
          { { 0.5, 0.0, 0.5 } },
          { { 0.5, 0.5, 0.0 } } };
    // Unstructured piecewise computations
    double w0_c4 = 0.0;
    for (int ic = 0; ic < 3; ++ic)
        w0_c4 += w[0][ic + 12] * FE3_C0_F_Q1[facet][0][ic];
    const double J_c0 = coordinate_dofs[0] * FE3_C0_D01_F_Q1[0][0][0] + coordinate_dofs[2] * FE3_C0_D01_F_Q1[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE3_C0_D01_F_Q1[0][0][0] + coordinate_dofs[4] * FE3_C0_D01_F_Q1[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE3_C0_D01_F_Q1[0][0][0] + coordinate_dofs[3] * FE3_C0_D01_F_Q1[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE3_C0_D01_F_Q1[0][0][0] + coordinate_dofs[5] * FE3_C0_D01_F_Q1[0][0][1];
    alignas(32) double sp[11];
    sp[0] = J_c0 * triangle_reference_facet_jacobian[facet][0][0];
    sp[1] = J_c1 * triangle_reference_facet_jacobian[facet][1][0];
    sp[2] = sp[0] + sp[1];
    sp[3] = sp[2] * sp[2];
    sp[4] = triangle_reference_facet_jacobian[facet][0][0] * J_c2;
    sp[5] = triangle_reference_facet_jacobian[facet][1][0] * J_c3;
    sp[6] = sp[4] + sp[5];
    sp[7] = sp[6] * sp[6];
    sp[8] = sp[3] + sp[7];
    sp[9] = std::sqrt(sp[8]);
    sp[10] = w0_c4 * sp[9];
    alignas(32) double BF0 = {};
    // Only 1 quadrature point, no loop
    {
        const double fw0 = sp[10] * weights1[0];
        BF0 += fw0;
    }
    A[0] = 0.0;
    A[0] += BF0;
}


vo2_2tdevice_cell_integral_4_otherwise::vo2_2tdevice_cell_integral_4_otherwise() : ufc::cell_integral()
{

}

vo2_2tdevice_cell_integral_4_otherwise::~vo2_2tdevice_cell_integral_4_otherwise()
{

}

const std::vector<bool> & vo2_2tdevice_cell_integral_4_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({true});
return enabled;
}

void vo2_2tdevice_cell_integral_4_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 1
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 1
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           1
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Quadrature rules
    alignas(32) static const double weights1[1] = { 0.5 };
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE3_C0_D01_Q1[1][1][2] = { { { -1.0, 1.0 } } };
    alignas(32) static const double FE3_C0_Q1[1][1][3] = { { { 0.3333333333333334, 0.3333333333333334, 0.3333333333333333 } } };
    // Unstructured piecewise computations
    double w0_c5 = 0.0;
    for (int ic = 0; ic < 3; ++ic)
        w0_c5 += w[0][ic + 15] * FE3_C0_Q1[0][0][ic];
    const double J_c0 = coordinate_dofs[0] * FE3_C0_D01_Q1[0][0][0] + coordinate_dofs[2] * FE3_C0_D01_Q1[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE3_C0_D01_Q1[0][0][0] + coordinate_dofs[5] * FE3_C0_D01_Q1[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE3_C0_D01_Q1[0][0][0] + coordinate_dofs[4] * FE3_C0_D01_Q1[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE3_C0_D01_Q1[0][0][0] + coordinate_dofs[3] * FE3_C0_D01_Q1[0][0][1];
    alignas(32) double sp[5];
    sp[0] = J_c0 * J_c3;
    sp[1] = J_c1 * J_c2;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = std::abs(sp[2]);
    sp[4] = w0_c5 * sp[3];
    alignas(32) double BF0 = {};
    // Only 1 quadrature point, no loop
    {
        const double fw0 = sp[4] * weights1[0];
        BF0 += fw0;
    }
    A[0] = 0.0;
    A[0] += BF0;
}


vo2_2tdevice_cell_integral_5_otherwise::vo2_2tdevice_cell_integral_5_otherwise() : ufc::cell_integral()
{

}

vo2_2tdevice_cell_integral_5_otherwise::~vo2_2tdevice_cell_integral_5_otherwise()
{

}

const std::vector<bool> & vo2_2tdevice_cell_integral_5_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({});
return enabled;
}

void vo2_2tdevice_cell_integral_5_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 2
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 2
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           2
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE3_C0_D01_Q3[1][1][2] = { { { -1.0, 1.0 } } };
    // Unstructured piecewise computations
    const double J_c0 = coordinate_dofs[0] * FE3_C0_D01_Q3[0][0][0] + coordinate_dofs[2] * FE3_C0_D01_Q3[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE3_C0_D01_Q3[0][0][0] + coordinate_dofs[5] * FE3_C0_D01_Q3[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE3_C0_D01_Q3[0][0][0] + coordinate_dofs[4] * FE3_C0_D01_Q3[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE3_C0_D01_Q3[0][0][0] + coordinate_dofs[3] * FE3_C0_D01_Q3[0][0][1];
    alignas(32) double sp[4];
    sp[0] = J_c0 * J_c3;
    sp[1] = J_c1 * J_c2;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = std::abs(sp[2]);
    A[0] = 0.08333333333333338 * sp[3];
    A[1] = 0.04166666666666666 * sp[3];
    A[2] = 0.04166666666666667 * sp[3];
    A[3] = 0.04166666666666666 * sp[3];
    A[4] = 0.08333333333333333 * sp[3];
    A[5] = 0.04166666666666665 * sp[3];
    A[6] = 0.04166666666666667 * sp[3];
    A[7] = 0.04166666666666665 * sp[3];
    A[8] = 0.08333333333333329 * sp[3];
}


vo2_2tdevice_cell_integral_6_otherwise::vo2_2tdevice_cell_integral_6_otherwise() : ufc::cell_integral()
{

}

vo2_2tdevice_cell_integral_6_otherwise::~vo2_2tdevice_cell_integral_6_otherwise()
{

}

const std::vector<bool> & vo2_2tdevice_cell_integral_6_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, true, true, true, true, true, true, true, true, true});
return enabled;
}

void vo2_2tdevice_cell_integral_6_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 5
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 5
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           5
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Quadrature rules
    alignas(32) static const double weights7[7] = { 0.1125, 0.06296959027241358, 0.06296959027241358, 0.06296959027241358, 0.06619707639425308, 0.06619707639425308, 0.06619707639425308 };
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE19_C0_D01_Q7[1][1][2] = { { { -1.0, 1.0 } } };
    alignas(32) static const double FE19_C0_Q7[1][7][3] =
        { { { 0.3333333333333334, 0.3333333333333333, 0.3333333333333333 },
            { 0.1012865073234565, 0.7974269853530872, 0.1012865073234563 },
            { 0.1012865073234565, 0.1012865073234564, 0.7974269853530871 },
            { 0.7974269853530873, 0.1012865073234563, 0.1012865073234563 },
            { 0.4701420641051152, 0.05971587178976979, 0.4701420641051151 },
            { 0.4701420641051152, 0.4701420641051151, 0.05971587178976974 },
            { 0.05971587178976993, 0.4701420641051151, 0.4701420641051151 } } };
    // Unstructured piecewise computations
    const double w0_d1_c5 = w[0][15] * FE19_C0_D01_Q7[0][0][0] + w[0][17] * FE19_C0_D01_Q7[0][0][1];
    const double J_c0 = coordinate_dofs[0] * FE19_C0_D01_Q7[0][0][0] + coordinate_dofs[2] * FE19_C0_D01_Q7[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE19_C0_D01_Q7[0][0][0] + coordinate_dofs[5] * FE19_C0_D01_Q7[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE19_C0_D01_Q7[0][0][0] + coordinate_dofs[4] * FE19_C0_D01_Q7[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE19_C0_D01_Q7[0][0][0] + coordinate_dofs[3] * FE19_C0_D01_Q7[0][0][1];
    double w0_d0_c5 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c5 += w[0][ic + 15] * FE19_C0_D01_Q7[0][0][ic];
    const double w0_d1_c2 = w[0][6] * FE19_C0_D01_Q7[0][0][0] + w[0][8] * FE19_C0_D01_Q7[0][0][1];
    double w0_d0_c2 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c2 += w[0][ic + 6] * FE19_C0_D01_Q7[0][0][ic];
    const double w0_d1_c1 = w[0][3] * FE19_C0_D01_Q7[0][0][0] + w[0][5] * FE19_C0_D01_Q7[0][0][1];
    double w0_d0_c1 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c1 += w[0][ic + 3] * FE19_C0_D01_Q7[0][0][ic];
    const double w0_d1_c4 = w[0][12] * FE19_C0_D01_Q7[0][0][0] + w[0][14] * FE19_C0_D01_Q7[0][0][1];
    double w0_d0_c4 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c4 += w[0][ic + 12] * FE19_C0_D01_Q7[0][0][ic];
    const double w0_d1_c3 = w[0][9] * FE19_C0_D01_Q7[0][0][0] + w[0][11] * FE19_C0_D01_Q7[0][0][1];
    double w0_d0_c3 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c3 += w[0][ic + 9] * FE19_C0_D01_Q7[0][0][ic];
    alignas(32) double sp[44];
    sp[0] = J_c0 * J_c3;
    sp[1] = J_c1 * J_c2;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = J_c0 / sp[2];
    sp[4] = w0_d1_c5 * sp[3];
    sp[5] = -1 * J_c1 / sp[2];
    sp[6] = w0_d0_c5 * sp[5];
    sp[7] = sp[4] + sp[6];
    sp[8] = w0_d1_c2 * sp[3];
    sp[9] = w0_d0_c2 * sp[5];
    sp[10] = sp[8] + sp[9];
    sp[11] = w0_d1_c1 * sp[3];
    sp[12] = w0_d0_c1 * sp[5];
    sp[13] = sp[11] + sp[12];
    sp[14] = w0_d1_c4 * sp[3];
    sp[15] = w0_d0_c4 * sp[5];
    sp[16] = sp[14] + sp[15];
    sp[17] = sp[16] * w[2][0];
    sp[18] = w[6][0] / w[2][0];
    sp[19] = w0_d1_c3 * sp[3];
    sp[20] = w0_d0_c3 * sp[5];
    sp[21] = sp[19] + sp[20];
    sp[22] = w[8][0] / w[2][0];
    sp[23] = J_c3 / sp[2];
    sp[24] = w0_d0_c5 * sp[23];
    sp[25] = -1 * J_c2 / sp[2];
    sp[26] = w0_d1_c5 * sp[25];
    sp[27] = sp[24] + sp[26];
    sp[28] = w0_d0_c2 * sp[23];
    sp[29] = w0_d1_c2 * sp[25];
    sp[30] = sp[28] + sp[29];
    sp[31] = w0_d0_c1 * sp[23];
    sp[32] = w0_d1_c1 * sp[25];
    sp[33] = sp[31] + sp[32];
    sp[34] = w0_d0_c4 * sp[23];
    sp[35] = w0_d1_c4 * sp[25];
    sp[36] = sp[34] + sp[35];
    sp[37] = sp[36] * w[2][0];
    sp[38] = w[7][0] / w[2][0];
    sp[39] = w0_d0_c3 * sp[23];
    sp[40] = w0_d1_c3 * sp[25];
    sp[41] = sp[39] + sp[40];
    sp[42] = w[9][0] / w[2][0];
    sp[43] = std::abs(sp[2]);
    alignas(32) double BF0[2] = {};
    alignas(32) double BF1[2] = {};
    for (int iq = 0; iq < 7; ++iq)
    {
        // Quadrature loop body setup (num_points=7)
        // Unstructured varying computations for num_points=7
        double w0_c2 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c2 += w[0][ic + 6] * FE19_C0_Q7[0][iq][ic];
        double w0_c5 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c5 += w[0][ic + 15] * FE19_C0_Q7[0][iq][ic];
        double w0_c1 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c1 += w[0][ic + 3] * FE19_C0_Q7[0][iq][ic];
        double w0_c3 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c3 += w[0][ic + 9] * FE19_C0_Q7[0][iq][ic];
        alignas(32) double sv7[50];
        sv7[0] = w0_c2 * w[1][0];
        sv7[1] = sp[7] * sv7[0];
        sv7[2] = w0_c5 * w[1][0];
        sv7[3] = sp[10] * sv7[2];
        sv7[4] = sv7[1] + sv7[3];
        sv7[5] = w0_c1 * w[3][0];
        sv7[6] = sp[13] * sv7[5];
        sv7[7] = sv7[4] + sv7[6];
        sv7[8] = sv7[7] + -1 * sp[17];
        sv7[9] = std::exp(-1 * w0_c2);
        sv7[10] = 1.32934038825 * std::pow(4 + std::pow(w0_c2, 2), -0.75) + sv7[9];
        sv7[11] = 1 / sv7[10] * w[4][0];
        sv7[12] = -1 * sv7[11] * sp[18];
        sv7[13] = sv7[8] * sv7[12];
        sv7[14] = w0_c3 * w[1][0];
        sv7[15] = sp[7] * sv7[14];
        sv7[16] = sp[21] * sv7[2];
        sv7[17] = sv7[15] + sv7[16];
        sv7[18] = sv7[17] + sv7[6];
        sv7[19] = sv7[18] + sp[17];
        sv7[20] = std::exp(-1 * w0_c3);
        sv7[21] = 1.32934038825 * std::pow(4 + std::pow(w0_c3, 2), -0.75) + sv7[20];
        sv7[22] = 1 / sv7[21] * w[5][0];
        sv7[23] = -1 * sv7[22] * sp[22];
        sv7[24] = sv7[19] * sv7[23];
        sv7[25] = sv7[13] + sv7[24];
        sv7[26] = sv7[25] * sp[3];
        sv7[27] = sv7[25] * sp[5];
        sv7[28] = sp[27] * sv7[0];
        sv7[29] = sp[30] * sv7[2];
        sv7[30] = sv7[28] + sv7[29];
        sv7[31] = sp[33] * sv7[5];
        sv7[32] = sv7[30] + sv7[31];
        sv7[33] = sv7[32] + -1 * sp[37];
        sv7[34] = -1 * sv7[11] * sp[38];
        sv7[35] = sv7[33] * sv7[34];
        sv7[36] = sp[27] * sv7[14];
        sv7[37] = sp[41] * sv7[2];
        sv7[38] = sv7[36] + sv7[37];
        sv7[39] = sv7[38] + sv7[31];
        sv7[40] = sv7[39] + sp[37];
        sv7[41] = -1 * sv7[22] * sp[42];
        sv7[42] = sv7[40] * sv7[41];
        sv7[43] = sv7[35] + sv7[42];
        sv7[44] = sv7[43] * sp[25];
        sv7[45] = sv7[43] * sp[23];
        sv7[46] = sv7[26] + sv7[44];
        sv7[47] = sv7[45] + sv7[27];
        sv7[48] = sv7[46] * sp[43];
        sv7[49] = sv7[47] * sp[43];
        const double fw0 = sv7[49] * weights7[iq];
        for (int i = 0; i < 2; ++i)
            BF0[i] += fw0 * FE19_C0_D01_Q7[0][0][i];
        const double fw1 = sv7[48] * weights7[iq];
        for (int i = 0; i < 2; ++i)
            BF1[i] += fw1 * FE19_C0_D01_Q7[0][0][i];
    }
    std::fill(A, A + 3, 0.0);
    static const int DM0[2] = { 0, 2 };
    for (int i = 0; i < 2; ++i)
        A[i] += BF0[i];
    for (int i = 0; i < 2; ++i)
        A[DM0[i]] += BF1[i];
}


vo2_2tdevice_exterior_facet_integral_6_0::vo2_2tdevice_exterior_facet_integral_6_0() : ufc::exterior_facet_integral()
{

}

vo2_2tdevice_exterior_facet_integral_6_0::~vo2_2tdevice_exterior_facet_integral_6_0()
{

}

const std::vector<bool> & vo2_2tdevice_exterior_facet_integral_6_0::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, true, true, true, true, true, true, false, true, false});
return enabled;
}

void vo2_2tdevice_exterior_facet_integral_6_0::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    std::size_t facet,
                                    int cell_orientation) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 6
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 6
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           6
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Quadrature rules
    alignas(32) static const double weights4[4] = { 0.1739274225687268, 0.3260725774312731, 0.3260725774312731, 0.1739274225687268 };
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE19_C0_D01_F_Q4[1][1][2] = { { { -1.0, 1.0 } } };
    alignas(32) static const double FE19_C0_F_Q4[3][4][3] =
        { { { 0.0, 0.9305681557970263, 0.06943184420297369 },
            { 0.0, 0.6699905217924281, 0.3300094782075718 },
            { 0.0, 0.3300094782075719, 0.6699905217924279 },
            { 0.0, 0.06943184420297382, 0.9305681557970262 } },
          { { 0.9305681557970263, 0.0, 0.06943184420297369 },
            { 0.6699905217924281, 0.0, 0.3300094782075718 },
            { 0.3300094782075719, 0.0, 0.669990521792428 },
            { 0.06943184420297382, 0.0, 0.9305681557970262 } },
          { { 0.9305681557970263, 0.06943184420297367, 0.0 },
            { 0.6699905217924281, 0.3300094782075718, 0.0 },
            { 0.3300094782075719, 0.6699905217924281, 0.0 },
            { 0.06943184420297374, 0.9305681557970263, 0.0 } } };
    // Unstructured piecewise computations
    const double w0_d1_c5 = w[0][15] * FE19_C0_D01_F_Q4[0][0][0] + w[0][17] * FE19_C0_D01_F_Q4[0][0][1];
    const double J_c0 = coordinate_dofs[0] * FE19_C0_D01_F_Q4[0][0][0] + coordinate_dofs[2] * FE19_C0_D01_F_Q4[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE19_C0_D01_F_Q4[0][0][0] + coordinate_dofs[5] * FE19_C0_D01_F_Q4[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE19_C0_D01_F_Q4[0][0][0] + coordinate_dofs[4] * FE19_C0_D01_F_Q4[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE19_C0_D01_F_Q4[0][0][0] + coordinate_dofs[3] * FE19_C0_D01_F_Q4[0][0][1];
    double w0_d0_c5 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c5 += w[0][ic + 15] * FE19_C0_D01_F_Q4[0][0][ic];
    const double w0_d1_c2 = w[0][6] * FE19_C0_D01_F_Q4[0][0][0] + w[0][8] * FE19_C0_D01_F_Q4[0][0][1];
    double w0_d0_c2 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c2 += w[0][ic + 6] * FE19_C0_D01_F_Q4[0][0][ic];
    const double w0_d1_c1 = w[0][3] * FE19_C0_D01_F_Q4[0][0][0] + w[0][5] * FE19_C0_D01_F_Q4[0][0][1];
    double w0_d0_c1 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c1 += w[0][ic + 3] * FE19_C0_D01_F_Q4[0][0][ic];
    const double w0_d1_c4 = w[0][12] * FE19_C0_D01_F_Q4[0][0][0] + w[0][14] * FE19_C0_D01_F_Q4[0][0][1];
    double w0_d0_c4 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c4 += w[0][ic + 12] * FE19_C0_D01_F_Q4[0][0][ic];
    const double w0_d1_c3 = w[0][9] * FE19_C0_D01_F_Q4[0][0][0] + w[0][11] * FE19_C0_D01_F_Q4[0][0][1];
    double w0_d0_c3 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c3 += w[0][ic + 9] * FE19_C0_D01_F_Q4[0][0][ic];
    alignas(32) double sp[33];
    sp[0] = J_c0 * J_c3;
    sp[1] = J_c1 * J_c2;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = J_c0 / sp[2];
    sp[4] = w0_d1_c5 * sp[3];
    sp[5] = -1 * J_c1 / sp[2];
    sp[6] = w0_d0_c5 * sp[5];
    sp[7] = sp[4] + sp[6];
    sp[8] = w0_d1_c2 * sp[3];
    sp[9] = w0_d0_c2 * sp[5];
    sp[10] = sp[8] + sp[9];
    sp[11] = w0_d1_c1 * sp[3];
    sp[12] = w0_d0_c1 * sp[5];
    sp[13] = sp[11] + sp[12];
    sp[14] = w0_d1_c4 * sp[3];
    sp[15] = w0_d0_c4 * sp[5];
    sp[16] = sp[14] + sp[15];
    sp[17] = sp[16] * w[2][0];
    sp[18] = w[6][0] / w[2][0];
    sp[19] = w0_d1_c3 * sp[3];
    sp[20] = w0_d0_c3 * sp[5];
    sp[21] = sp[19] + sp[20];
    sp[22] = w[8][0] / w[2][0];
    sp[23] = J_c0 * triangle_reference_facet_jacobian[facet][0][0];
    sp[24] = J_c1 * triangle_reference_facet_jacobian[facet][1][0];
    sp[25] = sp[23] + sp[24];
    sp[26] = sp[25] * sp[25];
    sp[27] = triangle_reference_facet_jacobian[facet][0][0] * J_c2;
    sp[28] = triangle_reference_facet_jacobian[facet][1][0] * J_c3;
    sp[29] = sp[27] + sp[28];
    sp[30] = sp[29] * sp[29];
    sp[31] = sp[26] + sp[30];
    sp[32] = std::sqrt(sp[31]);
    alignas(32) double BF0[3] = {};
    for (int iq = 0; iq < 4; ++iq)
    {
        // Quadrature loop body setup (num_points=4)
        // Unstructured varying computations for num_points=4
        double w0_c2 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c2 += w[0][ic + 6] * FE19_C0_F_Q4[facet][iq][ic];
        double w0_c5 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c5 += w[0][ic + 15] * FE19_C0_F_Q4[facet][iq][ic];
        double w0_c1 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c1 += w[0][ic + 3] * FE19_C0_F_Q4[facet][iq][ic];
        double w0_c3 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c3 += w[0][ic + 9] * FE19_C0_F_Q4[facet][iq][ic];
        alignas(32) double sv4[27];
        sv4[0] = w0_c2 * w[1][0];
        sv4[1] = sp[7] * sv4[0];
        sv4[2] = w0_c5 * w[1][0];
        sv4[3] = sp[10] * sv4[2];
        sv4[4] = sv4[1] + sv4[3];
        sv4[5] = w0_c1 * w[3][0];
        sv4[6] = sp[13] * sv4[5];
        sv4[7] = sv4[4] + sv4[6];
        sv4[8] = sv4[7] + -1 * sp[17];
        sv4[9] = std::exp(-1 * w0_c2);
        sv4[10] = 1.32934038825 * std::pow(4 + std::pow(w0_c2, 2), -0.75) + sv4[9];
        sv4[11] = 1 / sv4[10] * w[4][0];
        sv4[12] = -1 * sv4[11] * sp[18];
        sv4[13] = sv4[8] * sv4[12];
        sv4[14] = w0_c3 * w[1][0];
        sv4[15] = sp[7] * sv4[14];
        sv4[16] = sp[21] * sv4[2];
        sv4[17] = sv4[15] + sv4[16];
        sv4[18] = sv4[17] + sv4[6];
        sv4[19] = sv4[18] + sp[17];
        sv4[20] = std::exp(-1 * w0_c3);
        sv4[21] = 1.32934038825 * std::pow(4 + std::pow(w0_c3, 2), -0.75) + sv4[20];
        sv4[22] = 1 / sv4[21] * w[5][0];
        sv4[23] = -1 * sv4[22] * sp[22];
        sv4[24] = sv4[19] * sv4[23];
        sv4[25] = sv4[13] + sv4[24];
        sv4[26] = sv4[25] * sp[32];
        const double fw0 = sv4[26] * weights4[iq];
        for (int i = 0; i < 3; ++i)
            BF0[i] += fw0 * FE19_C0_F_Q4[facet][iq][i];
    }
    std::fill(A, A + 3, 0.0);
    for (int i = 0; i < 3; ++i)
        A[i] += BF0[i];
}


vo2_2tdevice_exterior_facet_integral_6_1::vo2_2tdevice_exterior_facet_integral_6_1() : ufc::exterior_facet_integral()
{

}

vo2_2tdevice_exterior_facet_integral_6_1::~vo2_2tdevice_exterior_facet_integral_6_1()
{

}

const std::vector<bool> & vo2_2tdevice_exterior_facet_integral_6_1::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, true, true, true, true, true, true, false, true, false});
return enabled;
}

void vo2_2tdevice_exterior_facet_integral_6_1::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    std::size_t facet,
                                    int cell_orientation) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 6
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 6
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           6
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Quadrature rules
    alignas(32) static const double weights4[4] = { 0.1739274225687268, 0.3260725774312731, 0.3260725774312731, 0.1739274225687268 };
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE19_C0_D01_F_Q4[1][1][2] = { { { -1.0, 1.0 } } };
    alignas(32) static const double FE19_C0_F_Q4[3][4][3] =
        { { { 0.0, 0.9305681557970263, 0.06943184420297369 },
            { 0.0, 0.6699905217924281, 0.3300094782075718 },
            { 0.0, 0.3300094782075719, 0.6699905217924279 },
            { 0.0, 0.06943184420297382, 0.9305681557970262 } },
          { { 0.9305681557970263, 0.0, 0.06943184420297369 },
            { 0.6699905217924281, 0.0, 0.3300094782075718 },
            { 0.3300094782075719, 0.0, 0.669990521792428 },
            { 0.06943184420297382, 0.0, 0.9305681557970262 } },
          { { 0.9305681557970263, 0.06943184420297367, 0.0 },
            { 0.6699905217924281, 0.3300094782075718, 0.0 },
            { 0.3300094782075719, 0.6699905217924281, 0.0 },
            { 0.06943184420297374, 0.9305681557970263, 0.0 } } };
    // Unstructured piecewise computations
    const double w0_d1_c5 = w[0][15] * FE19_C0_D01_F_Q4[0][0][0] + w[0][17] * FE19_C0_D01_F_Q4[0][0][1];
    const double J_c0 = coordinate_dofs[0] * FE19_C0_D01_F_Q4[0][0][0] + coordinate_dofs[2] * FE19_C0_D01_F_Q4[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE19_C0_D01_F_Q4[0][0][0] + coordinate_dofs[5] * FE19_C0_D01_F_Q4[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE19_C0_D01_F_Q4[0][0][0] + coordinate_dofs[4] * FE19_C0_D01_F_Q4[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE19_C0_D01_F_Q4[0][0][0] + coordinate_dofs[3] * FE19_C0_D01_F_Q4[0][0][1];
    double w0_d0_c5 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c5 += w[0][ic + 15] * FE19_C0_D01_F_Q4[0][0][ic];
    const double w0_d1_c2 = w[0][6] * FE19_C0_D01_F_Q4[0][0][0] + w[0][8] * FE19_C0_D01_F_Q4[0][0][1];
    double w0_d0_c2 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c2 += w[0][ic + 6] * FE19_C0_D01_F_Q4[0][0][ic];
    const double w0_d1_c1 = w[0][3] * FE19_C0_D01_F_Q4[0][0][0] + w[0][5] * FE19_C0_D01_F_Q4[0][0][1];
    double w0_d0_c1 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c1 += w[0][ic + 3] * FE19_C0_D01_F_Q4[0][0][ic];
    const double w0_d1_c4 = w[0][12] * FE19_C0_D01_F_Q4[0][0][0] + w[0][14] * FE19_C0_D01_F_Q4[0][0][1];
    double w0_d0_c4 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c4 += w[0][ic + 12] * FE19_C0_D01_F_Q4[0][0][ic];
    const double w0_d1_c3 = w[0][9] * FE19_C0_D01_F_Q4[0][0][0] + w[0][11] * FE19_C0_D01_F_Q4[0][0][1];
    double w0_d0_c3 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c3 += w[0][ic + 9] * FE19_C0_D01_F_Q4[0][0][ic];
    alignas(32) double sp[33];
    sp[0] = J_c0 * J_c3;
    sp[1] = J_c1 * J_c2;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = J_c0 / sp[2];
    sp[4] = w0_d1_c5 * sp[3];
    sp[5] = -1 * J_c1 / sp[2];
    sp[6] = w0_d0_c5 * sp[5];
    sp[7] = sp[4] + sp[6];
    sp[8] = w0_d1_c2 * sp[3];
    sp[9] = w0_d0_c2 * sp[5];
    sp[10] = sp[8] + sp[9];
    sp[11] = w0_d1_c1 * sp[3];
    sp[12] = w0_d0_c1 * sp[5];
    sp[13] = sp[11] + sp[12];
    sp[14] = w0_d1_c4 * sp[3];
    sp[15] = w0_d0_c4 * sp[5];
    sp[16] = sp[14] + sp[15];
    sp[17] = sp[16] * w[2][0];
    sp[18] = w[6][0] / w[2][0];
    sp[19] = w0_d1_c3 * sp[3];
    sp[20] = w0_d0_c3 * sp[5];
    sp[21] = sp[19] + sp[20];
    sp[22] = w[8][0] / w[2][0];
    sp[23] = J_c0 * triangle_reference_facet_jacobian[facet][0][0];
    sp[24] = J_c1 * triangle_reference_facet_jacobian[facet][1][0];
    sp[25] = sp[23] + sp[24];
    sp[26] = sp[25] * sp[25];
    sp[27] = triangle_reference_facet_jacobian[facet][0][0] * J_c2;
    sp[28] = triangle_reference_facet_jacobian[facet][1][0] * J_c3;
    sp[29] = sp[27] + sp[28];
    sp[30] = sp[29] * sp[29];
    sp[31] = sp[26] + sp[30];
    sp[32] = std::sqrt(sp[31]);
    alignas(32) double BF0[3] = {};
    for (int iq = 0; iq < 4; ++iq)
    {
        // Quadrature loop body setup (num_points=4)
        // Unstructured varying computations for num_points=4
        double w0_c2 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c2 += w[0][ic + 6] * FE19_C0_F_Q4[facet][iq][ic];
        double w0_c5 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c5 += w[0][ic + 15] * FE19_C0_F_Q4[facet][iq][ic];
        double w0_c1 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c1 += w[0][ic + 3] * FE19_C0_F_Q4[facet][iq][ic];
        double w0_c3 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c3 += w[0][ic + 9] * FE19_C0_F_Q4[facet][iq][ic];
        alignas(32) double sv4[27];
        sv4[0] = w0_c2 * w[1][0];
        sv4[1] = sp[7] * sv4[0];
        sv4[2] = w0_c5 * w[1][0];
        sv4[3] = sp[10] * sv4[2];
        sv4[4] = sv4[1] + sv4[3];
        sv4[5] = w0_c1 * w[3][0];
        sv4[6] = sp[13] * sv4[5];
        sv4[7] = sv4[4] + sv4[6];
        sv4[8] = sv4[7] + -1 * sp[17];
        sv4[9] = std::exp(-1 * w0_c2);
        sv4[10] = 1.32934038825 * std::pow(4 + std::pow(w0_c2, 2), -0.75) + sv4[9];
        sv4[11] = 1 / sv4[10] * w[4][0];
        sv4[12] = -1 * sv4[11] * sp[18];
        sv4[13] = sv4[8] * sv4[12];
        sv4[14] = w0_c3 * w[1][0];
        sv4[15] = sp[7] * sv4[14];
        sv4[16] = sp[21] * sv4[2];
        sv4[17] = sv4[15] + sv4[16];
        sv4[18] = sv4[17] + sv4[6];
        sv4[19] = sv4[18] + sp[17];
        sv4[20] = std::exp(-1 * w0_c3);
        sv4[21] = 1.32934038825 * std::pow(4 + std::pow(w0_c3, 2), -0.75) + sv4[20];
        sv4[22] = 1 / sv4[21] * w[5][0];
        sv4[23] = -1 * sv4[22] * sp[22];
        sv4[24] = sv4[19] * sv4[23];
        sv4[25] = sv4[13] + sv4[24];
        sv4[26] = -1 * sv4[25] * sp[32];
        const double fw0 = sv4[26] * weights4[iq];
        for (int i = 0; i < 3; ++i)
            BF0[i] += fw0 * FE19_C0_F_Q4[facet][iq][i];
    }
    std::fill(A, A + 3, 0.0);
    for (int i = 0; i < 3; ++i)
        A[i] += BF0[i];
}


vo2_2tdevice_form_0::vo2_2tdevice_form_0() : ufc::form()
{
    // Do nothing
}

vo2_2tdevice_form_0::~vo2_2tdevice_form_0()
{
    // Do nothing
}

const char * vo2_2tdevice_form_0::signature() const
{
    return "eeb86effc30e49849e24789f9ce77148ff7f3da207fe8d555c42571b1e303486aa00fb0e2f1849642fef404333cd2935610cd0e339202e5599226d5ed8577178";
}

std::size_t vo2_2tdevice_form_0::rank() const
{
    return 1;
}

std::size_t vo2_2tdevice_form_0::num_coefficients() const
{
    return 45;
}

std::size_t vo2_2tdevice_form_0::original_coefficient_position(std::size_t i) const
{
    if (i >= 45)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44};
    return position[i];
}

ufc::finite_element * vo2_2tdevice_form_0::create_coordinate_finite_element() const
{
    return new vo2_2tdevice_finite_element_1();
}

ufc::dofmap * vo2_2tdevice_form_0::create_coordinate_dofmap() const
{
    return new vo2_2tdevice_dofmap_1();
}

ufc::coordinate_mapping * vo2_2tdevice_form_0::create_coordinate_mapping() const
{
    return new vo2_2tdevice_coordinate_mapping_1();
}

ufc::finite_element * vo2_2tdevice_form_0::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new vo2_2tdevice_finite_element_3();
    case 1:
        return new vo2_2tdevice_finite_element_3();
    case 2:
        return new vo2_2tdevice_finite_element_3();
    case 3:
        return new vo2_2tdevice_finite_element_2();
    case 4:
        return new vo2_2tdevice_finite_element_2();
    case 5:
        return new vo2_2tdevice_finite_element_2();
    case 6:
        return new vo2_2tdevice_finite_element_2();
    case 7:
        return new vo2_2tdevice_finite_element_2();
    case 8:
        return new vo2_2tdevice_finite_element_2();
    case 9:
        return new vo2_2tdevice_finite_element_2();
    case 10:
        return new vo2_2tdevice_finite_element_2();
    case 11:
        return new vo2_2tdevice_finite_element_2();
    case 12:
        return new vo2_2tdevice_finite_element_2();
    case 13:
        return new vo2_2tdevice_finite_element_2();
    case 14:
        return new vo2_2tdevice_finite_element_2();
    case 15:
        return new vo2_2tdevice_finite_element_2();
    case 16:
        return new vo2_2tdevice_finite_element_2();
    case 17:
        return new vo2_2tdevice_finite_element_2();
    case 18:
        return new vo2_2tdevice_finite_element_2();
    case 19:
        return new vo2_2tdevice_finite_element_2();
    case 20:
        return new vo2_2tdevice_finite_element_2();
    case 21:
        return new vo2_2tdevice_finite_element_2();
    case 22:
        return new vo2_2tdevice_finite_element_2();
    case 23:
        return new vo2_2tdevice_finite_element_2();
    case 24:
        return new vo2_2tdevice_finite_element_2();
    case 25:
        return new vo2_2tdevice_finite_element_2();
    case 26:
        return new vo2_2tdevice_finite_element_2();
    case 27:
        return new vo2_2tdevice_finite_element_2();
    case 28:
        return new vo2_2tdevice_finite_element_2();
    case 29:
        return new vo2_2tdevice_finite_element_2();
    case 30:
        return new vo2_2tdevice_finite_element_2();
    case 31:
        return new vo2_2tdevice_finite_element_2();
    case 32:
        return new vo2_2tdevice_finite_element_2();
    case 33:
        return new vo2_2tdevice_finite_element_2();
    case 34:
        return new vo2_2tdevice_finite_element_2();
    case 35:
        return new vo2_2tdevice_finite_element_2();
    case 36:
        return new vo2_2tdevice_finite_element_2();
    case 37:
        return new vo2_2tdevice_finite_element_2();
    case 38:
        return new vo2_2tdevice_finite_element_2();
    case 39:
        return new vo2_2tdevice_finite_element_2();
    case 40:
        return new vo2_2tdevice_finite_element_2();
    case 41:
        return new vo2_2tdevice_finite_element_2();
    case 42:
        return new vo2_2tdevice_finite_element_2();
    case 43:
        return new vo2_2tdevice_finite_element_2();
    case 44:
        return new vo2_2tdevice_finite_element_2();
    case 45:
        return new vo2_2tdevice_finite_element_0();
    default:
        return nullptr;
    }
}

ufc::dofmap * vo2_2tdevice_form_0::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new vo2_2tdevice_dofmap_3();
    case 1:
        return new vo2_2tdevice_dofmap_3();
    case 2:
        return new vo2_2tdevice_dofmap_3();
    case 3:
        return new vo2_2tdevice_dofmap_2();
    case 4:
        return new vo2_2tdevice_dofmap_2();
    case 5:
        return new vo2_2tdevice_dofmap_2();
    case 6:
        return new vo2_2tdevice_dofmap_2();
    case 7:
        return new vo2_2tdevice_dofmap_2();
    case 8:
        return new vo2_2tdevice_dofmap_2();
    case 9:
        return new vo2_2tdevice_dofmap_2();
    case 10:
        return new vo2_2tdevice_dofmap_2();
    case 11:
        return new vo2_2tdevice_dofmap_2();
    case 12:
        return new vo2_2tdevice_dofmap_2();
    case 13:
        return new vo2_2tdevice_dofmap_2();
    case 14:
        return new vo2_2tdevice_dofmap_2();
    case 15:
        return new vo2_2tdevice_dofmap_2();
    case 16:
        return new vo2_2tdevice_dofmap_2();
    case 17:
        return new vo2_2tdevice_dofmap_2();
    case 18:
        return new vo2_2tdevice_dofmap_2();
    case 19:
        return new vo2_2tdevice_dofmap_2();
    case 20:
        return new vo2_2tdevice_dofmap_2();
    case 21:
        return new vo2_2tdevice_dofmap_2();
    case 22:
        return new vo2_2tdevice_dofmap_2();
    case 23:
        return new vo2_2tdevice_dofmap_2();
    case 24:
        return new vo2_2tdevice_dofmap_2();
    case 25:
        return new vo2_2tdevice_dofmap_2();
    case 26:
        return new vo2_2tdevice_dofmap_2();
    case 27:
        return new vo2_2tdevice_dofmap_2();
    case 28:
        return new vo2_2tdevice_dofmap_2();
    case 29:
        return new vo2_2tdevice_dofmap_2();
    case 30:
        return new vo2_2tdevice_dofmap_2();
    case 31:
        return new vo2_2tdevice_dofmap_2();
    case 32:
        return new vo2_2tdevice_dofmap_2();
    case 33:
        return new vo2_2tdevice_dofmap_2();
    case 34:
        return new vo2_2tdevice_dofmap_2();
    case 35:
        return new vo2_2tdevice_dofmap_2();
    case 36:
        return new vo2_2tdevice_dofmap_2();
    case 37:
        return new vo2_2tdevice_dofmap_2();
    case 38:
        return new vo2_2tdevice_dofmap_2();
    case 39:
        return new vo2_2tdevice_dofmap_2();
    case 40:
        return new vo2_2tdevice_dofmap_2();
    case 41:
        return new vo2_2tdevice_dofmap_2();
    case 42:
        return new vo2_2tdevice_dofmap_2();
    case 43:
        return new vo2_2tdevice_dofmap_2();
    case 44:
        return new vo2_2tdevice_dofmap_2();
    case 45:
        return new vo2_2tdevice_dofmap_0();
    default:
        return nullptr;
    }
}

std::size_t vo2_2tdevice_form_0::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_0::max_exterior_facet_subdomain_id() const
{
    return 2;
}

std::size_t vo2_2tdevice_form_0::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_0::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_0::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_0::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_0::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_0::max_overlap_subdomain_id() const
{
    return 0;
}

bool vo2_2tdevice_form_0::has_cell_integrals() const
{
    return true;
}

bool vo2_2tdevice_form_0::has_exterior_facet_integrals() const
{
    return true;
}

bool vo2_2tdevice_form_0::has_interior_facet_integrals() const
{
    return false;
}

bool vo2_2tdevice_form_0::has_vertex_integrals() const
{
    return false;
}

bool vo2_2tdevice_form_0::has_custom_integrals() const
{
    return false;
}

bool vo2_2tdevice_form_0::has_cutcell_integrals() const
{
    return false;
}

bool vo2_2tdevice_form_0::has_interface_integrals() const
{
    return false;
}

bool vo2_2tdevice_form_0::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * vo2_2tdevice_form_0::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * vo2_2tdevice_form_0::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    switch (subdomain_id)
    {
    case 0:
        return new vo2_2tdevice_exterior_facet_integral_0_0();
    case 1:
        return new vo2_2tdevice_exterior_facet_integral_0_1();
    default:
        return nullptr;
    }
}

ufc::interior_facet_integral * vo2_2tdevice_form_0::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * vo2_2tdevice_form_0::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * vo2_2tdevice_form_0::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * vo2_2tdevice_form_0::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * vo2_2tdevice_form_0::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * vo2_2tdevice_form_0::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * vo2_2tdevice_form_0::create_default_cell_integral() const
{
    return new vo2_2tdevice_cell_integral_0_otherwise();
}

ufc::exterior_facet_integral * vo2_2tdevice_form_0::create_default_exterior_facet_integral() const
{
    return new vo2_2tdevice_exterior_facet_integral_0_otherwise();
}

ufc::interior_facet_integral * vo2_2tdevice_form_0::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * vo2_2tdevice_form_0::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * vo2_2tdevice_form_0::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * vo2_2tdevice_form_0::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * vo2_2tdevice_form_0::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * vo2_2tdevice_form_0::create_default_overlap_integral() const
{
    return nullptr;
}


vo2_2tdevice_form_1::vo2_2tdevice_form_1() : ufc::form()
{
    // Do nothing
}

vo2_2tdevice_form_1::~vo2_2tdevice_form_1()
{
    // Do nothing
}

const char * vo2_2tdevice_form_1::signature() const
{
    return "ffaeed7268a2e2dd2c078dfaf4ac158395bff5117c5ac39a6127b092606ccee49ef7afe849ae5d48bc8e74b567d8497b4e3c0dae7cd5f013251b0ef013e6cfb5";
}

std::size_t vo2_2tdevice_form_1::rank() const
{
    return 2;
}

std::size_t vo2_2tdevice_form_1::num_coefficients() const
{
    return 41;
}

std::size_t vo2_2tdevice_form_1::original_coefficient_position(std::size_t i) const
{
    if (i >= 41)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 38, 39, 42, 43, 44};
    return position[i];
}

ufc::finite_element * vo2_2tdevice_form_1::create_coordinate_finite_element() const
{
    return new vo2_2tdevice_finite_element_1();
}

ufc::dofmap * vo2_2tdevice_form_1::create_coordinate_dofmap() const
{
    return new vo2_2tdevice_dofmap_1();
}

ufc::coordinate_mapping * vo2_2tdevice_form_1::create_coordinate_mapping() const
{
    return new vo2_2tdevice_coordinate_mapping_1();
}

ufc::finite_element * vo2_2tdevice_form_1::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new vo2_2tdevice_finite_element_3();
    case 1:
        return new vo2_2tdevice_finite_element_3();
    case 2:
        return new vo2_2tdevice_finite_element_3();
    case 3:
        return new vo2_2tdevice_finite_element_3();
    case 4:
        return new vo2_2tdevice_finite_element_2();
    case 5:
        return new vo2_2tdevice_finite_element_2();
    case 6:
        return new vo2_2tdevice_finite_element_2();
    case 7:
        return new vo2_2tdevice_finite_element_2();
    case 8:
        return new vo2_2tdevice_finite_element_2();
    case 9:
        return new vo2_2tdevice_finite_element_2();
    case 10:
        return new vo2_2tdevice_finite_element_2();
    case 11:
        return new vo2_2tdevice_finite_element_2();
    case 12:
        return new vo2_2tdevice_finite_element_2();
    case 13:
        return new vo2_2tdevice_finite_element_2();
    case 14:
        return new vo2_2tdevice_finite_element_2();
    case 15:
        return new vo2_2tdevice_finite_element_2();
    case 16:
        return new vo2_2tdevice_finite_element_2();
    case 17:
        return new vo2_2tdevice_finite_element_2();
    case 18:
        return new vo2_2tdevice_finite_element_2();
    case 19:
        return new vo2_2tdevice_finite_element_2();
    case 20:
        return new vo2_2tdevice_finite_element_2();
    case 21:
        return new vo2_2tdevice_finite_element_2();
    case 22:
        return new vo2_2tdevice_finite_element_2();
    case 23:
        return new vo2_2tdevice_finite_element_2();
    case 24:
        return new vo2_2tdevice_finite_element_2();
    case 25:
        return new vo2_2tdevice_finite_element_2();
    case 26:
        return new vo2_2tdevice_finite_element_2();
    case 27:
        return new vo2_2tdevice_finite_element_2();
    case 28:
        return new vo2_2tdevice_finite_element_2();
    case 29:
        return new vo2_2tdevice_finite_element_2();
    case 30:
        return new vo2_2tdevice_finite_element_2();
    case 31:
        return new vo2_2tdevice_finite_element_2();
    case 32:
        return new vo2_2tdevice_finite_element_2();
    case 33:
        return new vo2_2tdevice_finite_element_2();
    case 34:
        return new vo2_2tdevice_finite_element_2();
    case 35:
        return new vo2_2tdevice_finite_element_2();
    case 36:
        return new vo2_2tdevice_finite_element_2();
    case 37:
        return new vo2_2tdevice_finite_element_2();
    case 38:
        return new vo2_2tdevice_finite_element_2();
    case 39:
        return new vo2_2tdevice_finite_element_2();
    case 40:
        return new vo2_2tdevice_finite_element_2();
    case 41:
        return new vo2_2tdevice_finite_element_2();
    case 42:
        return new vo2_2tdevice_finite_element_0();
    default:
        return nullptr;
    }
}

ufc::dofmap * vo2_2tdevice_form_1::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new vo2_2tdevice_dofmap_3();
    case 1:
        return new vo2_2tdevice_dofmap_3();
    case 2:
        return new vo2_2tdevice_dofmap_3();
    case 3:
        return new vo2_2tdevice_dofmap_3();
    case 4:
        return new vo2_2tdevice_dofmap_2();
    case 5:
        return new vo2_2tdevice_dofmap_2();
    case 6:
        return new vo2_2tdevice_dofmap_2();
    case 7:
        return new vo2_2tdevice_dofmap_2();
    case 8:
        return new vo2_2tdevice_dofmap_2();
    case 9:
        return new vo2_2tdevice_dofmap_2();
    case 10:
        return new vo2_2tdevice_dofmap_2();
    case 11:
        return new vo2_2tdevice_dofmap_2();
    case 12:
        return new vo2_2tdevice_dofmap_2();
    case 13:
        return new vo2_2tdevice_dofmap_2();
    case 14:
        return new vo2_2tdevice_dofmap_2();
    case 15:
        return new vo2_2tdevice_dofmap_2();
    case 16:
        return new vo2_2tdevice_dofmap_2();
    case 17:
        return new vo2_2tdevice_dofmap_2();
    case 18:
        return new vo2_2tdevice_dofmap_2();
    case 19:
        return new vo2_2tdevice_dofmap_2();
    case 20:
        return new vo2_2tdevice_dofmap_2();
    case 21:
        return new vo2_2tdevice_dofmap_2();
    case 22:
        return new vo2_2tdevice_dofmap_2();
    case 23:
        return new vo2_2tdevice_dofmap_2();
    case 24:
        return new vo2_2tdevice_dofmap_2();
    case 25:
        return new vo2_2tdevice_dofmap_2();
    case 26:
        return new vo2_2tdevice_dofmap_2();
    case 27:
        return new vo2_2tdevice_dofmap_2();
    case 28:
        return new vo2_2tdevice_dofmap_2();
    case 29:
        return new vo2_2tdevice_dofmap_2();
    case 30:
        return new vo2_2tdevice_dofmap_2();
    case 31:
        return new vo2_2tdevice_dofmap_2();
    case 32:
        return new vo2_2tdevice_dofmap_2();
    case 33:
        return new vo2_2tdevice_dofmap_2();
    case 34:
        return new vo2_2tdevice_dofmap_2();
    case 35:
        return new vo2_2tdevice_dofmap_2();
    case 36:
        return new vo2_2tdevice_dofmap_2();
    case 37:
        return new vo2_2tdevice_dofmap_2();
    case 38:
        return new vo2_2tdevice_dofmap_2();
    case 39:
        return new vo2_2tdevice_dofmap_2();
    case 40:
        return new vo2_2tdevice_dofmap_2();
    case 41:
        return new vo2_2tdevice_dofmap_2();
    case 42:
        return new vo2_2tdevice_dofmap_0();
    default:
        return nullptr;
    }
}

std::size_t vo2_2tdevice_form_1::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_1::max_exterior_facet_subdomain_id() const
{
    return 2;
}

std::size_t vo2_2tdevice_form_1::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_1::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_1::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_1::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_1::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_1::max_overlap_subdomain_id() const
{
    return 0;
}

bool vo2_2tdevice_form_1::has_cell_integrals() const
{
    return true;
}

bool vo2_2tdevice_form_1::has_exterior_facet_integrals() const
{
    return true;
}

bool vo2_2tdevice_form_1::has_interior_facet_integrals() const
{
    return false;
}

bool vo2_2tdevice_form_1::has_vertex_integrals() const
{
    return false;
}

bool vo2_2tdevice_form_1::has_custom_integrals() const
{
    return false;
}

bool vo2_2tdevice_form_1::has_cutcell_integrals() const
{
    return false;
}

bool vo2_2tdevice_form_1::has_interface_integrals() const
{
    return false;
}

bool vo2_2tdevice_form_1::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * vo2_2tdevice_form_1::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * vo2_2tdevice_form_1::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    switch (subdomain_id)
    {
    case 0:
        return new vo2_2tdevice_exterior_facet_integral_1_0();
    case 1:
        return new vo2_2tdevice_exterior_facet_integral_1_1();
    default:
        return nullptr;
    }
}

ufc::interior_facet_integral * vo2_2tdevice_form_1::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * vo2_2tdevice_form_1::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * vo2_2tdevice_form_1::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * vo2_2tdevice_form_1::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * vo2_2tdevice_form_1::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * vo2_2tdevice_form_1::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * vo2_2tdevice_form_1::create_default_cell_integral() const
{
    return new vo2_2tdevice_cell_integral_1_otherwise();
}

ufc::exterior_facet_integral * vo2_2tdevice_form_1::create_default_exterior_facet_integral() const
{
    return new vo2_2tdevice_exterior_facet_integral_1_otherwise();
}

ufc::interior_facet_integral * vo2_2tdevice_form_1::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * vo2_2tdevice_form_1::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * vo2_2tdevice_form_1::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * vo2_2tdevice_form_1::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * vo2_2tdevice_form_1::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * vo2_2tdevice_form_1::create_default_overlap_integral() const
{
    return nullptr;
}


vo2_2tdevice_form_2::vo2_2tdevice_form_2() : ufc::form()
{
    // Do nothing
}

vo2_2tdevice_form_2::~vo2_2tdevice_form_2()
{
    // Do nothing
}

const char * vo2_2tdevice_form_2::signature() const
{
    return "edb3ce5fd8542174e5a46a4fd1132b2fd7bedebf359cd8520aa4b7a9a019828bc1767e11279516072cdb269920cf227ad491b7e7b07772dce90e356769bba763";
}

std::size_t vo2_2tdevice_form_2::rank() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_2::num_coefficients() const
{
    return 1;
}

std::size_t vo2_2tdevice_form_2::original_coefficient_position(std::size_t i) const
{
    if (i >= 1)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0};
    return position[i];
}

ufc::finite_element * vo2_2tdevice_form_2::create_coordinate_finite_element() const
{
    return new vo2_2tdevice_finite_element_1();
}

ufc::dofmap * vo2_2tdevice_form_2::create_coordinate_dofmap() const
{
    return new vo2_2tdevice_dofmap_1();
}

ufc::coordinate_mapping * vo2_2tdevice_form_2::create_coordinate_mapping() const
{
    return new vo2_2tdevice_coordinate_mapping_1();
}

ufc::finite_element * vo2_2tdevice_form_2::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new vo2_2tdevice_finite_element_0();
    default:
        return nullptr;
    }
}

ufc::dofmap * vo2_2tdevice_form_2::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new vo2_2tdevice_dofmap_0();
    default:
        return nullptr;
    }
}

std::size_t vo2_2tdevice_form_2::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_2::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_2::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_2::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_2::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_2::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_2::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_2::max_overlap_subdomain_id() const
{
    return 0;
}

bool vo2_2tdevice_form_2::has_cell_integrals() const
{
    return true;
}

bool vo2_2tdevice_form_2::has_exterior_facet_integrals() const
{
    return false;
}

bool vo2_2tdevice_form_2::has_interior_facet_integrals() const
{
    return false;
}

bool vo2_2tdevice_form_2::has_vertex_integrals() const
{
    return false;
}

bool vo2_2tdevice_form_2::has_custom_integrals() const
{
    return false;
}

bool vo2_2tdevice_form_2::has_cutcell_integrals() const
{
    return false;
}

bool vo2_2tdevice_form_2::has_interface_integrals() const
{
    return false;
}

bool vo2_2tdevice_form_2::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * vo2_2tdevice_form_2::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * vo2_2tdevice_form_2::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * vo2_2tdevice_form_2::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * vo2_2tdevice_form_2::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * vo2_2tdevice_form_2::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * vo2_2tdevice_form_2::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * vo2_2tdevice_form_2::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * vo2_2tdevice_form_2::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * vo2_2tdevice_form_2::create_default_cell_integral() const
{
    return new vo2_2tdevice_cell_integral_2_otherwise();
}

ufc::exterior_facet_integral * vo2_2tdevice_form_2::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * vo2_2tdevice_form_2::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * vo2_2tdevice_form_2::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * vo2_2tdevice_form_2::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * vo2_2tdevice_form_2::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * vo2_2tdevice_form_2::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * vo2_2tdevice_form_2::create_default_overlap_integral() const
{
    return nullptr;
}


vo2_2tdevice_form_3::vo2_2tdevice_form_3() : ufc::form()
{
    // Do nothing
}

vo2_2tdevice_form_3::~vo2_2tdevice_form_3()
{
    // Do nothing
}

const char * vo2_2tdevice_form_3::signature() const
{
    return "af7d72858308b26e91f2fe52f3a2233bc0b07cb32334f6778959e98f436fe87135130d0b4bb51442106f62467c9144a809f9b7103811c1cdecf0637567835e5c";
}

std::size_t vo2_2tdevice_form_3::rank() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_3::num_coefficients() const
{
    return 1;
}

std::size_t vo2_2tdevice_form_3::original_coefficient_position(std::size_t i) const
{
    if (i >= 1)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0};
    return position[i];
}

ufc::finite_element * vo2_2tdevice_form_3::create_coordinate_finite_element() const
{
    return new vo2_2tdevice_finite_element_1();
}

ufc::dofmap * vo2_2tdevice_form_3::create_coordinate_dofmap() const
{
    return new vo2_2tdevice_dofmap_1();
}

ufc::coordinate_mapping * vo2_2tdevice_form_3::create_coordinate_mapping() const
{
    return new vo2_2tdevice_coordinate_mapping_1();
}

ufc::finite_element * vo2_2tdevice_form_3::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new vo2_2tdevice_finite_element_3();
    default:
        return nullptr;
    }
}

ufc::dofmap * vo2_2tdevice_form_3::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new vo2_2tdevice_dofmap_3();
    default:
        return nullptr;
    }
}

std::size_t vo2_2tdevice_form_3::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_3::max_exterior_facet_subdomain_id() const
{
    return 1;
}

std::size_t vo2_2tdevice_form_3::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_3::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_3::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_3::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_3::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_3::max_overlap_subdomain_id() const
{
    return 0;
}

bool vo2_2tdevice_form_3::has_cell_integrals() const
{
    return false;
}

bool vo2_2tdevice_form_3::has_exterior_facet_integrals() const
{
    return true;
}

bool vo2_2tdevice_form_3::has_interior_facet_integrals() const
{
    return false;
}

bool vo2_2tdevice_form_3::has_vertex_integrals() const
{
    return false;
}

bool vo2_2tdevice_form_3::has_custom_integrals() const
{
    return false;
}

bool vo2_2tdevice_form_3::has_cutcell_integrals() const
{
    return false;
}

bool vo2_2tdevice_form_3::has_interface_integrals() const
{
    return false;
}

bool vo2_2tdevice_form_3::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * vo2_2tdevice_form_3::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * vo2_2tdevice_form_3::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    switch (subdomain_id)
    {
    case 0:
        return new vo2_2tdevice_exterior_facet_integral_3_0();
    default:
        return nullptr;
    }
}

ufc::interior_facet_integral * vo2_2tdevice_form_3::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * vo2_2tdevice_form_3::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * vo2_2tdevice_form_3::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * vo2_2tdevice_form_3::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * vo2_2tdevice_form_3::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * vo2_2tdevice_form_3::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * vo2_2tdevice_form_3::create_default_cell_integral() const
{
    return nullptr;
}

ufc::exterior_facet_integral * vo2_2tdevice_form_3::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * vo2_2tdevice_form_3::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * vo2_2tdevice_form_3::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * vo2_2tdevice_form_3::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * vo2_2tdevice_form_3::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * vo2_2tdevice_form_3::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * vo2_2tdevice_form_3::create_default_overlap_integral() const
{
    return nullptr;
}


vo2_2tdevice_form_4::vo2_2tdevice_form_4() : ufc::form()
{
    // Do nothing
}

vo2_2tdevice_form_4::~vo2_2tdevice_form_4()
{
    // Do nothing
}

const char * vo2_2tdevice_form_4::signature() const
{
    return "982d0ffc29fc17aaeebd6488ddfcaa688bd39f8e07f41992f2ba54493a505f8ff607063846b0bd1a7abcad95023ef4e1dc8eae93aa41699fdd97e97927956385";
}

std::size_t vo2_2tdevice_form_4::rank() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_4::num_coefficients() const
{
    return 1;
}

std::size_t vo2_2tdevice_form_4::original_coefficient_position(std::size_t i) const
{
    if (i >= 1)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0};
    return position[i];
}

ufc::finite_element * vo2_2tdevice_form_4::create_coordinate_finite_element() const
{
    return new vo2_2tdevice_finite_element_1();
}

ufc::dofmap * vo2_2tdevice_form_4::create_coordinate_dofmap() const
{
    return new vo2_2tdevice_dofmap_1();
}

ufc::coordinate_mapping * vo2_2tdevice_form_4::create_coordinate_mapping() const
{
    return new vo2_2tdevice_coordinate_mapping_1();
}

ufc::finite_element * vo2_2tdevice_form_4::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new vo2_2tdevice_finite_element_3();
    default:
        return nullptr;
    }
}

ufc::dofmap * vo2_2tdevice_form_4::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new vo2_2tdevice_dofmap_3();
    default:
        return nullptr;
    }
}

std::size_t vo2_2tdevice_form_4::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_4::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_4::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_4::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_4::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_4::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_4::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_4::max_overlap_subdomain_id() const
{
    return 0;
}

bool vo2_2tdevice_form_4::has_cell_integrals() const
{
    return true;
}

bool vo2_2tdevice_form_4::has_exterior_facet_integrals() const
{
    return false;
}

bool vo2_2tdevice_form_4::has_interior_facet_integrals() const
{
    return false;
}

bool vo2_2tdevice_form_4::has_vertex_integrals() const
{
    return false;
}

bool vo2_2tdevice_form_4::has_custom_integrals() const
{
    return false;
}

bool vo2_2tdevice_form_4::has_cutcell_integrals() const
{
    return false;
}

bool vo2_2tdevice_form_4::has_interface_integrals() const
{
    return false;
}

bool vo2_2tdevice_form_4::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * vo2_2tdevice_form_4::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * vo2_2tdevice_form_4::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * vo2_2tdevice_form_4::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * vo2_2tdevice_form_4::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * vo2_2tdevice_form_4::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * vo2_2tdevice_form_4::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * vo2_2tdevice_form_4::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * vo2_2tdevice_form_4::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * vo2_2tdevice_form_4::create_default_cell_integral() const
{
    return new vo2_2tdevice_cell_integral_4_otherwise();
}

ufc::exterior_facet_integral * vo2_2tdevice_form_4::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * vo2_2tdevice_form_4::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * vo2_2tdevice_form_4::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * vo2_2tdevice_form_4::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * vo2_2tdevice_form_4::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * vo2_2tdevice_form_4::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * vo2_2tdevice_form_4::create_default_overlap_integral() const
{
    return nullptr;
}


vo2_2tdevice_form_5::vo2_2tdevice_form_5() : ufc::form()
{
    // Do nothing
}

vo2_2tdevice_form_5::~vo2_2tdevice_form_5()
{
    // Do nothing
}

const char * vo2_2tdevice_form_5::signature() const
{
    return "be6aeb33008b7095d60c7820f33d8adda909d9e32cd469fda469b958aa41ee1638d0e0cc7f311bcad21f0170cea469dbae59eef8817f812bac0be5e8ed3cb4df";
}

std::size_t vo2_2tdevice_form_5::rank() const
{
    return 2;
}

std::size_t vo2_2tdevice_form_5::num_coefficients() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_5::original_coefficient_position(std::size_t i) const
{
    throw std::runtime_error("Invalid original coefficient index.");
    return i;
}

ufc::finite_element * vo2_2tdevice_form_5::create_coordinate_finite_element() const
{
    return new vo2_2tdevice_finite_element_1();
}

ufc::dofmap * vo2_2tdevice_form_5::create_coordinate_dofmap() const
{
    return new vo2_2tdevice_dofmap_1();
}

ufc::coordinate_mapping * vo2_2tdevice_form_5::create_coordinate_mapping() const
{
    return new vo2_2tdevice_coordinate_mapping_1();
}

ufc::finite_element * vo2_2tdevice_form_5::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new vo2_2tdevice_finite_element_0();
    case 1:
        return new vo2_2tdevice_finite_element_0();
    default:
        return nullptr;
    }
}

ufc::dofmap * vo2_2tdevice_form_5::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new vo2_2tdevice_dofmap_0();
    case 1:
        return new vo2_2tdevice_dofmap_0();
    default:
        return nullptr;
    }
}

std::size_t vo2_2tdevice_form_5::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_5::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_5::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_5::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_5::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_5::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_5::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_5::max_overlap_subdomain_id() const
{
    return 0;
}

bool vo2_2tdevice_form_5::has_cell_integrals() const
{
    return true;
}

bool vo2_2tdevice_form_5::has_exterior_facet_integrals() const
{
    return false;
}

bool vo2_2tdevice_form_5::has_interior_facet_integrals() const
{
    return false;
}

bool vo2_2tdevice_form_5::has_vertex_integrals() const
{
    return false;
}

bool vo2_2tdevice_form_5::has_custom_integrals() const
{
    return false;
}

bool vo2_2tdevice_form_5::has_cutcell_integrals() const
{
    return false;
}

bool vo2_2tdevice_form_5::has_interface_integrals() const
{
    return false;
}

bool vo2_2tdevice_form_5::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * vo2_2tdevice_form_5::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * vo2_2tdevice_form_5::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * vo2_2tdevice_form_5::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * vo2_2tdevice_form_5::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * vo2_2tdevice_form_5::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * vo2_2tdevice_form_5::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * vo2_2tdevice_form_5::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * vo2_2tdevice_form_5::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * vo2_2tdevice_form_5::create_default_cell_integral() const
{
    return new vo2_2tdevice_cell_integral_5_otherwise();
}

ufc::exterior_facet_integral * vo2_2tdevice_form_5::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * vo2_2tdevice_form_5::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * vo2_2tdevice_form_5::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * vo2_2tdevice_form_5::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * vo2_2tdevice_form_5::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * vo2_2tdevice_form_5::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * vo2_2tdevice_form_5::create_default_overlap_integral() const
{
    return nullptr;
}


vo2_2tdevice_form_6::vo2_2tdevice_form_6() : ufc::form()
{
    // Do nothing
}

vo2_2tdevice_form_6::~vo2_2tdevice_form_6()
{
    // Do nothing
}

const char * vo2_2tdevice_form_6::signature() const
{
    return "d9f74e6df8e9fb4024d9f6f374746842f31d3a1b55da1db8117df3ce7f94ba1c0052a29ea08cad5b0b5b1745f8457480fbf1889fb37387929b2f3f698e8ca28b";
}

std::size_t vo2_2tdevice_form_6::rank() const
{
    return 1;
}

std::size_t vo2_2tdevice_form_6::num_coefficients() const
{
    return 10;
}

std::size_t vo2_2tdevice_form_6::original_coefficient_position(std::size_t i) const
{
    if (i >= 10)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    return position[i];
}

ufc::finite_element * vo2_2tdevice_form_6::create_coordinate_finite_element() const
{
    return new vo2_2tdevice_finite_element_1();
}

ufc::dofmap * vo2_2tdevice_form_6::create_coordinate_dofmap() const
{
    return new vo2_2tdevice_dofmap_1();
}

ufc::coordinate_mapping * vo2_2tdevice_form_6::create_coordinate_mapping() const
{
    return new vo2_2tdevice_coordinate_mapping_1();
}

ufc::finite_element * vo2_2tdevice_form_6::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new vo2_2tdevice_finite_element_0();
    case 1:
        return new vo2_2tdevice_finite_element_3();
    case 2:
        return new vo2_2tdevice_finite_element_2();
    case 3:
        return new vo2_2tdevice_finite_element_2();
    case 4:
        return new vo2_2tdevice_finite_element_2();
    case 5:
        return new vo2_2tdevice_finite_element_2();
    case 6:
        return new vo2_2tdevice_finite_element_2();
    case 7:
        return new vo2_2tdevice_finite_element_2();
    case 8:
        return new vo2_2tdevice_finite_element_2();
    case 9:
        return new vo2_2tdevice_finite_element_2();
    case 10:
        return new vo2_2tdevice_finite_element_2();
    default:
        return nullptr;
    }
}

ufc::dofmap * vo2_2tdevice_form_6::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new vo2_2tdevice_dofmap_0();
    case 1:
        return new vo2_2tdevice_dofmap_3();
    case 2:
        return new vo2_2tdevice_dofmap_2();
    case 3:
        return new vo2_2tdevice_dofmap_2();
    case 4:
        return new vo2_2tdevice_dofmap_2();
    case 5:
        return new vo2_2tdevice_dofmap_2();
    case 6:
        return new vo2_2tdevice_dofmap_2();
    case 7:
        return new vo2_2tdevice_dofmap_2();
    case 8:
        return new vo2_2tdevice_dofmap_2();
    case 9:
        return new vo2_2tdevice_dofmap_2();
    case 10:
        return new vo2_2tdevice_dofmap_2();
    default:
        return nullptr;
    }
}

std::size_t vo2_2tdevice_form_6::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_6::max_exterior_facet_subdomain_id() const
{
    return 2;
}

std::size_t vo2_2tdevice_form_6::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_6::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_6::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_6::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_6::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t vo2_2tdevice_form_6::max_overlap_subdomain_id() const
{
    return 0;
}

bool vo2_2tdevice_form_6::has_cell_integrals() const
{
    return true;
}

bool vo2_2tdevice_form_6::has_exterior_facet_integrals() const
{
    return true;
}

bool vo2_2tdevice_form_6::has_interior_facet_integrals() const
{
    return false;
}

bool vo2_2tdevice_form_6::has_vertex_integrals() const
{
    return false;
}

bool vo2_2tdevice_form_6::has_custom_integrals() const
{
    return false;
}

bool vo2_2tdevice_form_6::has_cutcell_integrals() const
{
    return false;
}

bool vo2_2tdevice_form_6::has_interface_integrals() const
{
    return false;
}

bool vo2_2tdevice_form_6::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * vo2_2tdevice_form_6::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * vo2_2tdevice_form_6::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    switch (subdomain_id)
    {
    case 0:
        return new vo2_2tdevice_exterior_facet_integral_6_0();
    case 1:
        return new vo2_2tdevice_exterior_facet_integral_6_1();
    default:
        return nullptr;
    }
}

ufc::interior_facet_integral * vo2_2tdevice_form_6::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * vo2_2tdevice_form_6::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * vo2_2tdevice_form_6::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * vo2_2tdevice_form_6::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * vo2_2tdevice_form_6::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * vo2_2tdevice_form_6::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * vo2_2tdevice_form_6::create_default_cell_integral() const
{
    return new vo2_2tdevice_cell_integral_6_otherwise();
}

ufc::exterior_facet_integral * vo2_2tdevice_form_6::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * vo2_2tdevice_form_6::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * vo2_2tdevice_form_6::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * vo2_2tdevice_form_6::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * vo2_2tdevice_form_6::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * vo2_2tdevice_form_6::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * vo2_2tdevice_form_6::create_default_overlap_integral() const
{
    return nullptr;
}

